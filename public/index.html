<!DOCTYPE html>
<html>
  <head>
    <link href="./assets/style.css" rel="stylesheet" type="text/css" />
    <link href="./assets/dank-mono.css" rel="stylesheet" type="text/css" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto:400,500,700"
    />
    <!-- <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500"
    /> -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/styles/github.min.css"
    />
  </head>
  <body>
    <div class="chapter cover">
      <img src="./assets/.gitbook/book-cover.png" id="cover" />
    </div>
    <div class="chapter">
  <h1 id="vorwort">Vorwort</h1>
<p>In diesem Buch geht es mir darum einen Einstieg zu ermöglichen, fortgeschrittene Themen aufzugreifen und dabei möglichst React Best-Practices zu vermitteln. Wenn ihr mit dem Buch nicht nur versteht wie etwas funktioniert sondern auch warum, dann habe ich mein Ziel erfüllt. Nun hat jeder Entwickler andere Vorstellungen davon welche Methoden die besten sind und wie man am einfachsten, effizientesten oder schönsten Code schreibt. Allerdings halte ich mich hier stark an die Empfehlungen von den Core-Entwicklern bei Facebook, die die ebenfalls von der Community gut angenommenen Empfehlungen von AirBnB und noch einiger anderer Größen aus der „React-Szene“. Alles gewürzt mit einer Prise eigener Erfahrung.</p>
<p>So gibt es bspw. mehrere Wege wie man seine Anwendung später publiziert, ob man es mit Tools wie <strong>Browserify, Rollup</strong> oder <strong>Webpack</strong> zu einem Bundle packt oder nicht. Ob man seine Komponenten als ES2015-Klassen schreibt oder <code>createClass</code> aus „ES5-Zeiten“ verwendet. Dort wo ich es für sinnvoll erachte, werde ich auf die diversen gängigen Methoden eingehen um nicht nur Wege vorzugeben sondern auch Alternativen aufzuzeigen.</p>
<p>Ich möchte hier jedoch primär möglichst auf die modernsten, aktuellsten und in den meisten Fällen auch einfachsten Methoden eingehen, weshalb ich für die meisten Code-Beispiele von einem Setup mit <strong>Webpack</strong>, <strong>Babel</strong> und <strong>ES2015</strong> (und neuer) ausgehen werde, das ich im weiteren Verlauf aber noch einmal sehr genau beschreiben werde. Wer zuvor nie mit ES2015+ in Berührung kam wird sicherlich einen Augenblick länger benötigen die Beispiele zu verstehen, ich werde mich indes bemühen alle Beispiele verständlich zu halten und auch auf ES2015+ noch genauer eingehen. JavaScript-Grundkenntnisse sollten jedoch bei der Lektüre vorhanden sein.</p>
<p>Dieses Buch deckt außerdem nur das Thema <strong>Einstieg in React</strong> ab und bietet keinen Einstieg in JavaScript. Grundsätzliche und an einigen wenigen Stellen sicherlich auch etwas tiefergehende Kenntnisse in JavaScript werden daher vorausgesetzt, wobei ich alles möglichst einsteigerfreundlich erkläre, auch wenn man bisher nur einigermaßen oberflächlich mit JavaScript in Kontakt war. Ich setze nicht voraus, dass jeder Leser fehlerfrei erklären kann wie ein JavaScript-Interpreter funktioniert, ich gehe aber sehr wohl davon aus, dass der Leser einigermaßen darüber Bescheid weiß, wie Scopes in JavaScript funktionieren, was ein Callback ist, wie <code>Promise.then()</code> und <code>Promise.catch()</code> funktionieren und wie das Prinzip asynchroner Programmierung mit JavaScript funktioniert.</p>
<p><strong>Aber keine Sorge:</strong> das klingt komplizierter als es am Ende eigentlich ist. Jeder Leser der in der Vergangenheit bereits bspw. mit jQuery gearbeitet hat, sollte beim größten Teil dieses Buches keine Verständnisprobleme haben und meinen Erklärungen folgen können.</p>
</div>
<div class="chapter">
  <h1 id="über-den-autor">Über den Autor</h1>
<p><strong>Manuel Bieh,</strong> seit 2012 als Freelancer im Bereich Frontend-/JavaScript-Entwicklung tätig.</p>
<p>Bevor ich mich dazu entschied als Freelancer zu arbeiten hatte ich ebenfalls bereits fast 10 Jahre Erfahrung als Web-Entwickler, meist mit dem Fokus auf Frontend-Entwicklung, in verschiedenen Unternehmen gesammelt. Lange Zeit habe ich mich eher als Generalist statt als Spezialist gesehen und so gab und gibt es wenige bekannte Frontend-Technologien mit denen ich während meiner beruflichen Laufbahn nicht schon mal zumindest kurz in Berührung gekommen wäre. Als Spezialist habe ich mich aber außer wenn es generell um JavaScript geht nirgendwo gesehen. Dies änderte sich dann schlagartig als mir ein befreundeter Entwickler in 2014 erstmals von React erzählte und ich dann durch Neugierde und ganz konkret durch ein Projekt für Zalando erstmals intensiver mit React in Kontakt kam.</p>
<p>Anfangs fremdelte ich noch etwas, so wie übrigens viele, die neu in React einsteigen, doch je länger und intensiver ich mich mit React auseinandersetzte, desto mehr schlug meine anfängliche Skepsis in Begeisterung um. Seitdem hat mich React so gepackt, dass seitdem meine Projekte allesamt so ausgewählt habe, dass dort React im Einsatz ist (und dessen Einsatz auch sinnvoll ist!). In dieser Zeit habe ich viel gelernt (und lerne auch immer noch jeden Tag dazu), habe dabei in kleinen Teams mit unter 5 und in recht großen Teams mit über 30 Leuten gearbeitet und dort mein React-Wissen eingebracht und selbst immer wieder neue Eindrücke und Wissen mitgenommen.</p>
<p>Die Komplexität von React ist dabei aber nicht zu unterschätzen. Und so ist es zwar möglich relativ schnell in ziemlich kurzer Zeit eine Anwendung mit React zu entwickeln. Wenn man aber Wert auf hohe Qualität legt gibt es dort viele Stellschrauben an denen man drehen kann um Code-Qualität, Performance und Wartbarkeit zu erhöhen, die teilweise auch Leuten nicht bekannt sind die schon viel und lange mit React entwickelt haben. Und so würde ich mich selbst nach mehrjähriger intensiver und täglicher Arbeit mit React sicher noch immer nicht als absoluten Experten bezeichnen. Aber ich denke, dass mit der Zeit dennoch genug Wissen zusammengekommen ist welches ich in Form dieses Buches weitergeben kann um euch den Einstieg zu erleichtern und auch noch den einen oder anderen Profi-Tipp an die Hand zu geben.</p>
</div>
<div class="chapter">
  <h1 id="i-–-einführung">I – Einführung</h1>
</div>
<div class="chapter">
  <h1 id="allgemeines">Allgemeines</h1>
<h2 id="was-ist-react-eigentlich-und-was-ist-es-nicht">Was ist React eigentlich und was ist es nicht?</h2>
<p>Zitieren wir hier an erster Stelle mal die React-Dokumentation, denn die bringen es sehr prägnant auf den Punkt:</p>
<blockquote>
  <p>[React is] a library for building user interfaces.</p>
</blockquote>
<p>Auch wenn die Erklärung sehr kurz ist kann man aus ihr alle essentiellen Dinge ableiten die wichtig sind für die Arbeit mit React und um zu verstehen worum es sich dreht. React ist erst einmal nur eine Library, kein vollständiges Framework mit unzähligen Funktionen mit dem ihr ohne weitere Abhängigkeiten komplexe Web-Anwendungen entwickeln könnt. Und da kommen wir auch schon zum zweiten Teil des Satzes: for building user interfaces.</p>
<p>React ist also erst einmal lediglich eine <strong>Library</strong> die es euch einfach macht <strong>Benutzerinterfaces</strong> zu entwickeln. Keine Services oder Methoden um API-Calls zu machen, keine built-in Models oder ORM. Nur User Interfaces. Sozusagen nur der View-Layer eurer Anwendung. That’s it! In diesem Zusammenhang liest man gelegentlich, dass React das „V“ in <strong>MVC</strong> (<em>Model-View-Controller</em>) oder <strong>MVVM</strong> (<em>Model-View-ViewModel</em>) darstellt. Das trifft es in meinen Augen ganz gut.</p>
<p>React bietet einen <strong>deklarativen</strong> Weg um den <strong>Zustand</strong> (<em>State</em>) eines User Interfaces zu beschreiben. Vereinfacht gesagt bedeutet das, ihr beschreibt mit eurem Code im Grunde explizit wie euer User Interface aussehen soll, abhängig davon in welchem State eine Komponente sich befindet. Einfaches Beispiel zur Veranschaulichung dieses Prinzips: ist ein Benutzer eingeloggt, zeige das Dashboard, ist er es nicht, zeige das Login-Formular.</p>
<p>Die Logik selbst befindet sich dabei komplett im JavaScript-Teil der Anwendung (dort, wo sie also immer hingehören sollte) und nicht in den Templates selbst, wie das bei den allermeisten anderen Web-Frameworks die Regel ist. Klingt erst einmal kompliziert, wird aber im weiteren Verlauf immer deutlicher was damit eigentlich gemeint ist.</p>
<p>React arbeitet dabei komponentenbasiert, d.h. man entwickelt gekapselte funktionale Komponenten die beliebig zusammengestellt (composed) und wiederverwendet werden können. Erweiterung von Komponenten ist zwar möglich, jedoch sehr unüblich in der React-Welt. Hier wird auch von offizieller Seite das Composition Model propagiert, bei dem mehrere Komponenten zu einem „Gesamtbild“ zusammengefügt werden statt mit Inheritance, also Vererbung zu arbeiten.</p>
<p>Bedeutet das jetzt also, dass ich keine komplexen Web-Anwendungen mit React entwickeln kann? Nein. Absolut nicht. React besitzt ein sehr großes, sehr aktives und zum großen Teil auch sehr hochqualitatives Ecosystem an Libraries, die wiederum auf React basieren, es erweitern oder ergänzen und so zu einem mächtigen Werkzeug werden lassen, das sich hinter großen Frameworks wie Ember oder Angular nicht verstecken braucht. Im Gegenteil. Ist man erst einmal in die Welt des React-Ökosystems eingetaucht und hat sich einen Überblick verschafft, hat man ganz schnell eine Reihe an wirklich guten Tools und Libraries gefunden mit denen man professionelle, super individuelle und hochkomplexe Anwendungen entwickeln kann.</p>
<h2 id="wann-sollte-ich-react-benutzen-und-wann-nicht">Wann sollte ich React benutzen und wann nicht?</h2>
<p>Insbesondere kurz nachdem React an Fahrt aufnahm wurde oft die Frage gestellt ob die Tage von jQuery nun gezählt sind, ob man nun alles mit React entwickeln kann oder gar soll oder wann der Einsatz von React sinnvoll oder vielleicht auch gar nicht sinnvoll ist.</p>
<p>React ist, wie wir bereits geklärt haben erst einmal eine Library für die Erstellung von User Interfaces. User Interfaces bedeuten immer Interaktion. Und Interaktion geht zwangsweise in den meisten Fällen einher mit State-Management. Ich drücke einen Knopf und ein Dropdown öffnet sich. Ich ändere also den Zustand von <em>geschlossen</em> auf <em>offen</em>. Ich gebe Daten in ein Eingabefeld ein und bekomme angezeigt ob meine eingegebenen Daten valide sind. Sind sie es nicht, ändert sich der Zustand des Eingabefeldes von <em>gültig</em> in <em>ungültig</em>. Und genau hier kommt React ins Spiel. Habe ich keine Interaktion oder „sich ändernde Daten“ auf meiner Seite weil ich z.B. eine reine statische Image-Seite für ein Unternehmen entwickle, brauche ich <em>wahrscheinlich</em> kein React.</p>
<p>Falsch umgesetzt kann React hier sogar schaden, da auf einer Image-Website oftmals der Content im Vordergrund steht und sofern man seine React-Komponenten nicht bereits serverseitig vorrendert, können die meisten Suchmaschinen mit der Seite erst einmal wenig anfangen. React macht es uns aber glücklicherweise sehr einfach unsere Komponenten serverseitig zu rendern, von daher ist das noch ein Problem welches sich in der Regel leicht beheben lässt.</p>
<p>Habe ich hingegen sehr viel Interaktion und ein Interface das sich oft aktualisiert, wird der Einsatz von React mit ziemlich hoher Wahrscheinlichkeit sehr viel Zeit und Nerven sparen. Grundsätzlich gilt hier die Faustregel: je mehr Interaktion in einer Website oder Web-Anwendung stattfindet und je komplexer diese ist, desto mehr lohnt sich der Einsatz von React. Das griffigste Beispiel sind hier <strong>Single Page Applications</strong> (<em>SPA</em>), bei denen die Anwendung nur einmal im Browser aufgerufen und initialisiert wird und jegliche weitere Interaktion und Kommunikation mit dem Server über XHR (den meisten besser bekannt als „AJAX-Requests“) abläuft.</p>
<p>Ich habe es kürzlich selbst in einem Projekt erlebt, dass ich ein Anmeldeformular entwickeln musste, welches mir ziemlich simpel erschien und ich startete erst einmal ohne React. Im Laufe der Entwicklung stellte sich heraus, dass zum Zwecke besserer Usability immer mehr (Hintergrund-)Interaktion nötig wurde. So sollte bspw. nachträglich eine automatische Live-Validierung von Formulardaten eingebaut und der Anmeldeprozess in 2 Schritte unterteilt werden, so dass ich recht zügig dann doch auf React zurückgegriffen habe, weil mir das manuelle State-Management und die <strong>imperative</strong> Veränderung des User Interfaces einfach zu umständlich wurde.</p>
<p>Imperativ bedeutet in dem Fall, dass ich dem Browser sage was er machen soll, wohingegen ich bei <em>deklarativem</em> Code, wie man ihn mit React schreibt, lediglich das gewünschte Endergebnis anhängig vom aktuellen Zustand beschreibe. Eines der Kernprinzipien von React. Um beim Beispiel von oben zu bleiben: statt zu sagen „ich bin nun eingeloggt, lieber Browser, bitte blende nun das Login-Formular aus und zeige mir das Dashboard“, definiere ich zwei Ansichten: So, lieber Browser, soll mein Interface aussehen wenn ich eingeloggt bin (Dashboard-Ansicht) und so, wenn ich es nicht bin (Login-Ansicht). Welche der Ansichten angezeigt wird entscheidet dann React anhand des Zustands der Komponente.</p>
<h2 id="wo-hat-react-seinen-ursprung">Wo hat React seinen Ursprung?</h2>
<p>React wurde ursprünglich von bzw. bei <strong>Facebook</strong> entwickelt und später dann, bereits 2013, unter der BSD Lizenz als Open Source der Öffentlichkeit zugänglich gemacht, die nach einigen Protesten in eine MIT-Lizenz geändert wurde. Und so basiert auch ein sehr großer Teil von Facebook auf React. Mittlerweile sollen sich dort sogar über <strong>50.000</strong> eigene Komponenten im Einsatz befinden. Was insofern schön ist, als dass Facebook dadurch natürlich ein großes Interesse an der permanenten Weiterentwicklung hat und man nicht befürchten muss, dass man seine Anwendung auf Basis einer Technologie entwickelt hat die plötzlich nicht mehr weiterentwickelt wird.</p>
<p>Die React Core-Entwickler leisten dabei sehr gute Arbeit darin, die Community frühzeitig in Entscheidungen mit einzubeziehen und mitdiskutieren zu lassen. Eigens dazu gibt es ein Github-Repository mit <a href="https://github.com/reactjs/rfcs">React RFCs</a> („Request for Comments“), mittels dessen geplante Änderungen frühzeitig zur Diskussion gestellt werden und mittels dessen dem React-Team auch eigene Vorschläge unterbreitet werden können.</p>
<p><strong>Breaking Changes</strong>, also Änderungen die nicht abwärtskompatibel sind, folgen einem festen <em>Deprecation Schema</em> und so werden Methoden, Eigenschaften und Funktionen deren Entfernung geplant ist erst einmal für einige Zeit mit aussagekräftigen <strong>Deprecation Warnings</strong> versehen und sogar Tools bereitgestellt, mit denen sich alter Code weitestgehend automatisiert anpassen lässt (<a href="https://github.com/reactjs/react-codemod">React-Codemod</a>). React hält sich hier strikt an Semver-Konventionen.</p>
<p>Dies bedeutet das nur neue Major-Releases (<code>16.x.x</code> auf <code>17.x.x</code>) Breaking Changes enthalten, Minor-Releases (bspw. <code>16.2.x</code> auf <code>16.3.x</code>) enthalten neue Features oder bekommen Deprecation Warnings, die den Entwickler auf kommende Major-Releases vorbereiten während Patch-Releases (bspw.<code>16.3.0</code> auf <code>16.3.1</code>) lediglich Bugfixes beinhalten.</p>
<p>Vor dem Release von Major oder Minor Releases gibt es regelmäßig auch alpha, beta und rc (Release Candidate) Versionen, mit denen man vorab schon einen Blick auf kommende Features werfen kann. Diese sind aber jeweils mit Vorsicht zu genießen, da sich die Funktionsweise neuer Features bis zum endgültigen Release noch ändern könnten.</p>
<p class="has-image"><span><img src="./assets/.gitbook/deprecation-warning.png" alt="Beispiel für eine Deprecation Warning" /><span class="caption">Beispiel für eine Deprecation Warning</span></span></p>
<p>Dies ist sicher dem Umstand geschuldet, dass eben auch bei Facebook sehr viele React-Komponenten im Einsatz sind und man dort nicht einfach mal eben tiefgreifende Änderungen vornehmen kann ohne Probleme zu verursachen. Die Gedanken und Begründungen der Entwickler lassen sich dabei jederzeit ausführlich im Github Issue-Tracker verfolgen, alle wichtigen Änderungen werden dabei in sog.<a href="https://github.com/facebook/react/issues?utf8=%E2%9C%93&q=is%3Aissue%20is%3Aopen%20umbrella"> Umbrella-Tickets</a> zusammengefasst.</p>
</div>
<div class="chapter">
  <h1 id="ab-ins-kalte-wasser">Ab ins kalte Wasser</h1>
<p>Nun hatten wir bereits das „Was“, das „Wann“ und das „Wo“. Kommen wir also zum „Wie“ und schreiben unsere erste kleine <strong>React-Komponente</strong>. Neben <strong>React</strong> selbst benötigen wir für die Ausgabe unserer App im Browser auch das Package <strong>ReactDOM</strong> um unsere Anwendung <strong>mounten</strong> zu können, also grob gesagt: im Browser nutzbar zu machen.</p>
<p>Ein sehr minimalistisches Setup um schnell mit React loslegen zu können, sieht wie folgt aus:</p>
<pre><code class="hljs markup language-markup"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hallo React!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">crossorigin</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/react@16.8.4/umd/react.development.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">crossorigin</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/react-dom@16.8.4/umd/react-dom.development.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">
<span class="hljs-comment">// Platzhalter für unsere erste Komponente</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Wir erstellen also das Grundgerüst für ein gewöhnliches HTML-Dokument und laden <strong>React</strong> und <strong>ReactDOM</strong> in der jeweils aktuellsten Stable-Version vom unpkg-CDN die uns dann jeweils als globale Variable im <code>window</code> Objekt unter <code>window.React</code> und <code>window.ReactDOM</code> zur Verfügung stehen. Ansonsten sehen wir hier vorerst nur eine leere Seite mit einem (noch inhaltlosen) <code>&lt;div id="app"&gt;</code>. Dieses div nutzen wir gleich als sogenannte <strong>Mount-Node</strong>, um dort unsere erste React-Komponente anzuzeigen.</p>
<div class="hint hint--info">
<p>Sind mehrere React-Komponenten im Spiel redet man üblicherweise von einer <strong>App</strong>, <strong>WebApp</strong> oder <strong>Single Page App</strong>. Die Grenzen ab wann eine Komponente als App bezeichnet wird sind dabei aber fließend. Einige Entwickler reden auch schon bei einer einzigen Komponente von einer App.
Eine feste Definition gibt es dafür nicht.</p>
</div>
<p>Starten wir also klassischerweise mit dem üblichen „Hello World“ Beispiel und setzen das Script an die Stelle an der sich oben der Platzhalter befindet:</p>
<pre><code class="hljs javascript language-javascript">&lt;script&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> React.createElement(
      <span class="hljs-string">'div'</span>,
      {<span class="hljs-attr">id</span>: <span class="hljs-string">'hello-world'</span>},
      <span class="hljs-string">'Hello World'</span>
    );
  }
}
ReactDOM.render(
  React.createElement(HelloWorld),
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'app'</span>)
);
<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre>
<p>Und damit haben wir bereits die erste einfache React-Komponente implementiert! Setzen wir diesen Code nun an die Stelle unseres Platzhalters aus dem vorangegangenen Code-Snippet. Sehen wir im Browser die folgende Ausgabe:</p>
<p class="has-image"><span><img src="./assets/.gitbook/first-component.png" alt="Unsere erste React-Komponente im Browser." /><span class="caption">Unsere erste React-Komponente im Browser.</span></span></p>
<p>Sieht für’s Erste einmal gar nicht so kompliziert aus, oder? Gehen wir den Code einmal Schritt für Schritt durch. Die relevanten Stellen im Code habe ich fett hervorgehoben.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span></span></code></pre>
<p>Hier geben wir dem Kind seinen Namen. Unsere Komponente hat in dem Fall den Namen <strong>HelloWorld</strong>. Bei der Namensgebung sind der Fantasie grundsätzlich keine Grenzen gesetzt, doch Achtung: React-Komponenten müssen stets mit einem Großbuchstaben beginnen! So wäre helloWorld also kein gültiger Name für eine Komponente, HELLOWORLD hingegen schon (wenn auch sehr unüblich).</p>
<p>Die gängige Art der Benennung von Komponenten folgt der <strong>UpperCamelCase</strong>-Form. Auch längere, selbsterklärende Namen sind nicht unüblich. So wäre also ein Name wie <strong>UserNotificationView</strong> für eine Komponente keineswegs exotisch.</p>
<pre><code class="hljs jsx language-jsx">extends React.Component</code></pre>
<p>Hier erweitern wir schließlich die React interne Klasse <code>React.Component</code> wodurch unsere Klasse erst einmal zu einer Komponente wird die wir in React nutzen können. Neben der <code>React.Component</code> gibt es außerdem auch die <code>React.PureComponent</code> als Komponenten-Klasse, sowie eine zweite Form, die sogenannte <em>Stateless Functional Component</em>. Diese ist lediglich eine JavaScript-Funktion, die einem bestimmten Muster folgt. Beide werden im weiteren Verlauf noch ausführlich beleuchtet und sind an dieser Stelle zum Grundverständnis erst einmal weniger wichtig.</p>
<pre><code class="hljs jsx language-jsx">render();</code></pre>
<p>Unsere Komponente besteht lediglich aus dem einzigen zwingenden Bestandteil einer Komponente, nämlich der <code>render()</code>-Methode. Mittels dieser wird React mitgeteilt wie die entsprechende Komponente dargestellt (sprich: „gerendert“) werden soll. Eine Komponente hat zwingend einen <code>return</code>-Wert. Dieser kann entweder ein explizites <code>null</code> sein, um bewusst nichts anzuzeigen (jedoch nicht <code>undefined</code>!), ein React-Element oder ab Version 16 auch ein Array.</p>
<p>Im Falle eines Arrays darf dieser Strings, Numbers, React-Elemente oder ebenfalls <code>null</code> als Werte enthalten. Die <code>render()</code>-Methode dient also dazu <strong>deklarativ</strong> den Zustand unseres Interfaces zu beschreiben. All das, was wir aus ihr per <code>return</code> zurückgeben, zeigt uns React beim Render als Ausgabe im Browser an.</p>
<p>Auch wenn man in der Gestaltung seiner JavaScript-Klassen natürlich vollkommen frei ist und dies daher nicht zwingend notwendig ist, so wird die <code>render()</code>-Methode der Übersicht halber in der Regel meist als letzte Methode einer Komponente definiert. So wird es z.B. in den Code-Guidelines von AirBnB, dessen Entwickler in der React-Szene sehr aktiv sind, aber auch von vielen anderen bekannten Entwicklern vorgegeben oder zumindest empfohlen. Aus eigener Erfahrung kann ich sagen, dass es die tägliche Arbeit mit React deutlich erleichtert sich an diese Empfehlung zu halten<strong>.</strong></p>
<p class="has-image"><span><img src="./assets/.gitbook/react-no-render-error.png" alt="Fehlermeldungen bei fehlender render()-Methode" /><span class="caption">Fehlermeldungen bei fehlender render()-Methode</span></span></p>
<p class="has-image"><span><img src="./assets/.gitbook/invalid-react-element.png" alt="Fehlermeldung bei fehlerhafter render()-Methode" /><span class="caption">Fehlermeldung bei fehlerhafter render()-Methode</span></span></p>
<pre><code class="hljs jsx language-jsx">React.createElement();</code></pre>
<p>Wie erwähnt gibt die <code>render()</code>-Methode einer React-<strong>Komponente</strong> in den meisten Fällen ein React-<strong>Element</strong> zurück. React-Elemente sind sozusagen die kleinsten aber dennoch gleichzeitig auch die wesentlichen Bausteine in einer React-Anwendung und beschreiben, was der Benutzer letztendlich auf seinem Bildschirm sieht. Neben <code>React.cloneElement()</code> und <code>React.isValidElement()</code> ist <code>React.createElement()</code> zudem eine von lediglich 3 Top-Level API-Methoden (sieht man von mittlerweile veralteten (<em>deprecated</em>) Methoden einmal ab).</p>
<p>Die Methode erwartet 1-n Parameter:</p>
<ol>
<li>„Typ“, das können HTML-Elemente als String sein, also bspw. <code>'div'</code>, <code>'span'</code> oder <code>'p'</code> aber auch andere React-Komponenten</li>
<li>sog. „Props“, das sind im grundlegenden Sinn schreibgeschützte (<em>readonly</em>) „Eigenschafts-Objekte“ einer Komponente. Abgeleitet vom engl. <em>Properties</em> eben.</li>
<li>sowie beliebig viele Child-Elemente, die selbst wieder React-Elemente, Arrays, Funktionen oder auch einfacher Text sein können. Eine Komponente muss aber nicht zwingend auch Child-Elemente besitzen.</li>
</ol>
<p>Letztendlich ist ein React-Element unter der Haube nichts weiter als ein unveränderliches (<em>immutable</em>) JavaScript-Objekt zur Beschreibung von Eigenschaften, die React mitteilen wie etwas (und was) dargestellt werden soll. React erstellt nach dieser Beschreibung den sog. <strong>Virtual DOM</strong>. Dieser stellt eine Repräsentation des HTML-Baums in Form eines JavaScript-Objekts dar. Dieser Virtual DOM wird anschließend von React dazu verwendet, um möglichst nur die Teile einer Anwendung zu aktualisieren, in denen auch tatsächlich eine Änderung vorgenommen wurde wenn der Benutzer mit der Anwendung interagiert, Daten verändert oder Events auslöst.</p>
<p>Dadurch, dass React nicht einfach bei jeder State-Änderung die komplette Anwendung neu in den DOM schreibt, was aus Performance-Sicht sehr kostspielig wäre, sondern mittels eines <strong>Reconciliation</strong> (zu deutsch etwa <em>„Abgleich“</em>) genannten Prozesses zuvor vergleicht was geändert wurde, somit die Schreibvorgänge auf ein Minimum reduziert, wird ein zum Teil enormer Geschwindigkeitsvorteil erreicht gegenüber anderen Frameworks und Libraries die viele DOM-Operationen vornehmen.</p>
<p>Bei der täglichen Arbeit wird man <code>React.createElement()</code> jedoch für gewöhnlich niemals in dieser Form aufrufen, da uns <strong>JSX</strong>, eine von Facebook entwickelte Syntax-Erweiterung für JavaScript, diese Arbeit abnehmen und massiv erleichtern wird. Dennoch halte ich es für wichtig von ihrer Existenz zu wissen um zu verstehen wie JSX im Hintergrund arbeitet um so mögliche Fehlerquellen ausschließen zu können.</p>
<p>JSX sieht auf den ersten Blick aus wie HTML bzw. XML/XHTML, jedoch mit deutlich erweitertem Funktionsumfang und der Möglichkeit JavaScript-Ausdrücke darin zu verwenden. JSX ist eine Abstraktion um die Art, wie man React-Elemente erstellt, für den Entwickler <strong>deutlich</strong> zu vereinfachen. So würde unser obiges Beispiel:</p>
<pre><code class="hljs jsx language-jsx">React.createElement(<span class="hljs-string">'div'</span>, { <span class="hljs-attr">id</span>: <span class="hljs-string">'hello-world'</span> }, <span class="hljs-string">'Hello World'</span>);</code></pre>
<p>würde in JSX ganz einfach wie folgt geschrieben werden:</p>
<pre><code class="hljs jsx language-jsx">&lt;div id=<span class="hljs-string">"hello-world"</span>&gt;Hello World&lt;<span class="hljs-regexp">/div&gt;</span></code></pre>
<p>Was für viele Einsteiger in React erst einmal sehr befremdlich wirkt, ich habe in diesem Zusammenhang mal den schönen Begriff <strong>JSX-Schock</strong> gelesen, stellt sich aber nach etwas Rumspielerei jedoch sehr schnell als unglaublich praktisch heraus und ist meines Erachtens einer der wesentlichen Gründe warum React letztendlich so viel an Beliebtheit in so kurzer Zeit gewonnen hat.</p>
<p>Zurück zum Wesentlichen: unsere Komponente bekommt hier also über den <code>return</code>-Wert der <code>render()</code>-Methode mitgeteilt, dass sie ein Element vom typ <code>div</code> mit der id <code>hello-world</code> und dem Child-Element (in dem Fall ein Textknoten) mit dem Inhalt <code>Hallo Welt</code> darstellen soll.</p>
<pre><code class="hljs jsx language-jsx">ReactDOM.render(Element, Container);</code></pre>
<p>Zu guter Letzt kommt mit <code>ReactDOM</code> die zweite Library ins Spiel. <strong>ReactDOM</strong> ist zuständig für das Zusammenspiel von React mit dem DOM (<em>Document Object Model</em>), also oberflächlich ausgedrückt: dem <strong>Web-Browser</strong>. Wie auch schon React selbst besitzt ReactDOM nur sehr wenige Top-Level API-Methoden. Wir konzentrieren uns vorerst mal auf die <code>render()</code>-Methode, die sozusagen das Herzstück von ReactDOM im Browser ist.</p>
<p>Trotz der Namensgleichheit hat diese <strong>erst einmal nicht direkt</strong> etwas mit der Methode innerhalb von React-Komponenten zu tun sondern dient lediglich dazu ein React-Element in eine angegebene <strong>„Root-Node“</strong> zu rendern, also stumpf ausgedrückt: anzuzeigen. In unserem Fall wird hier unsere <code>HelloWorld</code>-Komponente in das <code>&lt;div id="app"&gt;</code> gerendert. Die Root-Node wird dabei <strong>nicht ersetzt</strong>, sondern die Komponente wird <strong>innerhalb des Containers</strong> eingesetzt.</p>
<p><strong>ReactDOM</strong> sorgt also dafür, <strong>dass</strong> wir die angegebene Komponente überhaupt erst einmal im Browser sehen können. <strong>Was</strong> wir dort genau sehen haben wir zuvor in der <code>render()</code>-Methode der Komponente über das angegebene React-Element als <code>return</code>-Wert beschrieben. Beim Aufruf von <code>ReactDOM.render()</code> wird dabei das als ersten Parameter angegebene <strong>React-Element</strong> in den als zweiten Parameter angegebenen <strong>Container</strong> gerendert.</p>
<div class="hint hint--info">
<p>Beim ersten Aufruf der <code>ReactDOM.render()</code> Funktion wird sämtlicher möglicherweise vorhandene Inhalt des Ziel-Containers durch den von React ermittelten, darzustellenden Inhalt ersetzt. Bei jedem weiteren Aufruf verwendet React einen internen Vergleichs-Algorithmus für bestmögliche Effizienz, um nicht die komplette Anwendung vollständig neu zu rendern!</p>
<p>In der Praxis ist das allerdings weniger von Relevanz, da die <code>ReactDOM.render()</code> Funktion bei der Erstellung von Single Page Apps üblicherweise nur einmalig ausgeführt wird, für gewöhnlich beim Laden einer Seite. React verändert dabei auch niemals den Ziel-Container selbst, sondern lediglich dessen Inhalt. Besitzt das Container-Element also eigene Attribute wie Klassen, IDs oder data-Attribute bleiben diese auch nach dem Aufruf von <code>ReactDOM.render()</code> erhalten.</p>
</div>
<p>Damit ist das generelle Funktionsprinzip von React erst einmal erklärt, unsere erste Komponente ist implementiert und im Browser zu sehen!</p>
</div>
<div class="chapter">
  <h1 id="tools-und-setup">Tools und Setup</h1>
<h2 id="tools">Tools</h2>
<p>Um störungsfrei und komfortabel mit React arbeiten zu können sollten einige Bedingungen erfüllt sein. Nicht alles davon ist <strong>zwingend</strong> notwendig, es erleichtert das Entwicklerleben jedoch ungemein, weswegen ich dennoch <strong>dringend</strong> dazu rate und auch bei allen folgenden Beispielen davon ausgehen werde, dass ihr diese Tools installiert habt:</p>
<h3 id="nodejs-und-npm">Node.js und npm</h3>
<p>Node werden die meisten möglicherweise als „serverseitiges JavaScript“ kennen, das ist allerdings nicht die ganze Wahrheit. In erster Linie ist <strong>Node</strong> einmal eine <strong>JavaScript-Laufzeitumgebung</strong>, die sich eben hervorragend für Netzwerkanwendungen eignet, also klassische Webserver. Darüber hinaus bringt <strong>Node</strong> auch ein Tool zur Paketverwaltung mit, nämlich <strong>npm</strong>, mit dem sich spielend einfach neue JavaScript-Libraries auf dem eigenen Rechner installieren lassen. Außerdem lassen sich auch eigene Kommandozeilen-Scripts damit schreiben und ausführen, was sich später noch als sehr praktisch erweisen wird.</p>
<p>Statt Node direkt zu installieren, empfehle ich <a href="https://github.com/creationix/nvm"><strong>nvm</strong></a> (Node Version Manager) für Mac und Linux bzw. <a href="https://github.com/coreybutler/nvm-windows"><strong>nvm-windows</strong></a> für Windows. Nvm hat den Vorteil, dass es einerseits keine Admin-Rechte benötigt um Packages global zu installieren und man andererseits mit einem simplen Befehl auf der Kommandozeile (<code>nvm install [version]</code>) die auf dem System installierte Version aktualisieren kann. Für einer Liste aller verfügbaren Version kannst du ganz einfach <code>nvm ls-remote</code> (Mac/Linux) bzw. <code>nvm list available</code> (Windows) benutzen. Ich empfehle im weiteren Verlaufe dieses Buch die aktuelle LTS (Long Term Support) Version zu benutzen. LTS Versionen sind stabile Versionen die auch längere Zeit Updates erhalten.</p>
<h3 id="yarn">Yarn</h3>
<p>Während <strong>Node</strong> mit <strong>npm</strong> bereits einen guten und soliden Package-Manager mitbringt, geht <strong>yarn</strong> noch ein Stück weiter, bietet besseres caching, dadurch auch bessere Performance, einfachere Kommandos und kommt darüber hinaus, wie React, ebenfalls aus dem Hause Facebook und wurde dort entwickelt u.a. um die Arbeit mit React noch etwas angenehmer zu gestalten. Während alles, was hier im weiteren Verlauf des Buches beschrieben wird, auch mit <strong>npm</strong> ausgeführt werden kann, würde ich dennoch empfehlen <strong>Yarn</strong> zu installieren, da dies gerade in React-Kreisen mehr und mehr an Gewicht gewinnt, insbesondere wegen seiner Einfachheit und seiner verbesserten Performance ggü. <strong>npm</strong>. Sind <strong>Node</strong> und <strong>npm</strong> erst einmal installiert, lässt sich <strong>yarn</strong> als globales Package über <strong>npm</strong> installieren:</p>
<pre><code class="hljs bash language-bash">npm install --global yarn</code></pre>
<p>oder einfach kurz:</p>
<pre><code class="hljs bash language-bash">npm i -g yarn</code></pre>
<p>Wir haben gerade außerdem unser erstes Package installiert. Easy! Das Commandline-Flag <code>--global</code> (bzw. <code>-g</code>) sorgt dabei dafür, dass die <code>yarn</code> Executable global installiert wird und von überall auf eurem Gerät auf der Kommandozeile ausgeführt werden kann.</p>
<h3 id="babel">Babel</h3>
<p>Babel ist ein Tool, das für gewöhnlich lediglich als Dependency (Abhängigkeit) und für gewöhnlich als npm-Paket in React basierten Projekten zum Einsatz kommt und an dieser Stelle nicht explizit installiert werden muss. Babel erlaubt es nicht oder <em>noch</em>-nicht standardkonformen oder noch nicht von allen gängigen Browsern unterstützten JavaScript-Code in interpretierbaren und ausführbaren Code zu <em>transpilieren</em>.</p>
<div class="hint hint--info">
<p><strong>Transpilieren</strong> (engl. <em>transpiling</em>) nennt man einen Prozess, bei dem der Sourcecode von einer Sprache in ein entsprechendes funktional identisches Gegenstück einer anderen Sprache umgewandelt wird. In unserem Fall eben von JSX oder ES2015+ in valides, ausführbares und vom Browser unterstütztes JavaScript.</p>
</div>
<p>Babel besteht aus einem Core-Modul (<code>@babel/core</code>) das lediglich einige APIs bereitstellt, die dann von <strong>Plugins</strong> für das entsprechende Transpiling verwendet werden. Diese Plugins werden oft zu sog. <strong>Presets</strong> zusammengefasst, die dann wiederum mehrere Plugins gleichzeitig installieren. Die in React basierten Projekten üblichsten Presets sind <code>@babel/preset-react</code> (um JSX zu lesen und zu übersetzen) und <code>@babel/preset-env</code>, welches abhängig von einer Ziel-Umgebung modernes JavaScript so umschreibt, dass es eben auch ältere Browser verstehen.</p>
<p>Das @-Zeichen vor dem Namen bedeutet dabei, dass es sich um eine Organisation innerhalb der npm Registry (dem npm-Paketverzeichnis) handelt und kann als eine Art Namespace betrachtet werden. Im Fall von Babel findet man dort die offiziellen Pakete die von den Babel-Maintainern dort veröffentlich werden. Bevor Babel in der Version 7 erschien gab es diese Organisation noch nicht und die Pakete wurden mit einem Bindestrich im Namen getrennt. So hieß <code>@babel/preset-react</code> eben <code>babel-preset-react</code>, <code>@babel/core</code> war <code>babel-core</code> usw. Also nicht verwirren lassen, sollte euch in einem Projekt mal <code>babel-core</code> statt <code>@babel/core</code> begegnen. In diesem Fall handelt es sich also einfach um Babel 6 (oder eine ältere Version). Allerdings kommt es gelegentlich vor, dass Entwickler deren Plugins oder Presets nicht offizieller Teil von Babel sind, diese ebenfalls mit <code>babel-</code> prefixen während die Pakete dennoch mit Babel 7 arbeiten. Hier hilft in der Regel nur ein Blick in die Readme des jeweiligen Pakets.</p>
<p>Die Presets, die ich bei der Arbeit mit React verwende (und gleichzeitig auch empfehle) sind:</p>
<ul>
<li><code>@babel/preset-env</code></li>
<li><code>@babel/preset-react</code></li>
<li><code>@babel/plugin-proposal-object-rest-spread</code></li>
<li><code>@babel/plugin-proposal-class-properties</code></li>
<li><code>@babel/plugin-syntax-dynamic-import</code></li>
</ul>
<p>Wer mit Flow oder TypeScript als statischen Type Checkern arbeiten möchte benötigt darüber hinaus noch <code>@babel/preset-flow</code> für Flow bzw. <code>@babel/preset-typescript</code> für TypeScript.</p>
<p>Installiert werden alle erwähnten Pakete via <code>yarn add --dev [paket]</code> bzw <code>npm install --save-dev [paket]</code>.</p>
<h3 id="webpack">Webpack</h3>
<p>Webpack ist ebenfalls eins der zentralen Tools im React-Ecosystem ohne das ein effizentes Arbeiten mit React kaum möglich oder zumindest deutlich umständlicher wäre. Hier handelt es sich um einen sog. <strong>Module-Bundler</strong>, der Modul basierte Entwicklung, wie sie manch einer vielleicht bereits aus NodeJS kennen mag, in den Browser bringt. Dadurch wird es ermöglicht Anwendungscode übersichtlich in einzelnen Files zu verteilen, die jeweils ihre Abhängigkeiten über <code>import</code> oder <code>require()</code> in ihren eigenen <strong>Module-Scope</strong> laden und damit innerhalb des Moduls verfügbar machen. Am Ende fällt dann nur noch eine einzelne JavaScript-Datei heraus (auf Wunsch auch mehrere), so dass nicht mehr jede einzelne unserer Komponenten, und das können schnell mal über 100 werden, einzeln über <code>&lt;script src="..."&gt;&lt;/script&gt;</code> im HTML eingebunden werden muss.</p>
<p>Wow. Klingt unfassbar kompliziert, passiert aber nach einigen wenigen Beispielen nahezu intuitiv von ganz allein und hat man sich erst einmal daran gewöhnt, wird man sich fragen wie man jemals ohne Module-Bundler arbeiten konnte.</p>
<p>Neben dem Module-Bundling selbst kann <strong>Webpack</strong> auch beigebracht werden Dateien mit JSX durch Babel in JavaScript zu transpilieren, Bilder, Stylesheets oder andere Assets in einen build-Ordner zu kopieren der später auf einen Server deployed wird und viele andere Dinge. Wie eine solche Konfiguration aussehen kann beleuchten wir später noch einmal genau, weshalb das Webpack Kommandozeilen-Tool auch an dieser Stelle noch nicht installiert werden muss.</p>
<h3 id="eslint">ESLint</h3>
<p>ESLint ist ein sehr praktisches Tool zur statischen Code-Analyse. Es soll in erster Linie dazu dienen um Fehler im Programmcode zu erkennen, kann aber auch dazu genutzt werden um bspw. konsistente Regeln beim Codestil durchzusetzen oder dem Entwickler Hinweise für Optimierungsmöglichkeiten während des Entwickelns zu geben. ESLint bezeichnet sich selbst als „pluggable linting utility“, verspricht also besonderen Wert auf Erweiterbarkeit zu legen. Und so gibt es in der Tat allerhand nützliche Plugins für diverse Tools, Laufzeitumgebungen und Frameworks.</p>
<p>Im professionellen Umfeld aber auch in den meisten Open Source Projekten ist eine ESLint-Konfiguration mittlerweile üblich und nicht mehr wegzudenken. In React-Projekten haben sich insbesondere die ESLint-Plugins <code>eslint-plugin-react</code>, <code>eslint-plugin-babel</code> und <code>eslint-plugin-react-hooks</code> als solide Basis erwiesen.</p>
<p>Bei der Einrichtung entsprechender IDE-Plugins erscheinen dann deutlich sichtbare Warnungen an den Stellen, wo mit dem Code augenscheinlich etwas nicht gemäß den definierten Regeln abläuft:</p>
<p class="has-image"><span><img src="./assets/.gitbook/eslint-example.png" alt="Eine Warnung über eine nicht verwendete Variable und ein fehlendes Semikolon in VSCode" /><span class="caption">Eine Warnung über eine nicht verwendete Variable und ein fehlendes Semikolon in VSCode</span></span></p>
<h3 id="ide-editor-plugins">IDE-/Editor-Plugins</h3>
<p>Alle bekannten Editoren und IDEs wie bspw. Webstorm, Atom, Visual Studio Code oder Sublime (aber auch so ziemlich jeder andere moderne Editor oder IDE) bietet Plugins oder inzwischen sogar bereits nativ integrierte Funktionen für die bessere Unterstützung für <strong>React</strong> und <strong>JSX</strong>. Hier rate ich dringend zur Installation dieser Plugins, da diese in der Regel für deutlich besseres Syntax-Highlighting sorgen, teilweise Code-Vervollständigung und andere Nettigkeiten bieten.</p>
<p>In Atom ist das etwa <a href="https://atom.io/packages/language-babel">language-babel</a>, in VS Code gibt es hier u.a. <a href="https://marketplace.visualstudio.com/items?itemName=dzannotti.vscode-babel-coloring">Babel ES6/ES7</a> und in Sublime lohnt sich in Blick auf <a href="https://github.com/babel/babel-sublime">babel-sublime</a>. Nutzt ihr Webstorm, habt ihr seit Version 10 native Unterstützung für React Syntax-Highlighting. Auch Plugins für das eben erwähnte ESLint sind überaus sinnvoll. Dazu am Besten im Plugin-Manager eurer IDE oder eures Editors einfach nach ESLint suchen und das Plugin mit den meisten Installationen auswählen. Dies ist für gewöhnlich jeweils das offizielle ESLint-Plugin.</p>
<h3 id="browser-plugins">Browser-Plugins</h3>
<p>Für den Browser empfehle ich dringend jeweils die React-Devtools für <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">Chrome</a> und <a href="https://addons.mozilla.org/de/firefox/addon/react-devtools/">Firefox</a> zu installieren, für den späteren Verlauf außerdem die Redux-Devtools für beide Browser (<a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd">Chrome</a>, <a href="https://addons.mozilla.org/de/firefox/addon/remotedev/?">Firefox</a>). Die Devtools fügen sich nahtlos als neuer Tab in die bestehenden Browser-Devtools ein und bieten einen enormen Mehrwert beim Debugging von React-Komponenten.</p>
<p class="has-image"><span><img src="./assets/.gitbook/image.png" alt="Chrome mit installierten Devtools-Plugins für React und Redux" /><span class="caption">Chrome mit installierten Devtools-Plugins für React und Redux</span></span></p>
<p>So lässt sich bspw. der State direkt im Browser manipulieren und die Auswirkungen live beobachten. Ich würde soweit gehen und behaupten, dass ein effizientes Debugging ohne die Devtools-Erweiterungen kaum oder sogar gar nicht möglich ist.</p>
<h2 id="zero-config-setup">Zero Config Setup</h2>
<p>Manch einer hat in der Vergangenheit darüber gescherzt, dass man gut und gerne Tage damit verbringen kann ein Setup aufzusetzen bevor man die erste Zeile Code schreibt. Und in der Tat: ein ordentliches Setup ist wichtig, bestimmt es doch ein Stück weit auch die Qualität und Wartbarkeit der Anwendung, die man auf Basis seines Setups entwickelt.</p>
<p>Hier hat die große React-Community aber bereits sehr gute Vorarbeit geleistet. Und so listet die Seite JavaScriptStuff aktuell <strong>198 Projekte</strong> in der Rubrik <a href="https://www.javascriptstuff.com/react-starter-projects/"><strong>React Starter Projects</strong></a>. Auch Facebook selbst, bzw. konkret <strong>Dan Abramov</strong>, Core-Entwickler bei Facebook und Autor von <strong>Redux</strong>, ist dort mit <strong>Create-React-App</strong> („CRA“) vertreten. Das Projekt ist mit über 45.000 Stars auf Github mittlerweile so etwas wie der de-facto Standard wenn es um React Starter Projekte geht und beschreibt sich auf Github selbst mit:</p>
<blockquote>
  <p>Create React apps with no build configuration</p>
</blockquote>
<p>Und in der Tat, <strong>Create React App</strong> macht es gerade Einsteigern (aber nicht nur diesen) sehr einfach ein sehr robustes und gutes Setup mit nur einem Befehl auf der Kommandozeile zu erzeugen:</p>
<pre><code class="hljs bash language-bash">yarn create react-app projektname</code></pre>
<p>Wer stattdessen npm bevorzugt, muss momentan noch zwei Befehle ausführen:</p>
<pre><code class="hljs bash language-bash">npm install -g create-react-app</code></pre>
<p>… um die <strong>Create React App</strong> Executable global zu installieren und anschließend</p>
<pre><code class="hljs bash language-bash">create-react-app projektname</code></pre>
<p>Und schon wird im Ordner „<em>projektname</em>“ ein vollständiges React-Setup mit einigen kleinen Beispiel-Komponenten erzeugt. Ich würde empfehlen dies jetzt direkt mal zu tun, denn die ersten Code-Beispiele werden zu Beginn allesamt auf einem gewöhnlichen CRA-Setup basieren und können so recht einfach ausprobiert werden.</p>
<div class="hint hint--warning">
<p>Der Projektname muss den <a href="https://docs.npmjs.com/files/package.json#name">Kriterien für die <code>name</code>-Eigenschaft</a> des <code>package.json</code>-Formats von <strong>npm</strong> haben. Dies bedeutet, neben einigen anderen Kriterien, er darf <strong>nur Kleinbuchstaben</strong> beinhalten, <strong>keine Leerzeichen</strong> und darf aus <strong>maximal 214 Zeichen</strong> bestehen. Die vollständigen Kriterien finden sich in der <strong>npm-</strong>Dokumentation</p>
</div>
<p>Später werde ich euch dann zeigen wie ihr die <code>eject</code>-Funktion benutzt um eigene Änderungen an der Konfiguration vornehmen zu können. [TODO: in die tat umsetzen]. Aber für den Beginn (und auch noch recht weit darüber hinaus) reicht erst einmal das Basis-Setup, da dieses bereits sehr umfangreich ist und viele Themen abdeckt, so dass wir uns weniger mit dem Setup beschäftigen müssen und direkt in den Code eintauchen können.</p>
<p>Nachdem CRA das Basis-Setup erstellt und seine Paket-Abhängigkeiten (<em>Dependencies</em>) installiert hat gibt es uns noch eine kurze Anleitung wie wir mit CRA an unserem ersten React-Projekt arbeiten können.</p>
<pre><code class="hljs bash language-bash">$ create-react-app foobar

Creating a new React app <span class="hljs-keyword">in</span> /home/manuel/my-react-app.

Installing packages. This might take a couple of minutes.
Installing react, react-dom, and react-scripts...

Success! Created foobar at /home/manuel/my-react-app
Inside that directory, you can run several commands:

  yarn start
    Starts the development server.

  yarn build
    Bundles the app into static files <span class="hljs-keyword">for</span> production.

  yarn <span class="hljs-built_in">test</span>
    Starts the <span class="hljs-built_in">test</span> runner.

  yarn eject
    Removes this tool and copies build dependencies, configuration files
    and scripts into the app directory. If you <span class="hljs-keyword">do</span> this, you can’t go back!

We suggest that you begin by typing:

  <span class="hljs-built_in">cd</span> my-react-app
  yarn start

Happy hacking!</code></pre>
<h3 id="yarn-start">yarn start</h3>
<p>Hiermit starten wir einen Entwicklungs-Server über den wir unsere neu erstellte App im Browser aufrufen können. Dieser kümmert sich auch darum alle Dateien im Ordner zu beobachten und unsere App mit all seinen Abhängigkeiten neu zu „kompilieren“ sobald wir eine Änderung an einem der Files vornehmen.</p>
<h3 id="yarn-build">yarn build</h3>
<p>Erstellt einen Build unserer App, die wir dann bspw. auf einen öffentlichen Server deployen können. Dieser Build ist gegenüber dem Development-Build (<code>yarn start</code>) auf Performance optimiert, weswegen das Ausführen von <code>yarn build</code> für gewöhnlich deutlich länger dauert als <code>yarn start</code>.</p>
<h3 id="yarn-test">yarn test</h3>
<p>Führt Tests aus. Als Test-Framework bringt CRA das ebenfalls von Facebook entwickelte <strong>Jest</strong> mit. Jest bringt hier aus meiner Sicht einen sehr entschiedenen Vorteil mit gegenüber anderen Testing-Frameworks, nämlich das sog. <strong>Snapshot-Testing</strong> bei dem sozusagen eine Art <em>Abbild</em> des aktuellen Zustands einer Komponente erstellt wird, der den Status Quo darstellt und mit dem zukünftige Test-Zustände verglichen werden. So fallen Änderungen, gewünschte wie ungewünschte, sofort ins Auge.</p>
<h3 id="yarn-eject">yarn eject</h3>
<p>Mit <code>yarn eject</code> können wir uns von Create React App „verabschieden“. Dabei werden alle build-Scripts, Dependencies und Config-Files in das aktuelle Projektverzeichnis kopiert und wir sind fortan selbst verantwortlich das alles korrekt läuft. Dadurch haben wir mehr Verantwortung, aber eben auch deutlich mehr Freiheiten, da wir von nun an eigene Änderungen an der Standard-Konfiguration von CRA vornehmen können. Wann und ob dieser Schritt überhaupt jemals nötig wird ist völlig abhängig vom Projekt. Ich selbst habe bereits in Projekten über Monate mit dem CRA Standard-Setup gearbeitet, in anderen Projekten hat es sich bereits nach wenigen Tagen oder Wochen ergeben, dass Änderungen am Setup vorgenommen werden müssen, so dass ein Eject recht frühzeitig vorgenommen wurde.</p>
<div class="hint hint--info">
<p>Um die Code-Beispiele in diesem Buch nachzuvollziehen empfehle ich an dieser Stelle <strong>Create React App</strong> zu installieren. Die große Mehrzahl der Beispiele können dann per Copy and Paste in die App.js-Datei aus Create React App übertragen und ausgeführt werden. Um den Lern-Effekt zu erhöhen würde ich sogar empfehlen die Beispiele nicht zu kopieren, sondern tatsächlich abzutippen.</p>
<p>Wer CRA nicht installieren möchte oder es eilig hat, dem sei <a href="https://codesandbox.io/">CodeSandbox</a> ans Herz gelegt. Hier kann in einer per Knopfdruck ein neues Setup mit Create React App als Basis erstellt und dann in einer Browser-Entwicklungsumgebung herumprobiert werden.</p>
</div>
</div>
<div class="chapter">
  <h1 id="ii-–-grundlagen">II – Grundlagen</h1>
</div>
<div class="chapter">
  <h1 id="exkurs-es2015">Exkurs ES2015+</h1>
<h2 id="das-„neue“-javascript">Das „neue“ JavaScript</h2>
<p><strong>ES2015</strong> ist kurz gesagt eine modernisierte, aktuelle Version von JavaScript mit vielen neuen Funktionen und Syntax-Erleichterungen. <strong>ES2015</strong> ist der Nachfolger von <strong>ECMAScript</strong> in der Version 5 (<strong>ES5</strong>), hieß daher ursprünglich auch einmal <strong>ES6</strong> und wird auch in einigen Blogs und Artikeln immer noch so bezeichnet. Stößt du also beim Lesen von Artikeln zu React auf den Begriff <strong>ES6</strong> ist damit <strong>ES2015</strong> gemeint. Ich schreibe hier meist von <strong>ES2015+</strong> und meine damit Änderungen die seit 2015 in JavaScript eingeflossen sind. Dazu gehören ES2016 (ES7), ES2017 (ES8) und ES2018 (ES9).</p>
<div class="hint hint--info">
<p>Das <strong>ES</strong> in <strong>ES2015</strong> und <strong>ES6</strong> steht für <strong>ECMAScript</strong>. Die ECMA International ist die Organisation, die hinter der Standardisierung der <strong>ECMA-262</strong> Spezifikation steht, auf der JavaScript basiert. Seit 2015 werden jährlich neue Versionen der Spezifikation veröffentlicht die aus historischen Gründen erst eine fortlaufende Versionsnummer beginnend ab Version 1 hatten, dann jedoch für mehr Klarheit die Jahreszahl ihrer Veröffentlichung angenommen haben. So wird <strong>ES6</strong> heute offiziell als <strong>ES2015</strong> bezeichnet, <strong>ES7</strong> als <strong>ES2016</strong>, usw.</p>
</div>
<p>Wer mit React arbeitet nutzt in vermutlich 99% der Fälle auch <strong>Babel</strong> als <strong>Transpiler</strong> um sein <strong>JSX</strong> entsprechend in <code>createElement()</code>-Aufrufe zu transpilieren. Doch <strong>Babel</strong> transpiliert nicht nur <strong>JSX</strong> in ausführbares JavaScript, sondern hieß ursprünglich mal <strong>6to5</strong> und hat genau das gemacht: mit <strong>ES6</strong>-Syntax geschriebenes JavaScript in <strong>ES5</strong> transpiliert, so dass neuere, zukünftige Features und Syntax-Erweiterungen auch in älteren Browsern ohne Unterstützung für „das neue“ JavaScript genutzt werden konnten.</p>
<p>Auf die meiner Meinung nach wichtigsten und nützlichsten neuen Funktionen und Möglichkeiten in <strong>ES2015</strong> und den folgenden Versionen möchte ich in diesem Kapitel eingehen. Dabei werde ich mich auf die neuen Funktionen beschränken, mit denen man bei der Arbeit mit React häufiger zu tun haben wird und die euch Entwicklern das Leben am meisten vereinfachen.</p>
<p><strong>Wenn du bereits Erfahrung mit ES2015 und den nachfolgenden Versionen hast kannst du dieses Kapitel überspringen!</strong></p>
<h2 id="variablen-deklarationen-mit-let-und-const">Variablen-Deklarationen mit let und const</h2>
<p>Gab es bisher nur <code>var</code> um eine Variable zu deklarieren in JavaScript, kommen in ES2015 zwei neue Schlüsselwörter dazu mit denen Variablen deklariert werden können: <code>let</code> und <code>const</code>. Eine Variablendeklaration mit <code>var</code> wird dadurch in fast allen Fällen überflüssig, meist sind <code>let</code> oder <code>const</code> die sauberere Wahl. Doch wo ist der Unterschied?</p>
<p>Anders als <code>var</code> existieren mit <code>let</code> oder <code>const</code> deklarierte Variablen <strong>nur innerhalb des Scopes in dem sie deklariert wurden!</strong> Ein solcher Scope kann eine Funktion sein wie sie bisher auch schon bei <code>var</code> einen neuen Scope erstellt hat aber auch Schleifen oder gar <code>if</code> Statements!</p>
<p><strong>Grobe Merkregel:</strong> überall dort wo man eine öffnende geschweifte Klammer findet, wird auch ein neuer Scope geöffnet. Konsequenterweise schließt die schließende Klammer diesen Scope wieder. Dadurch sind Variablen deutlich eingeschränkter und gekapselter, was für gewöhnlich eine gute Sache ist.</p>
<p>Möchte man den Wert einer Variable nochmal überschreiben, beispielsweise in einer Schleife, ist die Variable dafür mit <code>let</code> zu deklarieren. Möchte man die Referenz der Variable unveränderbar halten, sollte <code>const</code> benutzt werden.</p>
<p>Doch Vorsicht: anders als bei anderen Sprachen bedeutet <code>const</code> nicht, dass der komplette Inhalt der Variable konstant bleibt. Bei Objekten oder Arrays kann deren Inhalt auch bei mit <code>const</code> deklarierten Variablen noch verändert werden. Es kann lediglich das Referenzobjekt auf welche die Variable zeigt nicht mehr verändert werden.</p>
<h3 id="der-unterschied-zwischen-letconst-und-var">Der Unterschied zwischen <code>let</code>/<code>const</code> und <code>var</code></h3>
<p>Erst einmal zur Demonstration ein kurzes Beispiel wie sich die Variablendeklaration von <code>let</code> und <code>const</code> von denen mit <code>var</code> unterscheiden und was es bedeutet, dass erstere nur in dem Scope sichtbar sind, in dem sie definiert wurden:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {}
<span class="hljs-built_in">console</span>.log(i);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p>10</p>
</div>
<p>Nun einmal dasselbe Beispiel mit <code>let</code></p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) {}
<span class="hljs-built_in">console</span>.log(j);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--danger">
<p>Uncaught ReferenceError: <code>j</code> is not defined</p>
</div>
<p>Während auf die Variable <code>var i</code>, einmal definiert, auch außerhalb der <code>for</code>-Schleife zugegriffen werden kann, existiert die Variable <code>let j</code> nur innerhalb des Scopes in dem sie definiert wurde. Und das ist in diesem Fall innerhalb die <code>for</code>-Schleife, die einen neuen Scope erzeugt.</p>
<p>Dies ist ein kleiner Baustein der uns später dabei helfen wird unsere Komponenten gekapselt und ohne ungewünschte Seiteneffekte zu erstellen.</p>
<h4 id="unterschiede-zwischen-let-und-const">Unterschiede zwischen <code>let</code> und <code>const</code></h4>
<p>Folgender Code ist valide und funktioniert, solange die Variable mittels <code>let</code> (oder <code>var</code>) deklariert wurde:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> myNumber = <span class="hljs-number">1234</span>;
myNumber = <span class="hljs-number">5678</span>;
<span class="hljs-built_in">console</span>.log(myNumber);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p>5678</p>
</div>
<p>Der gleiche Code nochmal, nun allerdings mit <code>const</code>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> myNumber = <span class="hljs-number">1234</span>;
myNumber = <span class="hljs-number">5678</span>;
<span class="hljs-built_in">console</span>.log(myNumber);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--danger">
<p>Uncaught TypeError: Assignment to constant variable.</p>
</div>
<p>Wir versuchen hier also eine durch <code>const</code> deklarierte Variable direkt zu überschreiben und werden dabei vom JavaScript-Interpreter zurecht in die Schranken gewiesen. Doch was, wenn wir stattdessen nur eine Eigenschaft <em>innerhalb</em> eines mittels <code>const</code> deklarierten Objekts verändern wollen?</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> myObject = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
};
myObject.b = <span class="hljs-number">2</span>;
<span class="hljs-built_in">console</span>.log(myObject);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p><code>{a: 1, b: 2}</code></p>
</div>
<p>In diesem Fall gibt es keinerlei Probleme, da wir nicht die Referenz verändern, auf die die <code>myObject</code> Variable verweisen soll, sondern das Objekt, auf das verwiesen wird. Dies funktioniert ebenso mit Arrays, die verändert werden können, solange nicht der Wert der Variable selbst geändert wird!</p>
<p><strong>Erlaubt:</strong></p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> myArray = [];
myArray.push(<span class="hljs-number">1</span>);
myArray.push(<span class="hljs-number">2</span>);
<span class="hljs-built_in">console</span>.log(myArray);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p><code>[1, 2]</code></p>
</div>
<p><strong>Nicht erlaubt, da wir die Variable direkt überschreiben würden:</strong></p>
<pre><code class="hljs text language-text"><span class="hljs-attribute">const myArray</span> = [];
<span class="hljs-attribute">myArray</span> = Array.concat(1, 2);</code></pre>
<div class="hint hint--danger">
<p>Uncaught TypeError: Assignment to constant variable.</p>
</div>
<p>Möchten wir <code>myArray</code> also überschreibbar halten, müssen wir stattdessen <code>let</code> verwenden oder uns damit begnügen dass zwar der Inhalt des mittels <code>const</code> deklarierten Arrays veränderbar ist, nicht jedoch die Variable selbst.</p>
<h2 id="arrow-functions">Arrow Functions</h2>
<p><strong>Arrow Functions</strong> sind eine weitere <strong>deutliche</strong> Vereinfachung die uns ES2015 gebracht hat. Bisher funktionierte eine Funktionsdeklaration so: man schrieb das Keyword <code>function</code>, optional gefolgt von einem Funktionsnamen, Klammern, in der die Funktionsargumente beschrieben wurden, sowie dem <strong>Function Body</strong>, also dem eigentlichen Inhalt der Funktion:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) </span>{}</code></pre>
<p><strong>Arrow Functions</strong> vereinfachen uns das ungemein, indem sie erst einmal das <code>function</code> Keyword überflüssig machen:</p>
<pre><code class="hljs javascript language-javascript">(arg1, arg2) =&gt; {};</code></pre>
<p>Haben wir zudem nur einen Parameter, sind sogar die Klammern bei den Argumenten optional. Aus unserer Funktion</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg</span>) </span>{}</code></pre>
<p>Würde also die folgende <strong>Arrow Function</strong> werden:</p>
<pre><code class="hljs javascript language-javascript">(arg) =&gt; {};</code></pre>
<p>Jap, das ist eine gültige Funktion in ES2015!</p>
<p>Und es wird noch wilder. Soll unsere Funktion lediglich einen Ausdruck zurückzugeben als <code>return</code>-Wert, sind auch noch die Klammern optional. Vergleichen wir einmal eine Funktion die eine Zahl als einziges Argument entgegennimmt, diese verdoppelt und als <code>return</code>-Wert wieder aus der Funktion zurück gibt. Einmal in ES5:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">double</span>(<span class="hljs-params">number</span>) </span>{
  <span class="hljs-keyword">return</span> number * <span class="hljs-number">2</span>;
}</code></pre>
<p>… und als ES2015 <strong>Arrow Function</strong>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> double = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number * <span class="hljs-number">2</span>;</code></pre>
<p>In beiden Fällen liefert uns die eben deklarierte Funktion beim Aufruf von bspw. <code>double(5)</code> als Ergebnis <code>10</code> zurück!</p>
<p>Aber es gibt noch einen weiteren gewichtigen Vorteil, der bei der Arbeit mit React sehr nützlich sein wird: Arrow Functions haben keinen eigenen Constructor, können also nicht als Instanz in der Form <code>new MyArrowFunction()</code> erstellt werden, und binden auch kein eigenes <code>this</code> sondern erben <code>this</code> aus ihrem <strong>Parent Scope</strong>. Insbesondere Letzteres wird noch sehr hilfreich werden.</p>
<p>Auch das klingt fürchterlich kompliziert, lässt sich aber anhand eines einfachen Beispiels auch recht schnell erklären. Nehmen wir an wir definieren einen Button der die aktuelle Zeit in ein <code>div</code> schreiben soll, sobald ich ihn anklicke. Eine typische Funktion in ES5 könnte wie folgt aussehen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TimeButton</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> button = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn'</span>);
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">this</span>.showTime = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'time'</span>).innerHTML = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  };
  button.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    self.showTime();
  });
}</code></pre>
<p>Da die als <strong>Event Listener</strong> angegebene Funktion keinen Zugriff auf ihren <strong>Parent Scope</strong>, also den <strong>TimeButton</strong> hat, speichern wir hier hilfsweise <code>this</code> in der Variable <code>self</code>. Kein unübliches Muster in ES5. Alternativ könnte man auch den Scope der Funktion explizit an <code>this</code> binden und dem <strong>Event Listener</strong> beibringen in welchem Scope sein Code ausgeführt werden soll:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TimeButton</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> button = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn'</span>);
  <span class="hljs-keyword">this</span>.showTime = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'time'</span>).innerHTML = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  };
  button.addEventListener(
    <span class="hljs-string">'click'</span>,
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.showTime();
    }.bind(<span class="hljs-keyword">this</span>)
  );
}</code></pre>
<p>Hier spart man sich zumindest die zusätzliche Variable <code>self</code>. Auch das ist möglich, aber nicht besonders elegant.</p>
<p>An dieser Stelle kommt nun die <strong>Arrow Function</strong> ins Spiel, die, wie eben erwähnt, <code>this</code> aus ihrem <strong>Parent Scope</strong> erhält, also in diesem Fall aus unserer <code>TimeButton</code>-Instanz:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TimeButton</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> button = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn'</span>);
  <span class="hljs-keyword">this</span>.showTime = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'time'</span>).innerHTML = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  }
  button.addEventListener(<span class="hljs-string">'click'</span>, () {
    <span class="hljs-keyword">this</span>.showTime();
  });
}</code></pre>
<p>Und schon haben wir im <strong>Event Listener</strong> Zugriff auf <code>this</code> des überliegenden Scopes!</p>
<p>Keine <code>var self = this</code> Akrobatik mehr und auch kein <code>.bind(this)</code>. Wir können innerhalb des Event Listeners so arbeiten als befänden wir uns noch immer im <code>TimeButton</code> Scope! Das ist später insbesondere bei der Arbeit mit umfangreichen React-Komponenten mit vielen eigenen Class Properties und Methods hilfreich, da es Verwirrungen vorbeugt und nicht immer wieder einen neuen Scope erzeugt.</p>
<h2 id="neue-methoden-bei-strings-arrays-und-objekten">Neue Methoden bei Strings, Arrays und Objekten</h2>
<p>Mit ES2015 erhielten auch eine ganze Reihe neue statische und prototype-Methoden Einzug in JavaScript. Auch wenn die meisten davon nicht direkt relevant sind für die Arbeit mit React, erleichtern sie die Arbeit aber gelegentlich doch ungemein, weshalb ich hier ganz kurz auf die wichtigsten eingehen möchte.</p>
<h3 id="string-methoden">String-Methoden</h3>
<p>Hat man in der Vergangenheit auf <code>indexOf()</code> oder reguläre Ausdrücke gesetzt um zu prüfen ob ein String einen bestimmten Wert enthält, mit einem bestimmten Wert anfängt oder aufhört, bekommt der String Datentyp nun seine eigenen Methoden dafür.</p>
<p>Dies sind:</p>
<pre><code class="hljs javascript language-javascript">string.includes(value);
string.startsWith(value);
string.endsWith(value);</code></pre>
<p>Zurückgegeben wird jeweils ein Boolean, also <code>true</code> oder <code>false.</code> Möchte ich wissen ob mein String <code>Beispiel</code>ein <code>eis</code> enthält, prüfe ich ganz einfach auf</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-string">'Beispiel'</span>.includes(<span class="hljs-string">'eis'</span>);</code></pre>
<p>Analog verhält es sich mit <code>startsWith</code>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-string">'Beispiel'</span>.startsWith(<span class="hljs-string">'Bei'</span>);</code></pre>
<p>… wie auch mit <code>endsWith</code>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-string">'Beispiel'</span>.endsWith(<span class="hljs-string">'spiel'</span>);</code></pre>
<p>Die Methode arbeitet dabei case-sensitive, also unterscheidet zwischen Groß- und Kleinschreibung.</p>
<p>Zwei weitere hilfreiche Methoden die mit ES2015 Einzug in JavaScript erhalten haben sind <code>String.prototype.padStart()</code> und <code>String.prototype.padEnd()</code>. Diese Methoden könnt ihr nutzen um einen String auf eine gewisse Länge zu bringen indem ihr am Anfang (<code>.padStart()</code>) oder am Ende (<code>.padEnd()</code>) Zeichen hinzufügt bis die angegebene Länge erreicht ist. Dabei gibt der erste Parameter die gewünschte Länge an, der optionale zweite Parameter das Zeichen mit dem ihr den String bis zu dieser Stelle auffüllen wollt. Gebt ihr keinen zweiten Parameter an, wird standardmäßig ein Leerzeichen benutzt.</p>
<p>Hilfreich ist das bspw. wenn ihr Zahlen auffüllen wollt, so dass diese immer einheitlich dreistellig sind:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-string">'7'</span>.padStart(<span class="hljs-number">3</span>, <span class="hljs-string">'0'</span>); <span class="hljs-comment">// 007</span>
<span class="hljs-string">'72'</span>.padStart(<span class="hljs-number">3</span>, <span class="hljs-string">'0'</span>); <span class="hljs-comment">// 072</span>
<span class="hljs-string">'132'</span>.padStart(<span class="hljs-number">3</span>, <span class="hljs-string">'0'</span>); <span class="hljs-comment">// 132</span></code></pre>
<p><code>String.prototype.padEnd()</code> funktioniert nach dem gleichen Muster, mit dem Unterschied, dass es euren String am Ende auffüllt, nicht am Anfang.</p>
<h3 id="arrays">Arrays</h3>
<p>Bei den Array-Methoden gibt es sowohl neue statische Methoden als auch Methoden auf dem Array-Prototype. Was bedeutet dies? Prototype-Methoden arbeiten „mit dem Array“ als solches, also mit einer bestehenden <strong>Array-Instanz</strong>, statische Methoden sind im weiteren Sinne Helper-Methoden, die gewisse Dinge tun, die „mit Arrays zu tun haben“.</p>
<h4 id="statische-array-methoden">Statische Array-Methoden</h4>
<p>Fangen wir mit den statischen Methoden an:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-built_in">Array</span>.of(<span class="hljs-number">3</span>); <span class="hljs-comment">// [3]</span>
<span class="hljs-built_in">Array</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [1, 2 ,3]</span>
<span class="hljs-built_in">Array</span>.from(<span class="hljs-string">'Example'</span>); <span class="hljs-comment">// ['E', 'x', 'a', 'm', 'p', 'l', 'e']</span></code></pre>
<p><code>Array.of()</code> erstellt eine neue Array-Instanz aus einer beliebigen Anzahl an Parametern, unabhängig von deren Typen. <code>Array.from()</code> erstellt ebenfalls eine Array-Instanz, allerdings aus einem „Array-ähnlichen“ iterierbaren Objekt. Das wohl griffigste Beispiel für ein solches Objekt ist eine <code>HTMLCollection</code> oder eine <code>NodeList</code>. Solche erhält man bspw. bei der Verwendung von DOM-Methoden wie <code>getElementsByClassName()</code> oder dem moderneren <code>querySelectorAll()</code>. Diese besitzen selbst keine Methoden wie <code>.map()</code> oder <code>.filter()</code>. Möchte man über eine solche also iterieren, muss man sie erst einmal in einen Array konvertieren. Dies geht mit ES2015 nun ganz einfach durch die Verwendung von <code>Array.from()</code>.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> links = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'a'</span>));
<span class="hljs-built_in">Array</span>.isArray(links); <span class="hljs-comment">// true</span></code></pre>
<h4 id="methoden-auf-dem-array-prototypen">Methoden auf dem Array-Prototypen</h4>
<p>Die Methoden auf dem Array-Prototypen können <strong>direkt auf eine Array-Instanz</strong> angewendet werden. Die gängigsten während der Arbeit mit React und insbesondere später mit Redux sind:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-built_in">Array</span>.find(<span class="hljs-function"><span class="hljs-keyword">function</span>);
<span class="hljs-title">Array</span>.<span class="hljs-title">findIndex</span>(<span class="hljs-params">function</span>);
<span class="hljs-title">Array</span>.<span class="hljs-title">includes</span>(<span class="hljs-params">value</span>);</span></code></pre>
<p>Die <code>Array.find()</code>-Methode dient, wie der Name es erahnen lässt dazu, das <strong>erste</strong> element eines Arrays zu finden, das bestimmte Kriterien erfüllt, die mittels der als ersten Parameter übergebenen Funktion geprüft werden.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">13</span>, <span class="hljs-number">24</span>, <span class="hljs-number">27</span>, <span class="hljs-number">39</span>, <span class="hljs-number">50</span>];
<span class="hljs-keyword">const</span> biggerThan10 = numbers.find(<span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number &gt; <span class="hljs-number">10</span>); <span class="hljs-comment">// 13</span>

<span class="hljs-keyword">const</span> users = [
  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Bianca'</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Steve'</span> },
];
<span class="hljs-keyword">const</span> userWithId2 = users.find(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> user.id === <span class="hljs-number">2</span>); <span class="hljs-comment">// { id: 2, name: 'Bianca'}</span></code></pre>
<p>Die <code>Array.findIndex()</code>-Methode folgt der gleichen Signatur, liefert aber anders als die <code>Array.find()</code>-Methode nicht das gefundene Element selbst zurück, sondern nur dessen Index im Array. In den obigen Beispielen wären dies also <code>3</code> sowie <code>1</code>.</p>
<p>Die in ES2016 neu dazu gekommene Methode <code>Array.includes()</code> prüft ob ein Wert innerhalb eines Array existiert und gibt uns <strong>endlich</strong> einen Boolean zurück. Wer selbiges in der Vergangenheit mal mit <code>Array.indexOf()</code> realisiert hat wird sich erinnern wie umständlich es war. Nun also ein simples <code>Array.includes()</code>:</p>
<pre><code class="hljs javascript language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].includes(<span class="hljs-number">4</span>); <span class="hljs-comment">// true</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].includes(<span class="hljs-number">6</span>); <span class="hljs-comment">// false</span></code></pre>
<p>Aufgepasst: die Methode ist case-sensitive. <code>['a', 'b'].includes('A')</code> gibt also <code>false</code> zurück.</p>
<h3 id="objekte">Objekte</h3>
<h4 id="statische-objekt-methoden">Statische Objekt-Methoden</h4>
<p>Natürlich haben auch Objekte eine Reihe neuer Methoden und anderer schöner Möglichkeiten spendiert bekommen. Die wichtigsten im Überblick:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-built_in">Object</span>.assign(target, source[, source[,...]]);
<span class="hljs-built_in">Object</span>.entries(<span class="hljs-built_in">Object</span>)
<span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">Object</span>)
<span class="hljs-built_in">Object</span>.values(<span class="hljs-built_in">Object</span>)
<span class="hljs-built_in">Object</span>.freeze(<span class="hljs-built_in">Object</span>)</code></pre>
<p>Wieder der Reihe nach. Die wohl nützlichste ist aus meiner Sicht <code>Object.assign()</code>. Damit ist es möglich die Eigenschaften eines Objekts oder auch mehrerer Objekte zu einem bestehenden Objekt hinzuzufügen (sozusagen ein Merge). Die Methode gibt dabei das Ergebnis als Objekt zurück. Allerdings findet dabei auch eine Mutation des <strong>Ziel-Objekts</strong> statt, weswegen die Methode mit Bedacht benutzt werden sollte. Beispiele sagen mehr also Worte, bitteschön:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> user = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span> };
<span class="hljs-keyword">const</span> modifiedUser = <span class="hljs-built_in">Object</span>.assign(user, { <span class="hljs-attr">role</span>: <span class="hljs-string">'Admin'</span> });
<span class="hljs-built_in">console</span>.log(user);
<span class="hljs-comment">// -&gt; { id: 1, name: 'Manuel', role: 'Admin' }</span>
<span class="hljs-built_in">console</span>.log(modifiedUser);
<span class="hljs-comment">// -&gt; { id: 1, name: 'Manuel', role: 'Admin' }</span>
<span class="hljs-built_in">console</span>.log(user === modifiedUser);
<span class="hljs-comment">// -&gt; true</span></code></pre>
<p>Hier fügen wir also die Eigenschaft <code>role</code> aus dem Objekt im zweiten Parameter der <code>Object.assign()</code>-Methode zum bestehenden <strong>Ziel-Objekt</strong> hinzu.</p>
<p>Da React dem Prinzip von <strong>Pure Functions</strong> folgt, das sind Funktionen die in sich geschlossen sind und ihre Eingabeparameter nicht modifizieren, sollten deartige Mutationen möglichst vermieden werden. Dies können wir umgehen indem wir als ersten Parameter einfach ein Object-Literal übergeben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> user = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span> };
<span class="hljs-keyword">const</span> modifiedUser = <span class="hljs-built_in">Object</span>.assign({}, user, { <span class="hljs-attr">role</span>: <span class="hljs-string">'Admin'</span> });
<span class="hljs-built_in">console</span>.log(user);
<span class="hljs-comment">// -&gt; { id: 1, name: 'Manuel' }</span>
<span class="hljs-built_in">console</span>.log(modifiedUser);
<span class="hljs-comment">// -&gt; { id: 1, name: 'Manuel', role: 'Admin' }</span>
<span class="hljs-built_in">console</span>.log(user === modifiedUser);
<span class="hljs-comment">// -&gt; false</span></code></pre>
<p>Durch die Verwendung eines neu erstellten Objekts als Ziel-Objekt bekommen wir hier eben auch als Rückgabewert ein anderes Objekt als im ersten Beispiel. In einigen Fällen kann es gewünscht sein das <strong>Ziel-Objekt</strong> zu mutieren statt ein neues Objekt zu erstellen, während der Arbeit mit React ist dies jedoch in den deutlich überwiegenden Fällen nicht so.</p>
<p>Die Methode verarbeitet dabei auch beliebig viele Objekte als Parameter. Gibt es gleichnamige Eigenschaften in einem Objekt, haben spätere Eigenschaften Vorrang:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> user = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span> };
<span class="hljs-keyword">const</span> modifiedUser = <span class="hljs-built_in">Object</span>.assign(
  {},
  user,
  { <span class="hljs-attr">role</span>: <span class="hljs-string">'Admin'</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Nicht Manuel'</span>, <span class="hljs-attr">job</span>: <span class="hljs-string">'Developer'</span> }
);
<span class="hljs-built_in">console</span>.log(modifiedUser);
<span class="hljs-comment">// -&gt; { id: 1, name: 'Nicht Manuel', role: 'Admin', job: 'Developer' }</span></code></pre>
<p>Die drei statischen Objekt-Methoden <code>Object.entries()</code>, <code>Object.keys()</code> und <code>Object.values()</code> funktionieren im Grunde sehr ähnlich, sie liefern zu einem übergebenen Objekt die Eigenschaften (<code>keys</code>), die Werte (<code>values</code>) oder die Einträge (<code>entries</code>) ala <strong>Array</strong> zurück, wobei die <strong>Entries</strong> ein verschachteltes Array sind in der Form <code>[[key, value], [key2, values2], …]</code>.</p>
<p>Angewendet auf unser obiges Beispiel hat dies also folgende Return-Values zum Ergebnis:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-built_in">Object</span>.keys({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span> });
<span class="hljs-comment">// -&gt; ['id', 'name']</span>
<span class="hljs-built_in">Object</span>.values({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span> });
<span class="hljs-comment">// -&gt; [1, 'Manuel']</span>
<span class="hljs-built_in">Object</span>.entries({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span> });
<span class="hljs-comment">// -&gt; [['id', 1], ['name', 'Manuel']]</span></code></pre>
<p>Zuletzt schauen wir uns <code>Object.freeze()</code> an. Auch diese Methode ist ziemlich selbsterklärend und tut genau was der Name vermuten lässt: sie friert ein Objekt ein, untersagt es dem Entwickler also neue Eigenschaften hinzuzfügen oder alte Eigenschaften zu löschen oder auch nur zu verändern. Auch dies ist im Umgang mit den Objekten, die in React in den meisten Fällen unveränderlich sind (oder zumindest sein sollten) unglaublich praktisch.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> user = <span class="hljs-built_in">Object</span>.freeze({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span> });
user.id = <span class="hljs-number">2</span>;
<span class="hljs-keyword">delete</span> user.name;
user.role = <span class="hljs-string">'Admin'</span>;
<span class="hljs-built_in">console</span>.log(user);
<span class="hljs-comment">// -&gt; { id: 1, name: 'Manuel' }</span></code></pre>
<p>Ein mittels <code>Object.freeze()</code> erstelltes Objekt bietet auch guten Schutz vor versehentlicher Mutation mittels der oben beschriebenen, ebenfalls neuen <code>Object.assign()</code>-Methode. Wird versucht ein mittels <code>Object.freeze()</code> erstelltes Objekt per <code>Object.assign()</code> zu modifizieren, führt dies unweigerlich zu seinem <code>TypeError</code>.</p>
<h4 id="syntax-erweiterungen-und-vereinfachungen">Syntax-Erweiterungen und Vereinfachungen</h4>
<p>Die letzte Änderungen an der funktionsweise von Objekten sind keine Methode sondern Syntax-Erweiterungen.</p>
<p>Die erste sind die <strong>Computed Properties</strong> (also etwa <em>berechnete Eigenschaften</em>). Dahinter verbirbt sich die Möglichkeit Ausdrücke (bzw. deren Werte) als Objekt-Eigenschaften zu verwenden. Wollte man bspw. früher eine Eigenschaft in einem Objekt setzen, lief das meist so, dass man das Objekt erstellte (bspw. als <strong>Object-Literal</strong> <code>{}</code> oder per <code>Object.create()</code>), dieses einer Variablen zuwies und anschließend die neue Eigenschaft zum Objekt hinzufügte:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> nationality = <span class="hljs-string">'german'</span>;
<span class="hljs-keyword">const</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span>,
};
user[nationality] = <span class="hljs-literal">true</span>;
<span class="hljs-built_in">console</span>.log(user);
<span class="hljs-comment">// -&gt; { name: 'Manuel', german: true };</span></code></pre>
<p><strong>ES2015</strong> erlaubt uns nun, Ausdrücke direkt als Objekt-Eigenschaft zu nutzen, indem wir sie in eckige Klammern <code>[]</code> setzen. Dadurch sparen wir uns den Umweg nachträglich noch Eigenschaften zum Bereits erstellten Objekt hinzuzufügen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> nationality = <span class="hljs-string">'german'</span>;
<span class="hljs-keyword">const</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span>,
};
<span class="hljs-built_in">console</span>.log(user);
<span class="hljs-comment">// -&gt; { name: 'Manuel', german: true };</span></code></pre>
<p>Das Beispiel ist aus Gründen der einfacheren Verständlichkeit ein simples, doch die Verwendungsmöglichkeiten werden später mitunter noch deutlich komplexer und schaffen uns viele Möglichkeiten um sauberen und gut verständlichen Code zu schreiben, insbesondere wenn es um <strong>JSX</strong> geht.</p>
<p>Die letzte nennenswerte Neuerung bei Objekten sind die sogenannten <strong>Shorthand Property Names</strong>. Diese ersparen uns eine Menge unnötige Schreibarbeit. Nicht erst seit React kennt man es, dass man auf Code wie den folgenden stößt:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">'Manuel'</span>;
<span class="hljs-keyword">const</span> job = <span class="hljs-string">'Developer'</span>;
<span class="hljs-keyword">const</span> role = <span class="hljs-string">'Author'</span>;

<span class="hljs-keyword">const</span> user = {
  <span class="hljs-attr">name</span>: name,
  <span class="hljs-attr">job</span>: job,
  <span class="hljs-attr">role</span>: role,
};</code></pre>
<p>Ziemlich viele unnötige Dopplungen wenn man sich das mal genau anschaut, oder? Genau diese nimmt uns die <strong>Shorthand Property Name Syntax</strong> in <strong>ES2015</strong> endlich ab. Und so reicht es nur noch die Variable zu schreiben wenn diese den Namen der entsprechenden Objekt-Eigenschaft trägt. Im obigen Fall also:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">'Manuel'</span>;
<span class="hljs-keyword">const</span> job = <span class="hljs-string">'Developer'</span>;
<span class="hljs-keyword">const</span> role = <span class="hljs-string">'Author'</span>;

<span class="hljs-keyword">const</span> user = {
  name,
  job,
  role,
};</code></pre>
<p>Jep. Seit <strong>ES2015</strong> führen beide Schreibweisen tatsächlich zum identischen Objekt! Dabei kann die Shorthand Syntax auch problemlos mit der herkömmlichen Syntax kombiniert werden:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">'Manuel'</span>;
<span class="hljs-keyword">const</span> job = <span class="hljs-string">'Developer'</span>;

<span class="hljs-keyword">const</span> user = {
  name,
  job,
  <span class="hljs-attr">role</span>: <span class="hljs-string">'Author'</span>,
};</code></pre>
<h2 id="classes">Classes</h2>
<p>Mit <strong>ES2015</strong> fanden auch <strong>Klassen</strong> Einzug in JavaScript. <strong>Klassen</strong> kennt man eher aus objektorientierten Sprachen wie Java, in JavaScript gab es sie so explizit bisher allerdings noch nicht. Zwar war es auch schon vorher möglich durch die Verwendung von Funktionsinstanzen objektorientiert zu arbeiten und durch die <code>prototype</code>-Eigenschaft einer Funktion eigene Methoden und Eigenschaften zu definieren, dies war verglichen mit echten objektorientierten Sprachen jedoch sehr mühsam und schreiblastig.</p>
<p>Dies ändert sich mit <strong>ES2015</strong>, wo es nun erstmals auch Klassen gibt, die mittels <code>class</code> Keyword definiert werden. Das ist für uns insofern interessant, da React, obwohl es viele Prinzipien der funktionalen Programmierung (<strong>Functional Programming</strong>) verfolgt, gleichzeitig auch in einem wesentlichen Punkt auf ES2015 Klassen setzt, nämlich bei der Erstellung von Komponenten, in diesem Fall speziell von <strong>Class Components</strong>. Auch vor der Einführung von ES2015 Klassen war es natürlich möglich Komponenten in React zu definieren, dazu gab es eine eigene <code>createClass()</code>-Methode. Diese ist aber mittlerweile nicht mehr Teil des React Cores und sollte möglichst auch nicht mehr verwendet werden.</p>
<p>Eine Klasse besteht aus einem Namen, kann (optional) einen <strong>Constructor</strong> haben der bei der Erstellung einer Klassen-Instanz aufgerufen wird und beliebig viele Klassen-Methoden besitzen.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>{
  <span class="hljs-keyword">constructor</span>(firstName, lastName) {
    <span class="hljs-keyword">this</span>.firstName = firstName;
    <span class="hljs-keyword">this</span>.lastName = lastName;
  }

  getFullName() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.lastName;
  }
}

<span class="hljs-keyword">const</span> firstCustomer = <span class="hljs-keyword">new</span> Customer(<span class="hljs-string">'Max'</span>, <span class="hljs-string">'Mustermann'</span>);
<span class="hljs-built_in">console</span>.log(firstCustomer.getFullName());</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p>Max Mustermann</p>
</div>
<p>Auch das Erweitern bestehender Klassen mittels <code>extends</code> ist dabei möglich:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>{}</code></pre>
<p>Oder eben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{}</code></pre>
<p>Auch eine <code>super()</code>-Funktion kennt die neu eingeführte <strong>ES2015</strong>-Klasse, um damit den <strong>Constructor</strong> ihrer Elternklasse aufzurufen. Im Falle von React ist dies immer notwendig wenn ich in meiner eigenen Klasse eine <code>constructor</code>-Methode definiere. Diese muss dann dann <code>super()</code> aufrufen und ihre <code>props</code> an den Constructor der <code>React.Component</code> Klasse weiterzugeben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props);
  }
}</code></pre>
<p>Tätet ihr das nicht, wäre <code>this.props</code> innerhalb eurer Komponente <code>undefined</code> und ihr könntet nicht auf die Props eurer Komponente zugreifen. Grundsätzlich sollte die Verwendung eines Constructors aber in den allermeisten Fällen nicht nötig sein, denn React stellt eigene sog. <strong>Lifecycle-Methoden</strong> bereit, die der Verwendung des Constructors vorzuziehen sind.</p>
<h2 id="rest-und-spread-operators-und-destrukturierung">Rest und Spread Operators und Destrukturierung</h2>
<p>Eine weitere deutliche Vereinfachung ist die Einführung der der sog. Rest und Spread Operators für Objekte und Arrays. Streng genommen handelt es sich dabei bei der Verwendung in Kombination mit Objekten noch gar nicht um ES2015 Features, da diese sich noch in der Diskussion befinden und noch gar nicht endgültig in die ECMAScript Spezifikation aufgenommen wurden. Dies ändert sich erst mit ES2018. Eingeführt wurden Rest und Spread in ES2015 erstmals für Arrays. Durch die Verwendung von Babel ist die Nutzung auch mit Objekten aber heute bereits möglich und für gewöhnlich wird davon in React basierten Projekten auch rege Gebrauch gemacht.</p>
<p>Aber was ist das jetzt überhaupt? Fangen wir mit dem Spread Operator an.</p>
<h3 id="spread-operator">Spread Operator</h3>
<p>Der Spread Operator sorgt dafür Werte sozusagen „auszupacken“. Wollte man in ES5 mehrere Argumente aus einem Array an eine Funktion übergeben, geschah das bisher meist über <code>Function.prototype.apply()</code>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumAll</span>(<span class="hljs-params">number1, number2, number3</span>) </span>{
  <span class="hljs-keyword">return</span> number1, number2, number3;
}
<span class="hljs-keyword">var</span> myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
sumAll.apply(<span class="hljs-literal">null</span>, myArray);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p>6</p>
</div>
<p>Mit dem Spread Operator, der aus drei Punkten (…) besteht, kann ich diese Argumente nun auspacken oder eben „spreaden“:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumAll</span>(<span class="hljs-params">number1, number2, number3</span>) </span>{
  <span class="hljs-keyword">return</span> number1, number2, number3;
}
<span class="hljs-keyword">var</span> myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
sumAll(...myArray);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p>6</p>
</div>
<p>Ich muss also nicht mehr den Umweg über <code>apply()</code> gehen. Aber nicht nur bei Funktionsargumenten ist das hilfreich. Ich kann ihn auch nutzen um bspw. auf einfache Art und Weise zwei Arrays zu einem einzigen zu kombinieren:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> greenFruits = [<span class="hljs-string">'kiwi'</span>, <span class="hljs-string">'apple'</span>, <span class="hljs-string">'pear'</span>];
<span class="hljs-keyword">const</span> redFruits = [<span class="hljs-string">'strawberry'</span>, <span class="hljs-string">'cherry'</span>, <span class="hljs-string">'raspberry'</span>];
<span class="hljs-keyword">const</span> allFruits = [...greenFruits, ...redFruits];</code></pre>
<p><strong>Ergebnis:</strong></p>
<div class="hint hint--info">
<p><code>['kiwi', 'apple', 'pear', 'strawberry', 'cherry', 'raspberry']</code></p>
</div>
<p>Dabei wird ein neues Array erstellt, welches alle Werte sowohl aus dem <code>greenFruits</code> als auch aus dem <code>redFruits</code> Array enthält. Doch nicht nur das: dabei wird auch ein gänzlich neues Array erstellt und nicht bloß eine Referenz der beiden alten. Dies wird im weiteren Verlauf wenn wir an die <strong>readonly</strong>-Anforderung unserer Props noch sehr nützlich sein. Und so kann man den Spread Operator auch verwenden um eine einfache Kopie eines Arrays zu erstellen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> users = [<span class="hljs-string">'Manuel'</span>, <span class="hljs-string">'Chris'</span>, <span class="hljs-string">'Ben'</span>];
<span class="hljs-keyword">const</span> selectedUsers = [...users];</code></pre>
<p><code>selectedUsers</code> ist in diesem Fall eine Kopie unseres <code>users</code> Arrays mit all seinen Werten. Verändern wir nun das Users Array, hat dies auf unser <code>selectedUsers</code> Array keinerlei Auswirkungen.</p>
<p>Bei Objekten verhält sich der Spread Operator sehr ähnlich. Hier werden statt der einzelnen Werte alle Eigenschaften eines Objekts die „enumerable“ (aufzählbar) sind, also ganz grob gesagt bei der Verwendung in einer <code>for(… in …)</code> Schleife angezeigt werden würden.</p>
<p>Hier eignet sich der Spread Operator hervorragend um neue Objekte zu erstellen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> globalSettings = { <span class="hljs-attr">language</span>: <span class="hljs-string">'en-US'</span>, <span class="hljs-attr">timezone</span>: <span class="hljs-string">'Berlin/Germany'</span> };
<span class="hljs-keyword">const</span> userSettings = { <span class="hljs-attr">mutedUsers</span>: [<span class="hljs-string">'Manuel'</span>] };
<span class="hljs-keyword">const</span> allSettings = { ...globalSettings, ...userSettings };
<span class="hljs-built_in">console</span>.log(allSettings);</code></pre>
<p><strong>Ausgabe:</strong></p>
<pre><code class="hljs javascript language-javascript">{
  <span class="hljs-attr">language</span>: <span class="hljs-string">'en-US'</span>,
  <span class="hljs-attr">timezone</span>: <span class="hljs-string">'Berlin/Germany'</span>,
  <span class="hljs-attr">mutedUsers</span>: [<span class="hljs-string">'Manuel'</span>],
}</code></pre>
<p>Die Eigenschaften beider Objekte finden sich dabei im neu erstellten, kombinierten <code>allSettings</code> Objekt wieder. Dabei ist der <strong>Spread Operator</strong> hier nicht auf zwei Objekte beschränkt sondern kann beliebige weitere Objekte zu einem einzelnen neuen Objekt kombinieren. Auch die Kombination mit einzelnen Eigenschaften ist möglich:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> settings = {
  ...userSettings,
  <span class="hljs-attr">showWarnings</span>: <span class="hljs-literal">true</span>,
};</code></pre>
<p>Befinden sich in beiden Objekten Eigenschaften mit dem gleichen Namen, hat das letztgenannte Objekt Vorrang:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> globalSettings = { <span class="hljs-attr">language</span>: <span class="hljs-string">'en-US'</span>, <span class="hljs-attr">timezone</span>: <span class="hljs-string">'Berlin/Germany'</span> };
<span class="hljs-keyword">const</span> userSettings = { <span class="hljs-attr">language</span>: <span class="hljs-string">'de-DE'</span> };
<span class="hljs-keyword">const</span> allSettings = { ...globalSettings, ...userSettings };
<span class="hljs-built_in">console</span>.log(allSettings);</code></pre>
<p><strong>Ausgabe:</strong></p>
<pre><code class="hljs text language-text">{
  <span class="hljs-attribute">language</span>: <span class="hljs-string">'de-DE'</span>,
  timezone: <span class="hljs-string">'Berlin/Germany'</span>,
}</code></pre>
<p>Das zuletzt genannte <code>userSettings</code> Objekt überschreibt hier die gleichnamige Eigenschaft <code>language</code>, die sich auch im <code>globalSettings</code> Objekt befindet. Der Spread Operator funktioniert hier ganz ähnlich wie die in ES2015 neu eingeführte Objekt-Methode <code>Object.assign()</code>. Auch diese wird in ES2015+ basierten Anwendungen gelegentlich genutzt.</p>
<p>Allerdings gibt es hier den nennenswerten Unterschied, dass sie ein bestehendes Objekt mutiert und nicht per se ein neues Objekt generiert, wie das die Object Spread Variante tut. Und Mutation ist bezogen auf React-Komponenten und ihre Props eben das, was wir ja nicht wollen. Dennoch der Vollständigkeit halber ein kurzes Beispiel.</p>
<h4 id="objekte-kombinieren-mittels-objectassign">Objekte kombinieren mittels Object.assign()</h4>
<p><code>Object.assign()</code> nimmt beliebig viele Objekte entgegen und kombiniert diese zu einem einzigen Objekt:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> a = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };
<span class="hljs-keyword">const</span> b = { <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">const</span> c = { <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> };
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.assign(a, b, c));</code></pre>
<p><strong>Ausgabe:</strong></p>
<pre><code class="hljs javascript language-javascript">{<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>}</code></pre>
<p>Die Funktion gibt uns also ein neues Objekt zurück, in dem alle 3 übergebenen Objekte zu einem einzigen kombiniert wurden. Aber ist das wirklich ein neues Objekt? <strong>Nein!</strong> Lassen wir uns doch anschließend mal <code>a</code>, <code>b</code> und <code>c</code> in der Console ausgeben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-built_in">console</span>.log(a);
<span class="hljs-built_in">console</span>.log(b);
<span class="hljs-built_in">console</span>.log(c);</code></pre>
<p><strong>Ausgabe:</strong></p>
<pre><code class="hljs javascript language-javascript">{<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>}
{<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>}
{<span class="hljs-attr">c</span>: <span class="hljs-number">3</span>}</code></pre>
<p>Wir stellen also fest: <code>Object.assign()</code> hat uns nicht wirklich ein komplett neues Objekt aus den 3 übergebenen Objekten erstellt sondern lediglich die Eigenschaften des zweiten und dritten Objekts zum ersten übergebenen Objekt hinzugefügt. Und das ist, im Bezug auf <strong>Pure Functions</strong> und <strong>Immutable Objects</strong>, äußerst schlecht und in jedem Fall zu vermeiden!</p>
<p>Hier gibt es aber einen einfachen Trick um Objekte mittels <code>Object.assign()</code> zu kombinieren und dabei gleichzeitig ein neues Objekt zu erstellen. Dazu übergebt ihr der Funktion als erstes Argument ein leeres Object-Literal <code>{}</code>:</p>
<pre><code class="hljs text language-text"><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.assign</span>({}, <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, <span class="hljs-selector-tag">c</span>);</code></pre>
<p>… und schon werden dem neu erstellten <code>{}</code> Objekt die Eigenschaften unserer Objekte <code>a</code>, <code>b</code> und <code>c</code> übertragen, die bestehenden Objekte <code>a</code>, <code>b</code> und <code>c</code> bleiben dabei unangetastet!</p>
<h3 id="destructuring-assignment--destrukturierende-zuweisung">Destructuring Assignment / destrukturierende Zuweisung</h3>
<p>Bevor ich zum <strong>Rest Operator</strong> komme, der logisch sehr eng mit dem <strong>Spread Operator</strong> in Verbindung steht und meist mit diesem in einem Atemzug genannt wird, möchte ich auf das <strong>Destructuring Assignment</strong> (kurz: <strong>Destructuring</strong>) oder eben die <strong>destrukturierende Zuweisung</strong> (kurz: <strong>Destrukturierung</strong>), wie der schöne Begriff auf Deutsch heißt, eingehen. Ich werde hier wie so oft beim englischen Begriff bleiben, da ich den deutschen Begriff selbst in deutschsprachigen Texten selten bisher gelesen habe.</p>
<p>Mittels <strong>Destructuring</strong> ist es möglich einzelne Elemente aus Objekten oder Arrays zu extrahieren und Variablen zuzuweisen. Eine weitere <strong>deutliche</strong> Syntax-Erweiterung die uns ES2015 hier beschert hat.</p>
<h4 id="destructuring-von-arrays">Destructuring von Arrays</h4>
<p>Stellen wir uns vor wir möchten aus einem geordneten Array mit den Olympia-Teilnehmern im 100m Lauf jeweils den Gewinner der Gold-, Silber- und Bronzemedaille in eine eigene Variable schreiben. Auf herkömmlichen (also ES5) Weg funktionierte das bisher folgendermaßen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> athletes = [
  <span class="hljs-string">'Usain Bolt'</span>,
  <span class="hljs-string">'Andre De Grasse '</span>,
  <span class="hljs-string">'Christophe Lemaitre '</span>,
  <span class="hljs-string">'Adam Gemili'</span>,
  <span class="hljs-string">'Churandy Martina'</span>,
  <span class="hljs-string">'LaShawn Merritt'</span>,
  <span class="hljs-string">'Alonso Edward'</span>,
  <span class="hljs-string">'Ramil Guliyev'</span>,
];

<span class="hljs-keyword">const</span> gold = athletes[<span class="hljs-number">0</span>];
<span class="hljs-keyword">const</span> silver = athletes[<span class="hljs-number">1</span>];
<span class="hljs-keyword">const</span> bronze = athletes[<span class="hljs-number">2</span>];</code></pre>
<p>Dank <strong>Destructuring</strong> können wir dies auf ein einzelnes Statement verkürzen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> [gold, silver, bronze] = athletes;</code></pre>
<p>Die Werte der Array-Elemente <code>0</code>, <code>1</code> und <code>2</code> befinden sich dann der Reihe nach in den Variablen <code>gold</code>, <code>silver</code> und <code>bronze</code>, wie auch im ersten Beispiel, jedoch mit deutlich weniger Schreibarbeit!</p>
<p>Dies funktioniert überall wo wir mit einem Array auf der rechten Seite (also hinter dem <code>=</code> Zeichen) einer Zuweisung arbeiten, also auch wenn wir diesen als <code>return</code>-Wert aus einer Funktion erhalten:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> getAllAthletes = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> [
    <span class="hljs-string">'Usain Bolt'</span>,
    <span class="hljs-string">'Andre De Grasse '</span>,
    <span class="hljs-string">'Christophe Lemaitre '</span>,
    <span class="hljs-string">'Adam Gemili'</span>,
    <span class="hljs-string">'Churandy Martina'</span>,
    <span class="hljs-string">'LaShawn Merritt'</span>,
    <span class="hljs-string">'Alonso Edward'</span>,
    <span class="hljs-string">'Ramil Guliyev'</span>,
  ];
};

<span class="hljs-keyword">const</span> [gold, silver, bronze] = getAllAthletes();</code></pre>
<p>Die Arrow Function hier gibt uns ein Array mit allen Athleten zurück, dementsprechend können wir hier direkt beim Aufruf bereits das Destructuring nutzen und müssen den <code>return</code>-Wert bspw. nicht erst eigens in einer temporären Variable speichern.</p>
<p>Möchten wir auf diese Weise einzelne Elemente des Arrays auslassen, ist das buchstäblich durch Auslassen des entsprechenden Wertes möglich:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> [, silber, bronze] = athletes;</code></pre>
<p>Hier würden wir auf das Deklarieren einer <code>gold</code> Variable verzichten und nur die Gewinner der Silber- und Bronze-Medaille in entsprechenden Variablen speichern.</p>
<p>Doch nicht nur bei der offensichtlichen Variablenzuweisung mittels <code>let</code> oder <code>const</code> kann <strong>Array Destructuring</strong> verwendet werden. Auch bei weniger offensichtlichen Zuweisungen, wie bei der Übergabe von Funktionsargumenten in Form eines Arrays.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> logWinners = <span class="hljs-function">(<span class="hljs-params">athletes</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> gold = athletes[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">const</span> silver = athletes[<span class="hljs-number">1</span>];
  <span class="hljs-keyword">const</span> bronze = athletes[<span class="hljs-number">2</span>];
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Winners of Gold, Silver and Bronze are'</span>, gold, silver, bronze);
};</code></pre>
<p>Das geht einfacher:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> logWinners = <span class="hljs-function">(<span class="hljs-params">[gold, silver, bronze]</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Winners of Gold, Silver and Bronze are'</span>, gold, silver, bronze);
};</code></pre>
<p>Hier reichen wir das Array in unsere <code>logWinners()</code> Funktion herein und statt für jeden Medaillengewinner eine Variable pro Zeile zu deklarieren, nutzen wir auch in diesem Fall ganz einfach wieder die Destructuring Methode von oben.</p>
<h4 id="destructuring-von-objekten">Destructuring von Objekten</h4>
<p>Das Prinzip des <strong>Destructurings</strong> ist nicht allein auf Arrays beschränkt. Auch Objekte können auf diese Art Variablen zugeordnet werden, die standardmäßig mit dem Namen einer Eigenschaft übereinstimmen.</p>
<p>Die Schreibweise ist dabei ähnlich zu der bei Arrays, mit dem Unterschied das wir die Werte nicht anhand ihrer Position im Objekt zuweisen sondern anhand ihres Eigenschafts-Namens. Außerdem setzen wir die Zuweisung in die für Objekte typischen geschweiften Klammern, statt in eckige Klammern.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> user = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Manuel'</span>,
  <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Bieh'</span>,
  <span class="hljs-attr">job</span>: <span class="hljs-string">'JavaScript Developer'</span>,
  <span class="hljs-attr">image</span>: <span class="hljs-string">'manuel.jpg'</span>,
};
<span class="hljs-keyword">const</span> { firstName } = user;</code></pre>
<p>Die Variable <code>firstName</code> enthält nun den Wert aus <code>user.firstName</code>!</p>
<p>Das Object Destructuring ist eins der wohl meist verwendeten Features, das man in den meisten React-Komponenten findet. Es erlaubt uns einzelne Props in Variablen zu schreiben und an entsprechenden Stellen im JSX auf unkomplizierte Weise zu verwenden.</p>
<p>Nehmen wir an dieser Stelle einmal die folgende Stateless Functional Component als Beispiel:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> UserPersona = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{props.image}</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"User Image"</span> /&gt;</span>
      {props.firstName} {props.lastName}
      <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>{props.job}<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  );
};</span></code></pre>
<p>Die ständige Wiederholung von <code>props</code> vor jeder Eigenschaft erschwert die Lesbarkeit der Komponente unnötig. Hier können wir uns Object Destructuring zu Nutze machen um einmalig eine Variable für jede Eigenschaft unserer <code>props</code> zu deklarieren.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> UserPersona = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { firstName, lastName, image, job } = props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{image}</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"User Image"</span> /&gt;</span>
      {firstName} {lastName}
      <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>{job}<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  );
};</span></code></pre>
<p>Damit wirkt unsere Komponente schon deutlich aufgeräumter uns lesbarer. Doch es geht noch einfacher. Wie auch bei Arrays ist es auch möglich Objekte direkt bei der Übergabe als Funktionsargument zu destrukturieren. Statt des <code>props</code> Arguments nutzen wir dafür das <strong>Destructuring Assignment</strong> direkt:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> UserPersona = <span class="hljs-function">(<span class="hljs-params">{ firstName, lastName, image, job }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{image}</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"User Image"</span> /&gt;</span>
    {firstName} {lastName}
    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>{job}<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
);</span></code></pre>
<p>Als Bonus nutzen wir hier sogar die direkte Rückgabe aus der Funktion ohne geschweifte Klammern und explizites <code>return</code> Statement aus dem Kapitel über Arrow Functions, da wir ja nun mit unserem auf 5 Zeilen reduzierten <strong>JSX</strong> einen Ausdruck haben, den wir direkt aus der <strong>Arrow Function</strong> zurückgeben können.</p>
<p>Während der Arbeit mit React trifft man ständig auf derartige Syntax in <strong>SFCs</strong>, auch bei <strong>Class Components</strong> findet man sehr häufig zu Beginn der <code>render()</code>-Methode einer Komponente ein ähnliches Destructuring Assignment in der Form:</p>
<pre><code class="hljs javascript language-javascript">render() {
  <span class="hljs-keyword">const</span> { firstName, lastName, image, job } = <span class="hljs-keyword">this</span>.props;
  <span class="hljs-comment">// weiterer Code</span>
}</code></pre>
<p>Auch wenn das euch natürlich hinterher freigestellt ist ob ihr das so macht oder innerhalb der Funktion einfach weiterhin direkt auf <code>this.props.firstName</code> zugreift. Dieses Muster hat sich aber mittlerweile zu einer Art Best Practice entwickelt und wurde in den meisten Projekten so gehandhabt, da es den Code am Ende in den meisten Fällen lesbarer werden lässt und auch leichter verständlich ist.</p>
<p><strong>Umbenennung von Eigenschaften beim Destructuring</strong></p>
<p>Manchmal ist es notwendig Eigenschaften umzubenennen, entweder weil es bereits Variablen mit dem selben Namen gibt oder die Eigenschaften kein gültiger Variablenname wäre. All das ist denkbar und möglich. Und ES2015 bietet uns auch eine Lösung dafür.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> passenger = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel Bieh'</span>,
  <span class="hljs-attr">class</span>: <span class="hljs-string">'economy'</span>,
};</code></pre>
<p>Das obige <code>passenger</code> Objekt enthält die Eigenschaft class, die als Name für eine Eigenschaft gültig ist, als Name für eine Variable jedoch nicht. Ein direktes Destructuring wäre hier also nicht möglich und würde zu einem Fehler führen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> { name, <span class="hljs-class"><span class="hljs-keyword">class</span> } </span>= passenger;</code></pre>
<div class="hint hint--danger">
<p>Uncaught SyntaxError: Unexpected token }</p>
</div>
<p>Um hier den Namen der Variable umzubenennen muss der Eigenschaft der neue Namen getrennt durch einen Doppelpunkt <code>:</code> übergeben werden. Ein korrektes <strong>Destructuring Assignment</strong> wäre also in diesem Fall in etwa folgendes:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> { name, <span class="hljs-attr">class</span>: ticketClass } = passenger;</code></pre>
<p>Hier schreiben wir den Wert der <code>class</code> Eigenschaft in eine Variable <code>ticketClass</code>, was anders als <code>class</code> ein gültiger Name für eine Variable ist. Der Name des Passagiers landet dabei ganz gewöhnlich in einer Variable mit dem Namen <code>name</code>.</p>
<p><strong>Standardwerte beim Destructuring vergeben</strong></p>
<p>Auch die Vergabe von Standardwerten beim <strong>Destructuring</strong> ist möglich! Ist im Objekt welches destrukturiert wird eine Eigenschaft nicht definiert, wird stattdessen der Default verwendet. Ähnlich wie bei der Umbenennung wird dabei die jeweilige Eigenschaft wie gehabt vorangestellt, jedoch gefolgt von einem Gleich-Zeichen und dem entsprechenden Standardwert:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> { name = <span class="hljs-string">'Unknown passenger'</span> } = passenger;</code></pre>
<p>Der Wert von <code>name</code> wäre nun <code>Unknown passenger</code> wenn im <code>passenger</code> Objekt keine Eigenschaft <code>name</code> existiert oder deren Wert <code>undefined</code> ist. Existiert diese hingegen, ist aber leer (also bspw. ein leerer String oder <code>null</code>) wird der Standardwert <strong>nicht</strong> an dessen Stelle verwendet!</p>
<p><strong>Kombination von Umbenennung und Standardwerten</strong></p>
<p>Jetzt wird es verrückt, denn auch das ist möglich. Die Umbenennung von Eigenschaften in Variablennamen bei gleichzeitiger Verwendung von Standardwerten. Die Syntax dafür ist allerdings etwas, wo man bei der ersten Begegnung sicherlich einen Moment länger hinschauen muss. Wir bleiben wieder bei unserem <code>passenger</code> Objekt aus den Beispielen zuvor. Anforderung ist nun die Zuweisung der <code>name</code> Eigenschaft zu einer Variable mit dem Namen <code>passengerName</code>, die den Wert <code>Unknown Passenger</code> tragen soll, wenn kein Name vorhanden ist. Außerdem möchten wir weiterhin <code>class</code> in <code>ticketClass</code> umbenennen und den Passagier gleichzeitig in <code>Economy</code> einordnen, sollte es im entsprechenden Objekt keine <code>class</code> Eigenschaft geben.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> {
  <span class="hljs-attr">name</span>: passengerName = <span class="hljs-string">'Unknown passenger'</span>,
  <span class="hljs-attr">class</span>: ticketClass = <span class="hljs-string">'economy'</span>,
} = passenger;</code></pre>
<p>Hier besitzen die Variablen <code>passengerName</code> und <code>ticketClass</code> die werte <code>Unknown passenger</code> und <code>economy</code> wenn diese nicht im destrukturierten Objekt existieren. Doch Vorsicht: das Objekt selbst darf nicht null sein, andernfalls bekommen wir vom JavaScript Interpreter einen unschönen Fehler geworfen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> {
  <span class="hljs-attr">name</span>: passengerName = <span class="hljs-string">'Unknown passenger'</span>,
  <span class="hljs-attr">class</span>: ticketClass = <span class="hljs-string">'economy'</span>,
} = <span class="hljs-literal">null</span>;</code></pre>
<div class="hint hint--danger">
<p>Uncaught TypeError: Cannot destructure property `name` of 'undefined' or 'null'.</p>
</div>
<p>Hier gibt es einen unsauberen aber doch oft praktischen Trick um sicherzustellen, dass das Objekt selbst nicht <code>null</code> oder <code>undefined</code> ist. Dazu machen wir uns den <strong>Logical OR Operator</strong> zu nutze und verwenden ein leeres Objekt als Fallback, falls unser eigentliches Objekt eben <code>null</code> oder <code>undefined</code> ist:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> {
  <span class="hljs-attr">name</span>: passengerName = <span class="hljs-string">'Unknown passenger'</span>,
  <span class="hljs-attr">class</span>: ticketClass = <span class="hljs-string">'economy'</span>,
} = passenger || {};</code></pre>
<p>Mit dem angehängten <code>|| {}</code> sagen wir: ist das <code>passenger</code> Objekt <strong>falsy</strong>, nutze stattdessen ein leeres Objekt. Die vermutlich „sauberere“ Variante wäre es vorab zu prüfen ob <code>passenger</code> auch wirklich ein Objekt ist und das Destructuring nur dann auszuführen. Die Variante mit dem <strong>Logical OR</strong> Fallback ist allerdings schön kurz und dürfte in vielen Fällen ausreichen.</p>
<p><strong>Destructuring</strong> kann übrigens auch problemlos mit dem <strong>Spread Operator</strong> zusammen verwendet werden:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> globalSettings = { <span class="hljs-attr">language</span>: <span class="hljs-string">'en-US'</span> };
<span class="hljs-keyword">const</span> userSettings = { <span class="hljs-attr">timezone</span>: <span class="hljs-string">'Berlin/Germany'</span> };
<span class="hljs-keyword">const</span> { language, timezone } = { ...globalSettings, ...userSettings };</code></pre>
<p>Hier wird zuerst der <strong>Spread Operator</strong> aufgelöst, also ein Objekt mit allen Eigenschaften aus den beiden Objekten <code>globalSettings</code> und <code>userSettings</code> erzeugt und anschließend per <strong>Destructuring Assignment</strong> entsprechenden Variablen zugewiesen.</p>
<h3 id="rest-operator">Rest Operator</h3>
<p>Der Rest Operator dient dazu, um sich um die verbliebenen Elemente aus einem <strong>Destructuring</strong> und in <strong>Funktionsargumenten</strong> zu kümmern. Daher der Name: der Operator kümmert sich um den verbliebenen <strong>„Rest“</strong>. Wie auch schon der <strong>Spread Operator</strong> wird auch der <strong>Rest Operator</strong> mit drei Punkten <code>…</code> eingeleitet, jedoch nicht auf der <strong>rechten</strong> Seite einer Zuweisung, sondern auf der <strong>linken</strong>. Anders als beim Spread Operator kann es pro Ausdruck jedoch nur jeweils <strong>einen</strong> Rest Operator geben!</p>
<p>Schauen wir uns zuerst einmal den <strong>Rest Operator</strong> bei Funktionsargumenten an. Sagen wir, wir möchten nun eine Funktion schreiben, die beliebig viele Argumente empfängt. Hier möchten wir natürlich auch auf all diese Argumente zugreifen können, egal ob das 2, 5 oder 25 sind. In ES5 Standardfunktionen gibt es das Keyword <code>arguments</code>mittels dessen auf ein Array aller übergebenen Funktionsargumente zugegriffen werden kann innerhalb der Funktion:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);
}
Example(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p><code>Arguments(5) [1, 2, 3, 4, 5, callee: ƒ]</code></p>
</div>
<p><strong>Arrow Functions</strong> bieten diese Möglichkeit nicht mehr und werfen stattdessen einen Fehler:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> Example = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);
};
Example(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--danger">
<p>Uncaught ReferenceError: arguments is not defined</p>
</div>
<p>Hier kommt nun erstmals der <strong>Rest Operator</strong> ins Spiel. Dieser schreibt uns sämtliche übergebene Funktionsargumente die wir nicht bereits in benannte Variablen geschrieben haben in eine weitere Variable mit einem beliebigen Namen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> Example = <span class="hljs-function">(<span class="hljs-params">...rest</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(rest);
};
Example(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p><code>[1, 2, 3, 4, 5]</code></p>
</div>
<p>Dies funktioniert nicht nur als einzelnes Funktionsargument sondern auch wenn wir vorher bereits benannte Parameter definiert haben. Hier kümmert sich der <strong>Rest Operator</strong> dann buchstäblich um den letzten verbliebenen <strong>Rest:</strong></p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> Example = <span class="hljs-function">(<span class="hljs-params">first, second, third, ...rest</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'first:'</span>, first);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'second:'</span>, second);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'third:'</span>, third);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'rest:'</span>, rest);
};
Example(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p><code>first: 1 second: 2 third: 3 rest: [4, 5]</code></p>
</div>
<p>Der <strong>Rest Operator</strong> sammelt hier also die restlichen, verbliebenen Elemente aus einem <strong>Destructuring</strong> ein und speichert diese in einer Variable mit dem Namen, der hinter den drei Punkten angegeben wird. Dieser muss dabei nicht wie im obigen Beispiel <code>rest</code> heißen sondern kann jeden gültigen JavaScript-Variablennamen annehmen.</p>
<p>Das funktioniert aber nicht nur bei Funktionen sondern ebenso bei <strong>Array Destructuring</strong>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> athletes = [
  <span class="hljs-string">'Usain Bolt'</span>,
  <span class="hljs-string">'Andre De Grasse'</span>,
  <span class="hljs-string">'Christophe Lemaitre'</span>,
  <span class="hljs-string">'Adam Gemili'</span>,
  <span class="hljs-string">'Churandy Martina'</span>,
  <span class="hljs-string">'LaShawn Merritt'</span>,
  <span class="hljs-string">'Alonso Edward'</span>,
  <span class="hljs-string">'Ramil Guliyev'</span>,
];
<span class="hljs-keyword">const</span> [gold, silver, bronze, ...competitors] = athletes;
<span class="hljs-built_in">console</span>.log(gold);
<span class="hljs-built_in">console</span>.log(silver);
<span class="hljs-built_in">console</span>.log(bronze);
<span class="hljs-built_in">console</span>.log(competitors);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<pre><code class="hljs javascript language-javascript"><span class="hljs-string">'Usain Bolt'</span>
<span class="hljs-string">'Andre De Grasse'</span>
<span class="hljs-string">'Christophe Lemaitre'</span><span class="hljs-string">`
[
'Adam Gemili',
'Churandy Martina',
'LaShawn Merritt',
'Alonso Edward',
'Ramil Guliyev'
]
</span></code></pre>
</div>
<p>… wie auch beim <strong>Object Destructuring:</strong></p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> user = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Manuel'</span>,
  <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Bieh'</span>,
  <span class="hljs-attr">job</span>: <span class="hljs-string">'JavaScript Developer'</span>,
  <span class="hljs-attr">hair</span>: <span class="hljs-string">'Brown'</span>,
};
<span class="hljs-keyword">const</span> { firstName, lastName, ...other } = user;
<span class="hljs-built_in">console</span>.log(firstName);
<span class="hljs-built_in">console</span>.log(lastName);
<span class="hljs-built_in">console</span>.log(other);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p><code>Manuel</code><br />
<code>Bieh</code><br />
<code>{ job: 'JavaScript Developer', hair: 'Brown' }</code></p>
</div>
<p>All die Werte, die dabei nicht explizit in eine Variable geschrieben wurden während eines <strong>Destructuring Assignments</strong> können dann in der als <strong>Rest</strong> deklarierten Variable abgerufen werden.</p>
<h2 id="template-strings">Template Strings</h2>
<p><strong>Template Strings</strong> in ES2015 sind eine „dritte Schreibweise“ für Strings in JavaScript. Bisher konnten Strings entweder in einfache Anführungszeichen (<code>'Beispiel'</code>) oder in doppelte Anführungszeichen (<code>"Beispiel"</code>) gesetzt werden. Nun kommt auch die Möglichkeit hinzu, diese in Backticks (<code>Beispiel</code>) zu setzen.</p>
<p><strong>Template Strings</strong> können in zwei Varianten auftreten. Als gewöhnliche <strong>Template Strings</strong>, die JavaScript Ausdrücke enthalten können, sowie in erweiterter Form als sog. <strong>Tagged Template Strings</strong>.</p>
<p><strong>Tagged Template Strings</strong> sind eine deutlich mächtigere Form von <strong>Template Strings</strong>. Mit ihnen kann die Ausgabe von <strong>Template Strings</strong> mittels einer speziellen Funktion modifiziert werden. Das ist bei der gewöhnlichen Arbeit mit React erst einmal weniger wichtig. Später im Kapitel über <strong>CSS in React</strong> werde ich ihre Funktionsweise nochmal etwas genauer am Beispiel von <strong>Styled Components</strong> erklären. <strong>Styled Components</strong> sind eine Möglichkeit um Komponenten in React designen und basieren ganz grundlegend auf <strong>Tagged Template Strings</strong>.</p>
<p>Wollte man sie mit JavaScript-Ausdrücken oder Werten mischen, griff man in ES5 meist zu einfacher <strong>String Concatenation:</strong></p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">var</span> age = <span class="hljs-number">7</span>;
<span class="hljs-keyword">var</span> text = <span class="hljs-string">'Meine Tochter ist '</span> + age + <span class="hljs-string">' Jahre alt'</span>;</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">var</span> firstName = <span class="hljs-string">'Manuel'</span>;
<span class="hljs-keyword">var</span> lastName = <span class="hljs-string">'Bieh'</span>;
<span class="hljs-keyword">var</span> fullName = firstName + <span class="hljs-string">' '</span> + lastName;</code></pre>
<p>Mit <strong>Template Strings</strong> wurde nun eine Variante von String eingeführt, die selbst wiederum <strong>JavaScript-Ausdrücke</strong> enthalten kann. Diese werden dazu innerhalb eines <strong>Template Strings</strong> in eine Zeichenkette in der Form <code>${ }</code> gesetzt. Um bei den obigen Beispielen zu bleiben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> age = <span class="hljs-number">7</span>;
<span class="hljs-keyword">const</span> text = <span class="hljs-string">`Meine Tochter ist <span class="hljs-subst">${age}</span> Jahre alt`</span>;</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> firstName = <span class="hljs-string">'Manuel'</span>;
<span class="hljs-keyword">const</span> lastName = <span class="hljs-string">'Bieh'</span>;
<span class="hljs-keyword">const</span> fullName = <span class="hljs-string">`<span class="hljs-subst">${firstName}</span> <span class="hljs-subst">${lastName}</span>`</span>;</code></pre>
<p>Dabei können innerhalb der geschweiften Klammern sämtliche JavaScript Ausdrücke verwendet werden. Also auch Funktionsaufrufe:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Das heutige Datum ist <span class="hljs-subst">${<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString()}</span>`</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${firstName.toUpperCase()}</span> <span class="hljs-subst">${lastName.toUpperCase()}</span>`</span>);</code></pre>
<h2 id="promises-und-asyncawait">Promises und async/await</h2>
<p>Promises (dt. <em>Versprechen</em>) sind kein grundsätzlich neues Konzept in JavaScript, in ES2015 haben sie aber erstmals Einzug in den Standard erhalten und können nativ ohne eine andere Library (z.B. q, Bluebird, rsvp.js, …) verwendet werden. Ganz grob erlauben Promises es, die asynchrone Entwicklung durch Callbacks zu <em>linearisieren</em>. Ein Promise bekommt eine <strong>Executor-Funktion</strong> übergeben, die ihrerseits die zwei Argumente <code>resolve</code> und <code>reject</code> übergeben bekommen, und kann einen von insgesamt drei verschiedenen Zuständen annehmen: als Initialwert ist dieser Zustand <code>pending</code> und je nachdem ob eine Operation erfolgreich oder fehlerhaft war, die Executor-Funktion also das erste (<code>resolve</code>) oder das zweite (<code>reject</code>) Argument ausgeführt hat, wechselt dieser Zustand zu <code>fulfilled</code> oder <code>rejected</code>. Auf die beiden Endzustände kann dann mittels der Methoden <code>.then()</code> und <code>.catch()</code> reagiert werden. Wird <code>resolve</code> aufgerufen, wird der ´then()<code>-Teil ausgeführt, wird</code>reject<code>aufgerufen, werden **sämtliche**</code>then()<code>Aufrufe übersprungen und der</code>catch()` Teil wird stattdessen ausgeführt.</p>
<p>Eine Executor-Funktion <strong>muss</strong> dabei zwangsweise eine der beiden übergebenen Methoden ausführen, andernfalls bleibt das Promise dauerhaft <em>unfulfilled</em>, was zu fehlerhaften Verhalten und in bestimmten Fällen sogar zu Memory Leaks innerhalb einer Anwendung führen kann.</p>
<p>Um den Unterschied zwischen Promises und Callbacks einmal zu demonstrieren werfen wir einen Blick auf das folgende fiktive Beispiel:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> errorHandler = <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'An error occured:'</span>, err.message);
};

getUser(
  id,
  (user) =&gt; {
    user.getFriends(<span class="hljs-function">(<span class="hljs-params">friends</span>) =&gt;</span> {
      friends[<span class="hljs-number">0</span>].getSettings(<span class="hljs-function">(<span class="hljs-params">settings</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (settings.notifications === <span class="hljs-literal">true</span>) {
          email.send(
            <span class="hljs-string">'You are my first friend!'</span>,
            (status) =&gt; {
              <span class="hljs-keyword">if</span> (status === <span class="hljs-number">200</span>) {
                alert(<span class="hljs-string">'User has been notified via email!'</span>);
              }
            },
            errorHandler
          );
        }
      }, errorHandler);
    }, errorHandler);
  },
  errorHandler
);</code></pre>
<p>Wir rufen über die asynchrone <code>getUser()</code>-Funktion einen User zu einer entsprechenden <code>id</code> ab. Von diesem User besorgen wir uns mittels der asynchronen <code>getFriends()</code>-Methode eine Liste aller seiner Freunde. Vom ersten Freund (<code>friends[0]</code>) rufen wir mittels der asynchronen <code>getSettings()</code>-Methode die Benutzereinstellungen ab. Erlaubt der Benutzer E-Mail-Benachrichtigungen, schicken wir ihm eine E-Mail und reagieren, ebenfalls wieder asynchron, auf den Response des Mailservers.</p>
<p>Dabei ist das Beispiel noch ein relativ simples, es gibt keinerlei explizite Fehlerbehandlung und es gibt auch keine nennenswerten Ausnahmefälle. Dennoch ist der Code im Beispiel bereits <strong>6 Ebenen</strong> tief verschachtelt. Das Arbeiten mit Callbacks kann daher schnell unübersichtlich werden, insbesondere wenn innerhalb einer Callback-Funktion weitere Callback-Funktionen ausgeführt werden, wie in unserem Beispiel. So kommt es schnell zu der oft auch als <strong>Pyradmid of Doom</strong> bezeichneten Verschachtelung von Callbacks.</p>
<p>Nun schreiben wir das Beispiel einmal um und gehen davon aus, unsere fiktiven API-Methoden geben jeweils ein Promise zurück:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> errorHandler = <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'An error occured:'</span>, err.message);
};

getUser(id)
  .then(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> user.getFriends())
  .then(<span class="hljs-function">(<span class="hljs-params">friends</span>) =&gt;</span> friends[<span class="hljs-number">0</span>].getSettings())
  .then(<span class="hljs-function">(<span class="hljs-params">settings</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (settings.notifications === <span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">return</span> email.send(<span class="hljs-string">'You are my first friend!'</span>);
    }
  })
  .then(<span class="hljs-function">(<span class="hljs-params">status</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (status === <span class="hljs-number">200</span>) {
      alert(<span class="hljs-string">'User has been notified via email'</span>);
    }
  })
  .catch(errorHandler);</code></pre>
<p>Wir reagieren hier nach jedem Schritt mittels <code>then()</code> auf das zurückgegebene Promise, erreichen das gleiche Resultat wie vorher bei der Callback-Version, haben aber an der tiefsten Stelle lediglich eine Verschachtelung die 2 Ebenen tief ist.</p>
<p>Dabei ist es relativ simpel bestehenden, Callback basierenden Code in Promises umzuschreiben. Das möchte ich kurz anhand der Geolocation API und konkret deren <code>getCurrentPosition()</code>-Methode demonstrieren. Wer es nicht kennt: die Methode existiert auf dem <code>navigator.geolocation</code> Objekt, öffnet eine Benachrichtigung im Browser und fragt den Benutzer um Erlabnis ihn orten zu dürfen. Sie erwartet zwei Callbacks als Argument: das erste, der Success-Callback, bekommt ein Objekt mit der Position des Benutzers übergeben, falls dieser der Ortung zustimmt. Der zweite, der Error-Callback, bekommt ein Fehler-Objekt übergeben, falls der Benutzer einer Ortung entweder nicht zugestimmt hat oder eine Ortung aus anderen Gründen nicht möglich ist.</p>
<pre><code class="hljs javascript language-javascript">navigator.geolocation.getCurrentPosition(
  <span class="hljs-function">(<span class="hljs-params">position</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(
      <span class="hljs-string">`User position is at <span class="hljs-subst">${position.coords.latitude}</span>, <span class="hljs-subst">${
        position.coords.longitude
      }</span>`</span>
    );
  },
  () =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Unable to locate user'</span>);
  }
);</code></pre>
<p>Und so wird der Callback in ein Promise umgewandelt:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> getCurrentPositionPromise = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    navigator.geolocation.getCurrentPosition(resolve, reject);
  });
};</code></pre>
<p>Jap. Das war es wirklich schon. Nun können wir statt mittels der Callback-Syntax über folgenden Aufruf auf die Position des Benutzers zugreifen:</p>
<pre><code class="hljs javascript language-javascript">getCurrentPositionPromise()
  .then(<span class="hljs-function">(<span class="hljs-params">position</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(
      <span class="hljs-string">`User position is at <span class="hljs-subst">${position.coords.latitude}</span>, <span class="hljs-subst">${
        position.coords.longitude
      }</span>`</span>
    );
  })
  .catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Unable to locate user'</span>);
  });</code></pre>
<p>Einige neuere JavaScript APIs im Browser sind bereits diesem Ansatz folgend implementiert worden. Wer mehr über Promises und deren Funktionsweise erfahren möchte, dem empfehle ich <a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Promise">den entsprechenden Artikel bei den MDN Web Docs</a> zu lesen. Die Erklärung zu Promises sollte nur einleitend sein um auf ein deutlich spannenderes neues Feature vorzubereiten, nämlich:</p>
<h3 id="asynchrone-funktionen-mit-async-und-await">Asynchrone Funktionen mit <code>async</code> und <code>await</code></h3>
<p>Asynchrone Funktionen mit den Schlüsselwörtern <code>async</code> und <code>await</code> kann vielleicht ein Bisschen als die „nächste Evolutionsstufe“ in der asynchronen Entwicklung nach Callbacks und Promises gesehen werden. Sie haben Einzug in die JavaScript-Spezifikation in ES2016 erhalten. Unter der Haube nutzen sie zwar noch immer Promises, machen diese aber weitgehend unsichtbar. Sie erlauben es uns asynchronen Code so zu schreiben, dass er nahezu wie synchroner Code aussieht. Keine Callbacks mehr und auch kein <code>then()</code> oder <code>catch()</code> mehr.</p>
<p>Dazu wird einem asynchronen Funktionsaufruf das Schlüsselwort <code>await</code> vorangestellt. Um <code>await</code> nutzen zu können, muss die umgebende Funktion das zweite Schlüsselwort <code>async</code> vorangestellt werden, um dem JavaScript-Interpreter mitzuteilen, dass es sich um eine solche asynchrone Funktion handelt. Bei der Nutzung von <code>await</code> ohne eine Funktion als <code>async</code> zu markieren kommt es zu einer Exception.</p>
<p>Werfen wir also nochmal einen Blick auf das Beispiel unseres Users, der eine E-Mail an seinen ersten Freund schicken möchte. Diesmal mit asynchronen Funktionen:</p>
<pre><code class="hljs javascript language-javascript">(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> getUser(id);
    <span class="hljs-keyword">const</span> friends = <span class="hljs-keyword">await</span> user.getFriends();
    <span class="hljs-keyword">const</span> settings = <span class="hljs-keyword">await</span> friends[<span class="hljs-number">0</span>].getSettings();
    <span class="hljs-keyword">if</span> (settings.notifications === <span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">const</span> status = <span class="hljs-keyword">await</span> email.send(<span class="hljs-string">'You are my first friend!'</span>);
      <span class="hljs-keyword">if</span> (status === <span class="hljs-number">200</span>) {
        alert(<span class="hljs-string">'User has been notified via email'</span>);
      }
    }
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'An error occured:'</span>, err.message);
  }
})();</code></pre>
<p>Asynchrone Funktionen mit <code>async</code> und <code>await</code> sind für mich persönlich eine der nennenswertesten Veränderungen von JavaScript in den vergangenen Jahren, da sie das Arbeiten mit asynchronen Daten fast zum Kinderspiel werden lassen, verglichen mit komplexen und unübersichtlichen Callbacks. Und auch Promises, die bereits eine große Erleichterung ggü. herkömmlichen Callbacks waren, wirken im direkten Vergleich mit asynchronen Funktionen schon beinahe komplex.</p>
<h2 id="import-syntax-und-javascript-module">import-Syntax und Javascript-Module</h2>
<p>Module in JavaScript sind so eine Sache. Offiziell gab es sie bisher nicht, aber es gab immer wieder Versuche, Module in JavaScript einzuführen. Wer schon etwas länger dabei ist wird vielleicht noch <strong>AMD</strong> (Asynchronous Module Definition) kennen, wer mal mit Node.js gearbeitet hat, dem sollten außerdem CommonJS-Module (d.h. <code>module.exports</code> und <code>require('./myModule')</code>) ein Begriff sein. Lange gab es dann ausführliche Diskussionen darüber, auf welchen Modul-Standard man sich einigt, wie die Syntax aussieht und wie letztendlich die Implementierung auf Interpreter-Seite aussieht. Die Wahl fiel auf Modulen, die mittels <code>import</code> und <code>export</code> Keywords untereinander kommunizieren.</p>
<p>Babel ist dann vorangegangen und hat eine Lösung implementiert, die auf dem damaligen Stand der offiziellen Spezifikation basierte. Diese Umsetzung wurde dann zwischendurch mal geändert, weil es Updates am entsprechenden Standard gab, dann kam noch Webpack und implementierte einen eigenen Mechanismus zum Auflösen und Laden von JavaScript-Modulen, der sich am nun verabschiedeten Standard orientiert. Ebenso wie TypeScript.</p>
<p>Mittlerweile ist man sich nach gerade einmal <strong>10</strong> Jahren bei der Spezifikation einig und die Umsetzung auf Seiten der JavaScript-Engines ist im vollen Gange. Klingt kompliziert, ist es zwischendrin auch mal gewesen, inzwischen gibt es aber Konsens und für uns Entwickler herrscht allmählich Klarheit. Aber dennoch gibt es auch noch immer einige Fallstricke, durch die wir auch in Zukunft auf Webpack, Babel oder TypeScript setzen müssen (oder eher: sollten), um komfortabel mit Modulen zu arbeiten. Dazu später mehr.</p>
<p>Soviel zur Historie. Also wie funktionieren jetzt Imports und was sind Module überhaupt?</p>
<h3 id="module-in-javascript">Module in JavaScript</h3>
<p>Das Ziel von Modulen ist es, Scopes in JavaScript auf einer <strong>per Modul-Ebene zu kapseln</strong>. Ein Modul in diesem Sinne ist tatsächlich ein einzelnes <strong>File</strong>. Sofern man sie nicht explizit durch das Erstellen eines neuen Scopes begrenzt, z.B. indem man es in eine <strong>IIFE</strong> (Immediately Invoked Function Expression) einschließt, ist jede Funktion, jede Variable, die in JavaScript definiert wird erst einmal global verfügbar. Module wirken dem entgegen, indem sämtlicher Code erst einmal nur <strong>innerhalb des Moduls</strong> verfügbar ist. Dadurch vermeidet man Komplikationen, bspw. wenn zwei Libraries die gleiche Variable nutzen, außerdem schafft man auf einfache Art wiederverwendbaren Code, ohne auf der anderen Seite Angst haben zu müssen, dass dieser an anderer Stelle bereits existierende Variablen oder Funktionen ungewollt überschreibt.</p>
<p>Module können die in ihnen definierten Funktionen, Klassen oder Variablen <strong>exportieren</strong>, andere Module können diese Exports dann bei Bedarf importieren. Für den Export von Funktionen und Variablen gibt es ein <code>export</code>-Keyword, um diese Exports dann später an anderer Stelle zu importieren gibt es, ihr denkt es euch, das entsprechende <code>import</code>-Keyword. Exports können zwei Formen annehmen, nämlich zum Einen die eines <strong>Named Exports</strong> (dt. <strong>benannte Exporte</strong>) und auf der anderen Seite den, des <strong>Default Export</strong> (dt. <strong>Standard Export</strong>).</p>
<h4 id="named-exports">Named Exports</h4>
<p>Nehmen wir an wir haben ein Modul <code>calc.mjs</code>, das allerhand Funktionen für uns bereitstellt, um Berechnungen verschiedener Art auszuführen. Das Modul könnte bspw. den folgenden Inhalt haben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> double = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number * <span class="hljs-number">2</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> square = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number * number;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> divideBy = <span class="hljs-function">(<span class="hljs-params">number, divisor</span>) =&gt;</span> number / divisor;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> divideBy5 = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> divideBy(number, <span class="hljs-number">5</span>);</code></pre>
<p>Wir kündigen hier also einen <strong>Export</strong> an, definieren direkt danach eine Variable der wir eine Arrow Function zuweisen, die einen Parameter bekommt (oder zwei) und direkt das Ergebnis der Berechnung zurückgibt. Alternativ geht das auch in zwei separaten Schritten:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> double = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number * <span class="hljs-number">2</span>;
<span class="hljs-keyword">export</span> double;</code></pre>
<p>An anderer Stelle innerhalb unserer Anwendung können wir diese Funktionen nun mittels <code>import</code>-Keyword <strong>importieren</strong>. Dazu nutzen wir <code>import</code> gefolgt von den Exports, die wir importieren wollen, in geschweiften Klammern, gefolgt von <code>from</code> und dem Pfad zum Modul.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> { double, square, divideBy5 } <span class="hljs-keyword">from</span> <span class="hljs-string">'./calc.mjs'</span>;

<span class="hljs-keyword">const</span> value = <span class="hljs-number">5</span>;
<span class="hljs-built_in">console</span>.log(double(value)); <span class="hljs-comment">// 10</span>
<span class="hljs-built_in">console</span>.log(square(value)); <span class="hljs-comment">// 25</span>
<span class="hljs-built_in">console</span>.log(divideBy5(value)); <span class="hljs-comment">// 1</span></code></pre>
<p>Ein File kann dabei theoretisch <strong>unbegrenzt viele benannte Exports</strong> haben, sie müssen sich jedoch in ihrem Namen unterscheiden und ein bereits exportierter Name <strong>darf nicht ein weiteres Mal exportiert werden.</strong></p>
<h4 id="default-export">Default Export</h4>
<p>Zusätzlich zu den (Plural) sog. <strong>Named Exports</strong> aus dem obigen Beispiel gibt es noch den (Singular) <code>Default Export</code>. Eine spezielle Form eines Exports, der innerhalb eines jeden Moduls nur <strong>ein einziges Mal</strong> vorkommen darf und der mit dem Keyword <code>default</code> gekennzeichnet wird. Wird eine Variable oder eine Funktion als <code>default</code> gekennzeichnet ist es möglich, diesen Export auch ohne geschweifte Klammern zu importieren. Der <strong>Default Export</strong> kann z.B. dazu dienen, um mehrere benannte Exporte zu bündeln, um diese anschließend nicht einzeln importieren zu müssen.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> double = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number * <span class="hljs-number">2</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> square = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number * number;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> divideBy = <span class="hljs-function">(<span class="hljs-params">number, divisor</span>) =&gt;</span> number / divisor;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> divideBy5 = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> divideBy(number, <span class="hljs-number">5</span>);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  double,
  square,
  divideBy,
  divideBy5,
};</code></pre>
<p>Unsere Anwendung müsste dann stattdessen lediglich das Modul selbst importieren, also dessen <strong>Default Export</strong> und einer Variable zuweisen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> Calc <span class="hljs-keyword">from</span> <span class="hljs-string">'./calc.mjs'</span>;

<span class="hljs-built_in">console</span>.log(Calc.double(value)); <span class="hljs-comment">// 10</span>
<span class="hljs-built_in">console</span>.log(Calc.square(value)); <span class="hljs-comment">// 25</span>
<span class="hljs-built_in">console</span>.log(Calc.divideBy5(value)); <span class="hljs-comment">// 1</span></code></pre>
<p>Grundsätzlich ist es in vielen Fällen sinnvoll, dass ein Modul auch einen Default Export hat. Insbesondere bei Komponenten basierten Libraries wie React oder auch Vue.js ist es üblich nur einen Export pro Modul zu haben, dieser sollte dann der <strong>Default Export</strong> sein. Auch wenn dies syntaktisch nicht zwingend notwendig wäre, ist dies inzwischen de-facto Standard bei der Arbeit mit React.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-comment">// ...</span>
}</code></pre>
<h3 id="fallstricke-browser-vs-nodejs">Fallstricke: Browser vs. Node.js</h3>
<p>Wer aufmerksam war und gut aufgepasst hat, dem wird vielleicht aufgefallen sein, dass wir oben aus einem File mit dem Namen <code>calc.mjs</code> importieren, nicht <code>calc.js</code> (<code>.mjs</code> statt <code>.js</code>). Dies ist die Konvention, auf die man sich im langwierigen, oben beschriebenen Standardisierungsprozess geeinigt hat bei der Verwendung von JavaScript-Modulen in Node.js.</p>
<p>Wollt ihr also universelles JavaScript schreiben, also JavaScript das sowohl serverseitig mit Node.js ausgeführt werden kann, als auch clientseitig im Browser funktioniert, und wollt ihr das tun ohne einen Compiler-Zwischenschritt durch bspw. Babel, Webpack oder TypeScript einzulegen, <strong>müsst</strong> ihr zwangsweise die <code>.mjs</code>-Endung für eure Files verwenden.</p>
<p>Das Laden von Modulen funktioniert in Node.js also etwas anders als im Browser. Während es dem Browser egal ist welche Datei-Endung ein Modul hat (solange der Server den Content-Type <code>text/javascript</code> mitsendet), benötigt Node.js zwangsweise die <code>.mjs</code> Datei-Endung um JavaScript-Module als solche zu identifizieren.</p>
<p>Um JavaScript-Module im Browser zu nutzen, muss das <code>type</code>-Attribut auf dem <code>&lt;script&gt;&lt;/script&gt;</code>-Element den Wert <code>module</code> erhalten. Also:</p>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./myApp.mjs"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>Browser die den <code>type="module"</code> unterstützen, unterstützen auch gleichzeitig das <code>nomodule</code>-Attribut zur Auslieferung von Fallbacks für Browser ohne Module-Unterstützung und ignorieren dieses.</p>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./myApp.mjs"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./myApp.bundle.js"</span> <span class="hljs-attr">nomodule</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>Ein Browser mit Module-Support würde hier die <code>myApp.mjs</code> laden, während alle anderen stattdessen ein gebundletes (bspw. durch Webpack) <code>myApp.bundle.js</code> laden würden.</p>
<p>Doch das ist noch nicht alles, denn Node.js besitzt einen sehr eigenen Mechanismus zum Finden und Laden von Dateien. So werden bspw. Module die keinen relativen Pfad haben, also nicht mit <code>./</code> oder <code>../</code> beginnen, z.B. in <code>node_modules</code> oder <code>node_libraries</code> gesucht. Außerdem lädt Node.js standardmäßig eine darin befindliche index.js wenn Node.js einen Ordner mit dem angegebenen Namen findet.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> MyModule <span class="hljs-keyword">from</span> <span class="hljs-string">'myModule'</span>;</code></pre>
<p>Node.js würde also nach diesem Import u.a. im Ordner <code>./node_modules/myModule</code> suchen, dort eine <code>index.js</code> laden oder alternativ im <code>main</code>-Feld der <code>package.json</code> nach dem korrekten File suchen. Der Browser kann hingegen nicht nach belieben verschiedene Pfade ausprobieren um das richtige File zu finden, da dies jedesmal einen teuren Netzwerkrequest und möglicherweise viele 404 Responses verusachen würde.</p>
<p>Hinzu kommt, dass <strong>Import Specifier</strong>, das ist der Part hinter dem <code>from</code>, also das Modul aus dem ihr importieren wollt, im Browser geschützt sind und aus einer gültigen URL oder einem relativen Pfad bestehen müssen.</p>
<p>Imports wie der folgende, sind damit im Browser momentan gar nicht möglich:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;</code></pre>
<p>Abhilfe schaffen sollen hier später einmal die <strong>Package Name Maps</strong>, ein Proposal, also ein Vorschlag, für kommende ECMAScript Versionen, das aber momentan noch ganz am Anfang der Diskussion steht. Darum kommen wir wie eingangs erwähnt in absehbarer Zeit nicht drum herum auch weiterhin einen Module Bundler wie Webpack zu benutzen, um komfortabel mit ES-Modules arbeiten zu können wenn wir JavaScript-Module gleichzeitig sowohl serverseitig als auch clientseitig nutzen wollen.</p>
<h2 id="fazit">Fazit</h2>
<p>ES2015 und die nachfolgenden Versionen bieten eine Menge nützliche neue Funktionen die es bisher in JavaScript nicht gab. Viele davon sind bei der Arbeit mit React nahezu nicht wegzudenken. Zu den wichtigsten Neuerungen gehören die hier beschriebenen:</p>
<ul>
<li>Variablendeklarationen mit <code>let</code> und <code>const</code></li>
<li><strong>Arrow Functions</strong>, um Funktionen zu erstellen die kein eigenes <code>this</code> binden</li>
<li><strong>Klassen</strong>. Machen vieles einfacher und sind die Basis von <strong>React Class Components</strong></li>
<li>Die <strong>Rest und Spread Operatoren</strong>, die das Lesen und Schreiben von Daten in Arrays und Objekten deutlich vereinfachen</li>
<li><strong>Template Strings</strong>, um die Arbeit mit JavaScript-Ausdrücken in Strings einfacher zu machen</li>
<li><strong>Promises</strong> und <strong>Asynchrone Funktionen</strong> mittels <code>async</code>/<code>await</code> um die Arbeit mit asynchronen Daten deutlich zu vereinfachen</li>
<li><strong>Import</strong> und <strong>Export</strong> für die Kapselung von wiederverwendbarem JavaScript auf Module-Ebene</li>
</ul>
</div>
<div class="chapter">
  <h1 id="jsx-–-eine-einführung">JSX – eine Einführung</h1>
<h2 id="jsx-als-wichtiger-bestandteil-in-der-react-entwicklung">JSX als wichtiger Bestandteil in der React-Entwicklung</h2>
<p>Bevor wir tiefer in die Entwicklung von Komponenten einsteigen möchte ich zuerst einmal auf <strong>JSX</strong> eingehen, da JSX einen wesentlichen Teil bei der Arbeit mit React darstellt. Wie eingangs schon erwähnt stellt JSX einen ganz grundlegenden Teil der meisten React-Komponenten dar und ist aus meiner Sicht einer der Gründe, warum React so schnell und positiv von so vielen Entwicklern angenommen wurde. Mittlerweile bieten auch andere Frameworks wie Vue.js die Möglichkeit JSX zur Komponenten getriebenen Entwicklung einzusetzen.</p>
<p>JSX sieht auf den ersten Blick erst einmal gar nicht sehr viel anders aus als HTML, oder eher noch XML, da in JSX, eben wie auch in XML und XHTML jedes geöffnete Element ein schließendes Element (<code>&lt;/div&gt;</code>) besitzen oder selbstschließend (<code>&lt;img /&gt;</code>) sein muss. Mit dem grundlegenden Unterschied, dass JSX auf <strong>JavaScript-Ausdrücke</strong> zurückgreifen kann und dadurch sehr mächtig wird.</p>
<p>Unter der Haube werden in JSX verwendete Elemente in einem späteren Build-Prozess in verschachtelte <code>React.createElement()</code>-Aufrufe umgewandelt. Wir erinnern uns zurück an die Einleitung. Dort hatte ich bereits kurz erwähnt das React eine Baumstruktur an Elementen erzeugt, die selbst aus verschachtelten <code>React.createElement()</code>-Aufrufen besteht.</p>
<p>Klingt jetzt alles fürchterlich kompliziert, ist aber ganz einfach. Wirklich. Ein Beispiel: sehen wir uns einmal das folgende kurze HTML-Snippet an:</p>
<pre><code class="hljs jsx language-jsx">&lt;div id="app"&gt;
  &lt;p&gt;Ein Paragraph in JSX&lt;/p&gt;
  &lt;p&gt;Ein weiterer Paragraph&lt;/p&gt;
&lt;/div&gt;</code></pre>
<p>Wird dieses HTML so in dieser Form in <strong>JSX</strong> verwendet, werden diese Elemente werden später durch Babel in das folgende ausführbare JavaScript transpiliert:</p>
<pre><code class="hljs javascript language-javascript">React.createElement(
  <span class="hljs-string">'div'</span>,
  { <span class="hljs-attr">id</span>: <span class="hljs-string">'app'</span> },
  React.createElement(<span class="hljs-string">'p'</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'Ein Paragraph in JSX'</span>),
  React.createElement(<span class="hljs-string">'p'</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'Ein weiterer Paragraph'</span>)
);</code></pre>
<p>Das erste Funktionsargument für <code>createElement()</code> ist dabei jeweils der Tag-Name eines DOM-Elements als String-Repräsentation oder ein anderes JSX-Element, dann allerdings als Funktionsreferenz.</p>
<p>Das zweite Argument repräsentiert die <strong>Props</strong> eines Elements, also in etwa vergleichbar mit HTML-Attributen, wobei die Props in React deutlich flexibler sind und anders als herkömmliche HTML-Attribute nicht auf Strings beschränkt sind, sondern auch Arrays, Objekte oder gar andere React-Komponenten als Wert enthalten können.</p>
<p>Alle weiteren Argumente stellen die Kind-Elemente (<em>„children“</em>) des Elements dar. Im obigen Beispiel hat unser <code>div</code> zwei Paragraphen (<code>&lt;p&gt;</code>) als Kind-Elemente, welche selbst keine eigenen Props haben (<code>null</code>) und lediglich einen Text-String (<code>Ein Paragraph in JSX</code> bzw <code>Ein weiterer Paragraph</code>) als Kind-Element besitzt.</p>
<p>Wem das jetzt zu kompliziert klingt den kann ich beruhigen: das geht in der Praxis hinterher wie von selbst von der Hand. Fast so, als würde man HTML-Markup schreiben. Dennoch halte ich es für wichtig die Hintergründe zumindest einmal gelesen zu haben um spätere Beispiele besser nachvollziehen zu können.</p>
<h2 id="ausdrücke-in-javascript">Ausdrücke in JavaScript</h2>
<p>Was bedeutet dies nun für unsere JavaScript-Ausdrücke, auf die wir ja nun auch in JSX zurückgreifen können?</p>
<p>Zuerst einmal ist ein Ausdruck in JavaScript, kurz gesagt, ein Stück Code, der am Ende einen „Wert“ erzeugt bzw ein „Ergebnis“ zur Folge hat. Vereinfacht gesagt: alles was man bei der Variablenzuweisung auf die <strong>rechte</strong> Seite des Gleich-Zeichens (=) schreiben kann.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-number">1</span> + <span class="hljs-number">5</span>;</code></pre>
<p>… ist ein solcher Ausdruck, dessen Wert <code>6</code> beträgt.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-string">'Hal'</span> + <span class="hljs-string">'lo'</span>;</code></pre>
<p>… ist ein anderer Ausdruck der die zwei Strings <code>Hal</code> und <code>lo</code> per <strong>String Concatenation</strong> zu einem Wert <code>Hallo</code> zusammenfügt.</p>
<p>Stattdessen könnten wir aber auch einfach gleich schreiben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-number">6</span>
<span class="hljs-string">'Hallo'</span>
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
{<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>}
<span class="hljs-literal">true</span>
<span class="hljs-literal">null</span></code></pre>
<p>… da <strong>JavaScript-Datentypen</strong> allesamt auch als Ausdruck verwendet werden können.</p>
<p>Die ES2015 <strong>Template String Syntax</strong>, die Backticks (```) benutzt, ist ebenfalls ein Ausdruck. Klar, sind sie doch letztlich nichts anderes als ein String:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-string">`Hallo <span class="hljs-subst">${name}</span>`</span>;</code></pre>
<p>Was hingegen <strong>kein</strong> Ausdruck ist, ist:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">if</span> (active &amp;&amp; visibility === <span class="hljs-string">'visible'</span>) { … }</code></pre>
<p>… da ich zum Beispiel auch nicht schreiben könnte:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> isVisible = <span class="hljs-keyword">if</span> (active &amp;&amp; visibility === <span class="hljs-string">'visible'</span>) { … }</code></pre>
<p>Das würde mir jeder JavaScript-Interpreter wegen ungültiger Syntax um die Ohren hauen.</p>
<p>Lasse ich das <code>if</code> hier hingegen allerdings weg habe ich einen <strong>Logical AND Operator</strong>, der wiederum ein Ausdruck ist und einen Wert zum Ergebnis hat (in diesem Fall <code>true</code> oder <code>false</code>):</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> isVisible = active &amp;&amp; visibility === <span class="hljs-string">'visible'</span>;</code></pre>
<p>Ebenso ist der Ternary-Operator ( ? : ) ein Ausdruck:</p>
<pre><code class="hljs javascript language-javascript">Bedingung ? wahr : unwahr;</code></pre>
<p>Ausdrücke sind aber nicht auf boolsche Werte, Nummern, Strings beschränkt sondern können auch Objekte, Arrays, Funktionsaufrufe und sogar Arrow-Functions sein, die ebenfalls neu in ES2015 eingeführt werden und uns hier nicht das letzte mal begegnet sein werden.</p>
<p>Beispiel für eine Arrow-Function:</p>
<pre><code class="hljs javascript language-javascript">(number) =&gt; {
  <span class="hljs-keyword">return</span> number * <span class="hljs-number">2</span>;
};</code></pre>
<p>All das wird später noch wichtig werden. Um dem ganzen jetzt endgültig die Krone aufzusetzen können Ausdrücke selbst wiederum wieder JSX beinhalten und so kann man das Spiel endlos weiterführen. Uff.</p>
<p>Da das später noch wichtig wird, hier nochmal einige Beispiele für JSX, das gültige Ausdrücke beinhaltet:</p>
<h4 id="simple-mathematik">Simple Mathematik</h4>
<pre><code class="hljs jsx language-jsx">&lt;span&gt;<span class="hljs-number">5</span> + <span class="hljs-number">1</span> = {<span class="hljs-number">5</span> + <span class="hljs-number">1</span>}&lt;<span class="hljs-regexp">/span&gt;</span></code></pre>
<h4 id="ternary-operator">Ternary Operator</h4>
<pre><code class="hljs jsx language-jsx">&lt;span&gt;Heute ist {<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getDay() === <span class="hljs-number">1</span> ? <span class="hljs-string">'Montag'</span> : <span class="hljs-string">'nicht Montag'</span>}&lt;<span class="hljs-regexp">/span&gt;</span></code></pre>
<h4 id="ternary-operator-als-wert-einer-prop">Ternary Operator als Wert einer Prop</h4>
<pre><code class="hljs jsx language-jsx">&lt;div className={user.isAdmin ? <span class="hljs-string">'is-admin'</span> : <span class="hljs-literal">null</span>}&gt;…&lt;<span class="hljs-regexp">/div&gt;</span></code></pre>
<h4 id="arraymap-mit-jsx-als-rückgabewert-das-wiederum-einen-ausdruck-enthält">Array.map() mit JSX als Rückgabewert das wiederum einen Ausdruck enthält</h4>
<pre><code class="hljs jsx language-jsx">&lt;ul&gt;
  {[<span class="hljs-string">'Tim'</span>, <span class="hljs-string">'Struppi'</span>].map(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>{name})<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
  ))}
&lt;<span class="hljs-regexp">/ul&gt;</span></code></pre>
<h4 id="zahlenwerte-in-props">Zahlenwerte in Props</h4>
<pre><code class="hljs jsx language-jsx">&lt;input type=<span class="hljs-string">"range"</span> min={<span class="hljs-number">0</span>} max={<span class="hljs-number">100</span>} /&gt;</code></pre>
<p>All dies sind erste Beispiele wie Ausdrücke dafür verwendet werden können um aus JSX mehr als nur simples HTML zu machen.</p>
<h2 id="was-man-außerdem-wissen-sollte">Was man außerdem wissen sollte</h2>
<p>Wer die Beispiele aufmerksam studiert hat, dem werden je nach JavaScript-Kenntnissen vielleicht einige Dinge aufgefallen sein. Zuerst einmal tauchen in den Beispielen scheinbar willkürlich Klammern auf. Dies hat den Hintergrund, dass JSX stets in Klammern, also „<code>(</code>“ und „<code>)</code>“ geschrieben werden muss wenn sich das JSX sich über mehr als eine Zeile erstreckt (also doch nicht willkürlich.)</p>
<p>Prinzipiell schadet es nicht sein komplettes JSX immer in Klammern zu schreiben, auch wenn es sich nur um eine einzige Zeile handelt, Viele Leute bevorzugen das sogar aus Gründen der Einheitlichkeit, wirklich zwingend notwendig ist das aber nur bei mehrzeiligem JSX.</p>
<p>Möchten wir statt eines <strong>Strings</strong> einen <strong>Ausdruck</strong> innerhalb der Props nutzen wie im Beispiel <em>„Ternary Operator als Wert einer Prop“</em>, so nutzen wir dafür statt einfacher oder doppelter Attribut-Anführungszeichens auch hier die geschweiften Klammern um React mitzuteilen: hier drin befindet sich ein Ausdruck.</p>
<div class="hint hint--warning">
<p>Bei Objekten als Wert müssen jeweils <strong>zwei</strong> öffnende und schließende Klammern geschrieben werden. Die äußeren Klammern leiten den Ausdruck ein (bzw. beenden diesen) und die inneren sind die, des eigentlichen Objekts:</p>
<p><code>&lt;User data={{ name: 'Manuel', location: 'Berlin' }} /&gt;</code></p>
<p>Das gilt in ähnlicher Form auch für Array-Literals, natürlich mit dem Unterschied, dass die inneren Klammern die eckigen sind, die das Array-Literal kennzeichnen:</p>
<p><code>&lt;List items={[1, 2, 3, 4, 5]} /&gt;</code></p>
</div>
<p>Weiter könnte manch einem aufgefallen sein, dass im gleichen Beispiel die Prop <code>className</code> verwendet wird. Wer jemals mit der DOM Element im Browser gearbeitet hat dem wird vielleicht im Gedächtnis geblieben sein, dass mittels <code>Element.className</code> auf das <code>class</code>-Attribute eines Elements zugegriffen werden kann. Ganz genau so ist das auch in React, das sich an den Eigenschaften der DOM <code>Element</code> Klasse bedient.</p>
<p>Möchte man gewisse HTML-Attribute in JSX setzen, ist dafür also die JavaScript-Entsprechung zu verwenden. <code>class</code> ist ein geschütztes Keyword in JavaScript um eine Klasse zu kennzeichnen, also verwenden wir an dieser Stelle stattdessen <code>className</code>. Gleiches gilt für <code>for</code>, was in JavaScript als Keyword benutzt wird um Schleifen einzuleiten, in HTML aber hingegen um <code>&lt;label&gt;</code> Elementen mitzuteilen, welches Eingabefeld sie beschreiben. Statt <code>for</code> schreiben wir in JSX also angelehnt an das DOM <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/htmlFor">HTMLLabelElement Interface</a> <code>htmlFor</code>:</p>
<pre><code class="hljs jsx language-jsx">&lt;fieldset&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"name"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">htmlFor</span>=<span class="hljs-string">"name"</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span></span></code></pre>
<p>Dieses Muster zieht sich konsequent durch alle bekannten HTML-Attribute. Möchtest du ein HTML-Attribut in JSX setzen, musst du dafür die Schreibweise der entsprechenden JavaScript DOM Element-Eigenschaft verwenden. So wird aus <code>tabindex</code> eben <code>tabIndex</code>, <code>readonly</code> wird zu <code>readOnly</code>, <code>maxlength</code> wird zu <code>maxLength</code>, usw.</p>
<p>Aber: Keine Angst! Im Development-Modus gibt React eine entsprechende Warnung in der Browser Console aus, so dass es dir selten passieren sollte, dass du entsprechenden fehlerhaften Code nicht bemerkst:</p>
<div class="hint hint--danger">
<p>Warning: Invalid DOM property <code>class</code>. Did you mean <code>className</code>?</p>
</div>
<p>Wer es genau wissen will, hier die vollständige Liste unterstützter HTML-Attribute wie sie in der offiziellen React-Doku steht (festhalten, wird lang):</p>
<blockquote>
  <p><code>accept acceptCharset accessKey action allowFullScreen alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge charSet checked cite classID className colSpan cols content contentEditable contextMenu controls controlsList coords crossOrigin data dateTime default defer dir disabled download draggable encType form formAction formEncType formMethod formNoValidate formTarget frameBorder headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media mediaGroup method min minLength multiple muted name noValidate nonce open optimum pattern placeholder poster preload profile radioGroup readOnly rel required reversed role rowSpan rows sandbox scope scoped scrolling seamless selected shape size sizes span spellCheck src srcDoc srcLang srcSet start step style summary tabIndex target title type useMap value width wmode wrap</code></p>
</blockquote>
<p>Das gleiche gilt übrigens auch für SVG-Elemente, die man ebenfalls innerhalb von JSX verwenden kann, da SVG valides XML ist! Die Liste der unterstützten SVG-Attribute ist aber gut und gerne 3 mal so lang und längst nicht so relevant im Alltag, weswegen ich dich in diesem Fall aber nun wirklich an die entsprechende Stelle in der offiziellen Doku verweisen muss: <a href="https://reactjs.org/docs/dom-elements.html#all-supported-html-attributes">https://reactjs.org/docs/dom-elements.html#all-supported-html-attributes</a></p>
<h2 id="sonderfall-inline-styles">Sonderfall Inline-Styles</h2>
<p>Natürlich gibt es auch Sonderfälle. Das style-Attribut ist ein solcher. Während Inline-Styles in HTML mit den originalen CSS-Eigenschaftsnamen und als String geschrieben werden, benutzt React, du ahnst es: JavaScript-Eigenschaften und außerdem ein Objekt statt eines einfachen Strings.</p>
<p>Schreibst du in herkömmlichem HTML:</p>
<pre><code class="hljs markup language-markup">&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">"margin-left: 12px; border-color: red; padding: 8px"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre>
<p>Sieht das Gegenstück in JSX so aus:</p>
<pre><code class="hljs jsx language-jsx">&lt;div style={{ <span class="hljs-attr">marginLeft</span>: <span class="hljs-string">'12px'</span>, <span class="hljs-attr">borderColor</span>: <span class="hljs-string">'red'</span>, <span class="hljs-attr">padding</span>: <span class="hljs-string">'8px'</span> }} /&gt;</code></pre>
<p>Ein weiterer Sonderfall sind Events. Da diese sehr umfangreich sind, widmen wir uns dem Thema später in einem eigenen Kapitel nochmal.</p>
<h2 id="kommentare-in-jsx">Kommentare in JSX</h2>
<p>Auch Kommentare sind möglich in JSX, funktionieren aber nicht wie in HTML in der Form:</p>
<pre><code class="hljs markup language-markup"><span class="hljs-comment">&lt;!-- Dies ist ein Beispiel für einen Kommentar --&gt;</span></code></pre>
<p>… sondern werden ebenfalls wie Ausdrücke in geschweifte Klammern gefasst, und dann in Form eines JavaScript Mehrzeilenkommentars geschrieben:</p>
<pre><code class="hljs jsx language-jsx">{
  <span class="hljs-comment">/* So sieht ein Kommentar in JSX aus */</span>
}</code></pre>
<p>Derartige Kommentare können sich natürlich auch über mehrere Zeilen erstrecken. Einzeilige JavaScript Kommentare die mit einem doppelten Slash (<code>//</code>) eingeleitet werden sind hingegen nicht möglich in JSX. Hier muss also auch bei einem kurzen einzeiligen Kommentar die <code>/* */</code> Syntax für mehrzeilige Kommentare verwendet werden.</p>
<p>Damit solltest du auch schon ausreichend Kenntnisse über JSX erlangt haben, um die nachfolgenden Beispiele und Beschreibungen mit weiteren Verlauf immer besser verstehen und nachvollziehen zu können</p>
<h2 id="fazit">Fazit</h2>
<div class="hint hint--info">
<ul>
<li>Mehrzeiliges JSX muss stets in Klammern gesetzt werden</li>
<li>JSX kann JavaScript-Ausdrücke verarbeiten. Diese müssen in geschweifte Klammern gesetzt werden und können dann auch in Props verwendet werden.</li>
<li>Um Attribute für HTML-Elemente zu setzen muss die Schreibweise des DOM Element Interface benutzt werden (<code>htmlFor</code> statt <code>for</code>, <code>className</code> statt <code>class</code>)</li>
<li>CSS Inline-Styles werden als JavaScript Object geschrieben</li>
<li>Kommentare werden ebenfalls in geschweifte Klammern gesetzt und verwenden Multiline-Comment Syntax: <code>{/* */}</code></li>
</ul>
</div>
</div>
<div class="chapter">
  <h1 id="rendering-von-elementen">Rendering von Elementen</h1>
<p>In einigen der vorherigen Kapitel habe ich sie wie selbstverständlich bereits einige Male erwähnt, doch was genau sind <strong>React Elemente</strong> eigentlich?</p>
<p><strong>React Elemente</strong> sind der kleinstmögliche Baustein in einer <strong>React Anwendung</strong>. Anhand der <strong>Elemente</strong> beschreibt ihr, was der Benutzer später auf dem Bildschirm zu sehen bekommt. Trotz ihres gleichen Namens unterscheiden sie sich von DOM-Elementen in einem wesentlichen Punkt: sie sind lediglich ein einfaches Objekt und damit auch günstig (im Sinne der Performance) zu erstellen. Die bloße Erstellung eines <strong>React Elements</strong> mittels <code>React.createElement()</code> löst noch keine DOM Operation aus!</p>
<div class="hint hint--warning">
<p>React <strong>Elemente</strong> werden oftmals mit React <strong>Komponenten</strong> durcheinander geworfen oder im Sprachgebrauch analog verwendet. Das ist aber nicht korrekt! <strong>Elemente</strong> sind das, aus was <strong>Komponenten</strong> letztendlich bestehen. <strong>Komponenten</strong> werden im nächsten Kapitel noch ausführlich behandelt, bevor es damit weitergeht, solltest du jedoch zuerst dieses Kapitel über <strong>Elemente</strong> gelesen haben.</p>
</div>
<p>Wir wissen bereits wie wir mittels <strong>JSX</strong> ein <strong>React Element</strong> erstellen und das <strong>JSX</strong> nur eine Vereinfachung ist, um uns viel Schreibarbeit und ständige <code>React.createElement()</code>-Aufrufe zu ersparen. Doch wie rendern wir ein erstelltes Element nun, also mit anderen Worten, zeigen wir es im Browser an?</p>
<p>Hier bedienen wir uns an <code>ReactDOM</code>, genauer gesagt dessen eigener <code>render()</code>-Methode. Um ein React Element zu rendern benötigen wir grundsätzlich eine <strong>Root-</strong> oder <strong>Mount-Node</strong>. Dies ist eine DOM-Node die sozusagen als Platzhalter dient und die React mitteilt, wohin ein Element gerendert werden soll. Theoretisch kannst du problemlos mehrere Root-Nodes in deinem HTML-Dokument haben. React kontrolliert diese alle unabhängig voneinander. Statt also nur einer großen React-Anwendung kannst du also auch auch viele kleine (oder auch große) Anwendungen in einem einzigen HTML-Dokument unterbringen. Üblich ist es aber normalerweise nur <strong>eine Root-Node</strong> für deine React-Anwendung zu haben.</p>
<p>Kommen wir also zum Wesentlichen: um ein React <strong>Element</strong> zu rendern übergibst du dieses als erstes Argument der <code>ReactDOM.render()</code>-Methode, zusammen mit der <strong>Root-Node</strong> als zweitem Argument, also der DOM-Node, in das dein <strong>Element</strong> gerendert werden soll.</p>
<p>Stellen wir uns einmal vor du hast ein <code>div</code> mit der ID <code>root</code>in deinem HTML-Dokument, das als <strong>Root-Node</strong> dienen soll:</p>
<pre><code class="hljs markup language-markup"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Der entsprechende Aufruf ist dann der folgende:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">var</span> myFirstElement = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Mein erstes React Element<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
ReactDOM.render(myFirstElement, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));</code></pre>
<p>Führst du diesen Code nun im Browser aus, siehst du <strong>innerhalb</strong> des <code>root</code>-divs nun dein <code>&lt;div&gt;Mein erstes React Element&lt;/div&gt;</code>.</p>
<p><strong>React Elemente</strong> sind dabei <strong>immutable</strong>, also unveränderlich. Dies bedeutet, ist ein Element einmal erstellt, repräsentiert es immer einen bestimmten Zustand („State“) im User Interface. Die offizielle React Dokumentation spricht hier metaphorisch von einem Einzelbild in einem Film. Möchten wir unser User Interface aktualisieren, müssen wir dazu ein neues <strong>React Element</strong> mit den veränderten Daten erstellen. Keine Angst, das klingt umständlicher als es ist und passiert später einmal ganz intuitiv.</p>
<p>React selbst ist dabei so klug, dass es durch einen Vergleichsalgorithmus nur die Teile einer Anwendung aktualisiert, die sich auch tatsächlich verändert haben. Dabei werden <strong>React Elemente</strong> und ihre Kind-Elemente mit ihren Vorgängerversionen vergleichen und lösen nur eine DOM-Operation aus wenn eine Änderung vorliegt. Dies führt dazu, dass React Anwendungen, richtig gemacht, sehr gute Rendering-Performance aufweisen, da DOM-Operationen in der Regel sehr kostspielig (also Performance lastig) sind, durch React und seinen <strong>Reconciliation</strong> genannten Prozess aber auf ein Minimum verringert werden. Dabei werden nicht immer grundsätzlich ganze DOM-Elemente neu erzeugt anhand der Beschreibung eines <strong>React-Elements</strong>, sondern es werden auch nur einzelne Attribute aktualisiert, sollte sich nur ein solches geändert haben.</p>
<p>Schauen wir uns das mal in der Praxis an:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showTime</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleTimeString();
  <span class="hljs-keyword">var</span> timeElement = (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Es ist jetzt {time} Uhr<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
  ReactDOM.render(timeElement, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));
}
setInterval(showTime, <span class="hljs-number">1000</span>);</code></pre>
<p>Wieder erstellen wir ein <strong>React-Element</strong>, diesmal soll es uns beim Aufruf von <code>ReactDOM.render()</code> die aktuelle Zeit ausgeben. Da wir stets die genaue Uhrzeit wissen wollen, stecken wir das Element und den <code>ReactDOM.render()</code> Aufruf in eine Funktion, die per <code>setInterval</code> alle 1000 ms aufgerufen wird.</p>
<p>Ein Blick in die <strong>Chrome Devtools</strong> offenbart: bei jedem <code>ReactDOM.render()</code>-Aufruf wird stets nur die Uhrzeit selbst aktualisiert, die restlichen Elemente, wie die DOM-Nodes oder auch nicht betroffene Teil des angezeigten Textes bleiben unangetastet:</p>
<p class="has-image"><span><img src="./assets/.gitbook/react-update.png" alt="React aktualisiert nur die Zeit selbst, nichts anderes." /><span class="caption">React aktualisiert nur die Zeit selbst, nichts anderes.</span></span></p>
<p>Und hier lernen wir zugleich auch eins der grundlegenden React Prinzipien in der Praxis kennen: das <strong>deklarative</strong> Vorgehen zur Erstellung von User Interfaces. Statt unserer Mini-App <strong>imperativ</strong> zu sagen, dass sie bitte sekündlich die Uhrzeit aktualisieren soll, definieren wir stattdessen <strong>deklarativ</strong> im <strong>React-Element</strong>, dass wir an einer gewissen Stelle jeweils stets bei jedem Re-Rendering die aktuelle Uhrzeit sehen möchten.</p>
<p>Eine ähnliche Funktionalität ohne React implementiert hätte stattdessen wohl in etwa so ausgesehen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeTime</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleTimeString();
  <span class="hljs-keyword">var</span> target = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>);
  target.textContent = <span class="hljs-string">'Es ist jetzt '</span> + time  <span class="hljs-string">' Uhr'</span>;
}
setInterval(changeTime, <span class="hljs-number">1000</span>);</code></pre>
<p>Der Vorteil beim deklarativen Vorgehen ist, dass wir nur noch <strong>Zustände beschreiben</strong> und sagen wie etwas angezeigt werden soll und nicht selber jeden Schritt festlegen wie wir diesen Zielzustand erreichen wollen. Das macht insbesondere bei komplexeren Anwendungen viele Dinge einfacher, übersichtlicher und ist dadurch zugleich deutlich weniger fehleranfälliger.</p>
<div class="hint hint--info">
<p>In der Praxis ist es eher üblich, dass <code>ReactDOM.render()</code> nur ein einziges Mal, meist beim Öffnen einer Seite aufgerufen wird. Der wiederholte Aufruf der <code>render()</code>-Methode dient hier nur zur Veranschaulichung wie <strong>ReactDOM</strong> und React <strong>Elemente</strong> zusammenspielen.</p>
<p>Das Re-Rendering übernehmen meist <strong>stateful Components</strong> (also Komponenten, die einen eigenen Zustand speichern). Mit Komponenten geht es im nächsten Kapitel weiter!</p>
</div>
</div>
<div class="chapter">
  <h1 id="komponenten-in-react">Komponenten in React</h1>
<h2 id="die-zwei-erscheinungsformen-von-react-components">Die zwei Erscheinungsformen von React Components</h2>
<p>Eine erste einfache <strong>HelloWorld</strong>-Komponente haben wir schon beim <a href="../einfuehrung/ab-ins-kalte-wasser.md">Sprung ins kalte Wasser</a> implementiert. Jedoch war dies natürlich bewusst eine sehr simple Komponente, die nicht gerade sehr praxisnah war und auch längst nicht alles beinhaltet hat was uns React bietet. Aber sie diente als gute erste Veranschaulichung, um die grundsätzliche Funktionsweise von von <strong>React</strong> und <strong>React-Komponenten</strong> kennenzulernen.</p>
<p>Das Prinzip von <strong>Komponenten</strong> ist einfach erklärt: eine <strong>Komponente</strong> erlaubt es komplexe User Interfaces in einzelne kleine Stücke zu unterteilen. Diese sind im Idealfall wiederverwendbar, isoliert und in sich geschlossen. Sie verarbeiten beliebigen Input von außen in Form von sogenannter <strong>Props</strong> (engl. für „Properties“, also Eigenschaften) und beschreiben letztendlich anhand ihrer <code>render()</code>-Funktion was auf dem Bildschirm erscheint.</p>
<p>Komponenten können grob in zwei verschiedenen Varianten auftreten: in Form einer einfachen Funktion (engl. <strong>Function Component</strong>), sowie <strong>Class Components</strong>, die eine gewöhnliche ES2015-Klasse repräsentieren.<br />
Bis zur Einführung der React <strong>Hooks</strong> war es in <strong>Function Components</strong> nicht möglich einen lokalen State zu verwalten, weswegen man in diesem Buch hin und wieder möglicherweise noch auf den Begriff <strong>Stateless Functional Component</strong> stößen könnte. (Ich arbeite bereits daran alle betreffenden Stellen entsprechend umzuschreiben ;))</p>
<h3 id="function-components">Function Components</h3>
<p>Die deutlich einfachste Art um in React eine Komponente zu definieren ist sicherlich die <strong>Function Component</strong>, die, wie der Name es bereits andeutet, tatsächlich lediglich eine gewöhnliche JavaScript-Funktion ist:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Hello</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello {props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}</code></pre>
<p>Diese Funktion erfüllt alle Kriterien einer gültigen <strong>React-Komponente</strong>: sie hat als <code>return</code>-Wert ein explizites <code>null</code> (<code>undefined</code> ist dagegen <strong>nicht</strong> gültig!) oder ein gültiges <code>React.Element</code> (hier in Form von <strong>JSX</strong>) und sie empfängt ein <code>props</code>-Objekt als erstes und Funktionsargument, wobei sogar dieses optional ist und ebenfalls <code>null</code> sein kann.</p>
<h3 id="class-components">Class Components</h3>
<p>Die zweite Möglichkeit wie eine <strong>React-Komponente</strong> erstellt werden kann habe ich im Eingangsbeispiel schon kurz gezeigt: <strong>Class Components</strong>. Diese bestehen aus einer ES2015-Klasse, die von der <code>React.Component</code> oder <code>React.PureComponent</code>(dazu später mehr) Klasse ableitet und hat mindestens eine Methode mit dem Namen <code>render()</code>:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello {this.props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
  }
}</code></pre>
<p>Wichtiger Unterschied hier: während eine <strong>Function Component</strong> ihre <strong>Props</strong> als Funktionsargumente übergeben bekommt, bekommt die <code>render()</code>-Methode einer <strong>Klassen-Komponente</strong> selbst keinerlei Argumente übergeben, sondern es kann einzig über die Instanz-Eigenschaft <code>this.props</code> auf die <strong>Props</strong> zugegriffen!</p>
<p>Die beiden obigen Komponenten resultieren hier in einer komplett identischen Ausgabe!</p>
<div class="hint hint--info">
<p>Ein Kriterium das beide Arten von Komponenten gemeinsam haben ist, dass der <code>displayName</code>, also der Name einer gültigen Komponente stets mit einem <strong>Großbuchstaben</strong> anfängt. Der Rest des Namens kann aus Großbuchstaben oder Kleinbuchstaben bestehen, wichtig ist lediglich, dass der erste Buchstabe stets ein Großbuchstabe ist!</p>
<p>Beginnt der Name einer Komponente mit einem Kleinbuchstaben, behandelt React diese stattdessen als reines DOM-Element. <code>section</code> würde React also als DOM-Element interpretieren, während eine eigene Komponente durchaus den Namen <code>Section</code> haben kann und wegen ihres Großbuchstabens am Anfang von React korrekt vom <code>section</code> DOM-Element unterschieden werden würde.</p>
</div>
<p>Wie wir innerhalb der <strong>Komponenten</strong> jeweils mit dem <strong>State</strong> arbeiten, diesen modifizieren und uns zu eigen machen ist sehr komplex, weswegen dem Thema ein eigenes Kapitel gewidmet ist. Dieses folgt direkt im Anschluss an dieses hier und ich würde empfehlen erst dieses Kapitel zu beenden um die Funktionsweise von Komponenten zu verstehen, bevor wir hier tiefer einsteigen.</p>
<h3 id="sonderfall-purecomponent">Sonderfall PureComponent</h3>
<p>Eine Sonderform der <strong>Class Component</strong> stellt die <strong>Pure Component</strong> dar. Diese erbt von <code>React.PureComponent</code> und funktioniert vom Grundsatz her wie die gewöhnliche Class Component, die von <code>React.Component</code> abgeleitet wird. Mit dem Unterschied, dass React diese Art der Komponente nur dann neu rendert wenn sich ihre <strong>Props</strong> oder ihr <strong>State</strong> im Vergleich zur vorherigen Render-Phase geändert haben.</p>
<p>Die Klasse führt dazu einen oberflächlichen (<em>„shallow“</em>) Vergleich durch, schaut also lediglich ob die Referenzen noch identisch zum vorherigen Rendering sind und <strong>nicht</strong>, ob sich die Werte selbst geändert haben. Dies bedeutet, dass eine PureComponent ggf. auch dann neu rendert wenn die Werte zwar identisch sind, sich die Referenzen jedoch geändert haben, etwa weil eine neue Arrow-Function erzeugt wurde.</p>
<p>Am besten lässt sich dies an einem kurzen Beispiel erklären:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> logFunction = <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(message);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">logger</span>=<span class="hljs-string">{changeHandler}</span> /&gt;</span>;
  }
}</span></code></pre>
<p>Hier definieren wir eine Funktion <code>logFunction</code> außerhalb der Klasse. Die fiktive <code>MyComponent</code>-Komponente bekommt als <code>logger</code>-Prop hier die <strong>Referenz</strong> zur <code>logFunction</code> übergeben. Die <strong>Identität</strong> der Referenz bleibt hier bei jedem erneuten Rendering bestehen und eine PureComponent würde nicht erneut gerendert sofern sich ihr eigener State nicht geändert hat, da die Props hier in der Rendering-Phase die selben sind wie in der vorherigen.</p>
<p>Im folgenden Beispiel hingegen, würde auch die PureComponent neu gerendert:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">logger</span>=<span class="hljs-string">{(message)</span> =&gt;</span> console.log(message)} /&gt;;
  }
}</span></code></pre>
<p>Zwar übergeben wir auch hier stets eine immer gleiche Funktion an die <code>MyComponent</code>, allerdings erzeugen wir für den Interpreter bei jedem neuen Rendering auch eine neue Funktion. Dadurch geht der Bezug zur alten Funktion verloren und die <em>Shallow-Comparison</em>, also der oberflächliche Vergleich zwischen den vorherigen und den neuen Props schlägt fehl, ist also unterschiedlich und löst damit ein Rerendering aus.</p>
<p>Dies gilt gleichermaßen auch für Objekte und Arrays:</p>
<pre><code class="hljs jsx language-jsx">&lt;MyComponent
  logConfig={{ <span class="hljs-attr">logLevel</span>: <span class="hljs-string">'info'</span> }}
  logEntries={[<span class="hljs-string">'Nachricht 1'</span>, <span class="hljs-string">'Nachricht 2'</span>]}
/&gt;</code></pre>
<p>Hier würde ein Rendering ausgelöst, weil auch das <code>logConfig</code>-Objekt bzw. das <code>logEntries</code>-Array bei jedem erneuten Rendering an Ort und Stelle neu erzeugt werden würde.</p>
<h3 id="„pure“-function-components">„Pure“ Function Components</h3>
<p><strong>Class Components</strong> leiten von den Klassen <code>Component</code> oder <code>PureComponent</code> ab und wir bestimmen durch die Auswahl von welcher Klassen wir ableiten, ob die Komponente mit jeder Änderung einer sich in der Hierarchie höher befindlichen Komponente neu gerendert werden soll. Diese Möglichkeit haben wir bei einfachen Funktionen nicht. Seit <strong>React 16.6.0</strong> bietet React jedoch durch die neue Wrapper-Funktion <code>React.memo()</code> auch in <strong>Function Components</strong> die Möglichkeit der Rerendering-Optimierung. Dazu wird diese einfach um die entsprechende Funktion gelegt:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> MyComponent = React.memo(<span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Ich werde nur neu gerendert wenn sich meine Props ändern<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
});</code></pre>
<p>Die <strong>Function Component</strong> verhält sich dann so wie eine vergleichbare <strong>Class Component</strong>, die von der <code>React.PureComponent</code> Klasse abgeleitet wird.</p>
<p>Wer neugierig geworden ist, kann sich für das einfachere Verständnis auch mit der folgenden Demo etwas austoben:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Class Component: {new Date().toISOString()}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PureClassComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">PureComponent</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Pure Class Component: {new Date().toISOString()}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
  }
}

<span class="hljs-keyword">const</span> FunctionComponent = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Function Component: {new Date().toISOString()}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
};

<span class="hljs-keyword">const</span> MemoizedFunctionComponent = React.memo(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Memoized Function Component: {new Date().toISOString()}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
});

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">lastRender</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString(),
  };

  componentDidMount() {
    <span class="hljs-keyword">this</span>.interval = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">lastRender</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString() });
    }, <span class="hljs-number">200</span>);
  }

  componentWillUnmount() {
    clearInterval(<span class="hljs-keyword">this</span>.interval);
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>App: {this.state.lastRender}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ClassComponent</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">PureClassComponent</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">FunctionComponent</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">MemoizedFunctionComponent</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Hier löst die <code>App</code>-Komponente alle 0,2 Sekunden automatisch ein Rerendering aus, ohne das dabei jedoch <strong>Props</strong> an ihre Kind-Komponenten übergeben werden. Preisfrage: welche beiden Komponenten werden dabei jeweils mit neu gerendert und welche beiden nicht?</p>
<h2 id="component-composition-–-mehrere-komponenten-in-einer">Component Composition – mehrere Komponenten in einer</h2>
<p>Bisher haben unsere Beispiel-Komponenten jeweils nur DOM-Elemente ausgegeben. <strong>React-Komponenten</strong> können aber auch andere React-Komponenten beinhalten. Wichtig hierbei ist nur, dass die Komponente sich im selben Scope befindet, also entweder direkt im gleichen Scope definiert wurde oder bei der Verwendung von CommonJS- oder ES-Modules ins aktuelle File importiert wurden mittels <code>require()</code> oder <code>import</code>.</p>
<p><strong>Ein Beispiel:</strong></p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Hello</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hallo {props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyApp</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;Hello name="Manuel" /&gt;
      &lt;Hello name="Tom" /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(&lt;MyApp /&gt;, document.getElementById('app'));</code></pre>
<p>Die Komponente <code>&lt;MyApp&gt;</code> gibt hier ein <code>&lt;div&gt;</code> zurück, das zweimal die Hello-Komponente aus dem vorherigen Beispiel benutzt um Manuel und Tom zu begrüßen. Das Resultat:</p>
<pre><code class="hljs jsx language-jsx">&lt;div&gt;
  &lt;div&gt;Hallo Manuel&lt;/div&gt;
  &lt;div&gt;Hallo Tom&lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>Wichtig: eine Komponente darf stets nur ein einzelnes Root-Element zurückgeben! Dies kann sein:</p>
<ul>
<li>ein einzelnes React-Element:</li>
</ul>
<pre><code class="hljs jsx language-jsx">&lt;Hello name=<span class="hljs-string">"Manuel /&gt;</span></code></pre>
<ul>
<li>Auch in verschachtelter Form, solange es nur ein einzelnes Element auf äußerer Ebene gibt:</li>
</ul>
<pre><code class="hljs jsx language-jsx">&lt;Parent&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Parent</span>&gt;</span></span></code></pre>
<ul>
<li>ein DOM-Element (auch dieses darf wiederum verschachtelt sein und andere Elemente beinhalten):</li>
</ul>
<pre><code class="hljs jsx language-jsx">&lt;div&gt;…&lt;<span class="hljs-regexp">/div&gt;</span></code></pre>
<ul>
<li>… oder selbstschließend:</li>
</ul>
<pre><code class="hljs jsx language-jsx">&lt;img src=<span class="hljs-string">"logo.jpg"</span> alt=<span class="hljs-string">"Bild: Logo"</span> /&gt;</code></pre>
<ul>
<li>Oder auch</li>
</ul>
<pre><code class="hljs javascript language-javascript"><span class="hljs-literal">null</span>;</code></pre>
<p>… jedoch <strong>nicht</strong> <code>undefined</code>!</p>
<p>Seit <strong>React 16.0.0</strong> dürfen das außerdem auch sein:</p>
<ul>
<li>ein Array welches wiederum gültige return-Werte (s.o.) beinhaltet:</li>
</ul>
<pre><code class="hljs jsx language-jsx">[<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"1"</span>&gt;</span>Hallo<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>, &lt;Hello key=<span class="hljs-string">"2"</span> name=<span class="hljs-string">"Manuel"</span> /&gt;];</code></pre>
<ul>
<li>ein simpler String:</li>
</ul>
<pre><code class="hljs javascript language-javascript"><span class="hljs-string">'Hallo Welt'</span>;</code></pre>
<ul>
<li>oder ein sogenanntes „Fragment“ – eine Art spezielle „Komponente“, das selbst nicht im gerenderten Output auftaucht und als Container dienen kann, falls man andererseits gegen die Regel verstoßen würde nur ein Root-Element aus der Funktion zurückzugeben oder invalides HTML erzeugen würde:</li>
</ul>
<pre><code class="hljs jsx language-jsx">&lt;React.Fragment&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
  &lt;li&gt;3&lt;/li&gt;
&lt;/React.Fragment&gt;</code></pre>
<p>Beim Transpiling mit Babel ab Version 7 kann außerdem die Fragment-Kurzform benutzt werden die aus einem leeren öffnenden und schließenden Element besteht:</p>
<pre><code class="hljs jsx language-jsx">&lt;&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
  &lt;li&gt;3&lt;/li&gt;
&lt;/&gt;</code></pre>
<p>Komponenten können dabei beliebig zusammengesetzt (<em>„composed“</em>) werden. So bietet es sich oftmals an große und komplexe Komponenten in einzelne, kleinere und übersichtlichere Komponenten zu unterteilen um diese leichter verständlich und optimalerweise sogar auch wiederverwendbar zu machen. Dies ist oftmals ein lebender Prozess bei dem man ab einem gewissen Punkt bemerkt, dass eine Unterteilung in mehrere einzelne Komponenten möglicherweise sinnvoll wäre.</p>
<h2 id="komponenten-aufteilen-–-übersicht-bewahren">Komponenten aufteilen – Übersicht bewahren</h2>
<p>Werfen wir doch mal einen Blick auf eine beispielhafte Kopfleiste, die ein Logo, eine Navigation und eine Suchleiste enthält. Kein ganz unübliches Muster also schaut man sich Web-Anwendungen an:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Header</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    &lt;header&gt;
      &lt;div className="logo"&gt;
        &lt;img src="logo.jpg" alt="Image: Logo" /&gt;
      &lt;/div&gt;
      &lt;ul className="navigation"&gt;
        &lt;li&gt;
          &lt;a href="/"&gt;Homepage&lt;/a&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;a href="/team"&gt;Team&lt;/a&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;a href="/services"&gt;Services&lt;/a&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;a href="/contact"&gt;Contact&lt;/a&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;div className="searchbar"&gt;
        &lt;form method="post" action="/search"&gt;
          &lt;p&gt;
            &lt;label htmlFor="q"&gt;Suche:&lt;/label&gt;
            &lt;input type="text" id="q" name="q" /&gt;
          &lt;/p&gt;
          &lt;input type="submit" value="Suchen" /&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    &lt;/header&gt;
  );
}</code></pre>
<p>Wir wissen bereits, dass Komponenten in React problemlos auch andere Komponenten beinhalten können und das diese Komponenten-basierte Arbeitsweise auch der Idee und dem Mindset von React entspricht. Was bietet sich hier also an? Richtig: wir teilen unsere doch bereits relativ große, unübersichtliche Komponente in mehrere kleinere Häppchen auf, die jeweils alle nur einen einzigen, ganz bestimmten Zweck erfüllen.</p>
<p>Da wäre das Logo, das wir sicherlich an anderer Stelle nochmal verwenden können. Die Navigation kann möglicherweise neben dem Header auch nochmal in einer Sitemap eingesetzt werden. Auch die Suchleiste soll vielleicht irgendwann mal nicht mehr nur im Header zum Einsatz kommen, sondern vielleicht auch auf der Suchergebnisseite selbst.</p>
<p>In Komponenten gesprochen, landen wir dann bei folgendem Endresultat:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Logo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    &lt;div className="logo"&gt;
      &lt;img src="logo.jpg" alt="Image: Logo" /&gt;
    &lt;/div&gt;
  );
}

function Navigation() {
  return (
    &lt;ul className="navigation"&gt;
      &lt;li&gt;
        &lt;a href="/"&gt;Homepage&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href="/team"&gt;Team&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href="/services"&gt;Services&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href="/contact"&gt;Contact&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  );
}

function Searchbar() {
  return (
    &lt;div className="searchbar"&gt;
      &lt;form method="post" action="/search"&gt;
        &lt;p&gt;
          &lt;label htmlFor="q"&gt;Suche:&lt;/label&gt;
          &lt;input type="text" id="q" name="q" /&gt;
        &lt;/p&gt;
        &lt;input type="submit" value="Suchen" /&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}

function Header() {
  return (
    &lt;header&gt;
      &lt;Logo /&gt;
      &lt;Navigation /&gt;
      &lt;Searchbar /&gt;
    &lt;/header&gt;
  );
}</code></pre>
<p>Auch wenn der Code jetzt erstmal länger geworden ist haben wir uns dadurch dennoch einige große Vorteile geschaffen.</p>
<h3 id="leichtere-kollaboration">Leichtere Kollaboration</h3>
<p>Alle Komponenten können (und sollten!) in einem eigenen File gespeichert werden, was die Arbeit im Team immens erleichtert. So könnte jedes Team-Mitglied oder auch einzelne Teams innerhalb eines großen Projekt-Teams für eine oder mehrere Komponenten hauptverantwortlich sein („Ownership übernehmen“) und Änderungen in diesen vornehmen, während das Risiko die Änderungen eines Kollegen zu überschreiben oder später Git Merge-Konflikte auflösen zu müssen immens sinkt. Teams werden zu <em>Konsumenten</em> von Komponenten anderer Teams, die anhand eventuell verfügbarer Props ein simples Interface für ihre Komponente bereitstellen.</p>
<h3 id="single-responsibility-prinzip">Single Responsibility Prinzip</h3>
<p>Wir haben nun außerdem „sprechende“ Komponenten, von denen jede eine klar definierte Aufgabe hat, die direkt anhand ihres Namens ersichtlich wird. Das Logo zeigt mir überall wo es verwendet wird dasselbe Logo an. Möchte ich später eine Änderung an der Suchleiste vornehmen, suche ich gezielt nach der Searchbar.js und ändere diese entsprechend meinen neuen Anforderungen. Die Header-Komponente dient als übergeordnete Komponente die selbst dafür verantwortlich ist, alle ihre Bestandteile zu beinhalten und diese überall hin mitzubringen, wo sie eingesetzt wird.</p>
<h3 id="wiederverwendbarkeit">Wiederverwendbarkeit</h3>
<p>Und nicht zuletzt haben wir ganz nebenbei noch Wiederverwendbarkeit geschaffen. Möchte ich wie erwähnt das Logo nicht nur im Header sondern auch im Footer verwenden hält mich natürlich nichts davon ab, dieselbe Komponente auch in meiner Footer-Komponente zu verwenden. Habe ich verschiedene Seitenbereiche mit unterschiedlichen Layouts, die jedoch alle denselben Header darstellen, kann ich dazu meine schlanke und übersichtliche Header-Komponente überall dort verwenden, wo ich ich ihn benötige. Der Konsument einer Komponente muss dazu nicht einmal wissen aus welchen einzelnen Komponenten sie besteht. Es reicht, lediglich die gewünschte Komponente zu importieren da diese sich selbst um ihre Abhängigkeiten kümmert.</p>
<h2 id="props-–-die-„datenempfänger“-einer-komponente">Props – die „Datenempfänger“ einer Komponente</h2>
<p>Nun habe ich bereits soviel über <strong>Props</strong> geschrieben. Höchste Zeit also einmal das Geheimnis zu lüften und genauer darauf einzugehen. Was sind also „Props“?</p>
<p>Durch die <strong>Props</strong> nehmen Komponenten beliebige Arten von Daten entgegen und können innerhalb der <strong>Komponente</strong> auf diese Daten zugreifen. Denken wir an unsere <strong>funktionale Komponente</strong> zurück, erinnern wir uns vielleicht, dass in diesem Fall die <strong>Props</strong> tatsächlich als ganz gewöhnliches Argument an die Funktion übergeben wurden. Ähnlich ist das Prinzip bei einer <strong>Class Component</strong>, mit dem Unterschied, dass die <strong>Props</strong> über den Constructor der Klasse in die Komponente hereingereicht werden und über <code>this.props</code> innerhalb der Klassen-Instanz verfügbar sind, statt über ein Funktionsargument, wie das bei funktionalen Komponenten der Fall ist.</p>
<p>Wichtig dabei ist: wann immer eine Komponente von außen neue <strong>Props</strong> hereingereicht bekommt, löst dies ein Re-Rendering der Komponente aus! Dieses Verhalten kann mittels der <code>shouldComponentUpdate()</code> <strong>Lifecycle-Methode</strong> explizit unterbunden werden, doch dazu gibt es im nachfolgenden Kapitel mehr. Wichtig ist erst einmal der allgemeine Grundsatz: empfängt eine <strong>Komponente</strong> von außen neue <strong>Props</strong>, veranlasst dies React dazu eine <strong>Komponente</strong> mitsamt ihrer Kind-Komponenten neu zu rendern.</p>
<h3 id="props-sind-readonly-innerhalb-einer-komponente">Props sind readonly innerhalb einer Komponente</h3>
<p>Unabhängig davon wie die Props in welcher Art von Komponente auch immer landen, eines ist ihnen gemeinsam: sie sind innerhalb der Komponente <strong>immer readonly</strong>, dürfen (und können) also nur gelesen, nicht aber modifiziert werden! Der Profi spricht hier auch von <strong>Immutability</strong> oder <strong>Immutable Objects</strong>. Um mit veränderlichen Daten zu arbeiten kommt später der React <strong>State</strong> ins Spiel. Aber eins nach dem anderen.</p>
<p>Modifiziert eine Funktion ihren Input nicht und hat auch keine Abhängigkeit nach außen, so spricht man in der funktionalen Programmierung von einer puren Funktion (engl.: <strong>Pure Function</strong>) und die Idee dahinter ist recht simpel: so soll sichergestellt werden, dass eine Funktion in sich geschlossen ist, daher davon unbeeindruckt bleibt wenn sich außerhalb der Funktion etwas ändert, die Funktion bekommt alle benötigten Parameter hereingereicht, ist frei von Seiteneffekten (engl.: <strong>Side Effects</strong>) und erzielt somit bei gleichen Eingabewerten auch immer die exakt identische Ausgabe. <strong>Gleicher Input, gleicher Output!</strong></p>
<p>Mit anderen Worten: egal welche Variablen außerhalb der Funktion ihren Wert ändern, egal wie oft andere Funktionen anderswo aufgerufen werden: bekommt eine Pure Function die gleichen Parameter wie zuvor, gibt sie mir auch das gleiche Ergebnis wie zuvor zurück. Immer und ausnahmslos.</p>
<p>Warum ist das wichtig? Nun, React verfolgt bei seinen Komponenten das Prinzip von <strong>Pure Functions</strong>. Erhält eine Komponente die gleichen Props von außen hineingereicht, ist der initiale Output auch immer identisch.</p>
<h3 id="pure-functions-im-detail">Pure Functions im Detail</h3>
<p>Da das Prinzip von <strong>Pure Functions</strong> ein grundlegendes ist bei der Arbeit mit React möchte ich diese Anhand einiger Beispiele etwas näher beleuchten. Hier geht es überwiegend um Theorie, die sich sicherlich komplizierter anhört als das später bei der praktischen Arbeit mit React der Fall sein wird. Dennoch möchte ich diese zum besseren Verständnis nicht unerwähnt lassen.</p>
<h4 id="beispiel-für-eine-simple-pure-function">Beispiel für eine simple Pure Function</h4>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pureDouble</span>(<span class="hljs-params">number</span>) </span>{
  <span class="hljs-keyword">return</span> number * <span class="hljs-number">2</span>;
}</code></pre>
<p>Unsere erste simple Funktion bekommt eine Nummer übergeben, verdoppelt diese und gibt das Ergebnis zurück. Egal ob ich die Funktion 1, 10 oder 250 mal aufrufe: übergebe ich der Funktion bspw. eine <code>5</code> als Wert, erhalte ich eine <code>10</code> zurück. Immer und ausnahmslos. Same input, same output.</p>
<h4 id="beispiel-für-eine-impure-function">Beispiel für eine Impure Function</h4>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">impureCalculation</span>(<span class="hljs-params">number</span>) </span>{
  <span class="hljs-keyword">return</span> number + <span class="hljs-built_in">window</span>.outerWidth;
}</code></pre>
<p>Die zweite Funktion ist nicht mehr pure, weil sie nicht zuverlässig immer den gleichen Output liefert, selbst wenn ihr Input identisch ist. Momentan ist mein Browser-Fenster 1920 Pixel breit. Rufe ich die Funktion mit <code>10</code> als Argument auf, erhalte ich <code>1930</code> zurück (<code>10 + 1920</code>). Verkleinere ich nun das Fenster auf 1280 Pixel und rufe die Funktion erneut, mit exakt der gleichen <code>10</code> als Argument auf bekomme ich dennoch ein anderes Ergebnis (<code>1290</code>) als beim ersten Mal. Es handelt sich also nicht um eine Pure Function.</p>
<p>Eine Möglichkeit diese Funktion „pure“ zu machen wäre, ihr meine Fensterbreite als weiteres Funktionsargument zu übergeben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pureCalculation</span>(<span class="hljs-params">number, outerWidth</span>) </span>{
  <span class="hljs-keyword">return</span> number + outerWidth;
}</code></pre>
<p>So liefert die Funktion beim Aufruf von pureCalculation(10, window.outerWidth) zwar immer noch ein Ergebnis was von meiner Fensterbreite abhängt, die Funktion ist dennoch „pure“ da sie beim gleichen Input weiterhin den gleichen Output liefert. Einfacher kann man das nachvollziehen wenn man die Funktion mal auf ihre wesentlichen Eigenschaften reduziert:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pureSum</span>(<span class="hljs-params">number1, number2</span>) </span>{
  <span class="hljs-keyword">return</span> number1 + number2;
}</code></pre>
<p><strong>Gleicher Input, Gleicher Output.</strong></p>
<h4 id="weiteres-beispiel-für-eine-impure-function">Weiteres Beispiel für eine Impure Function</h4>
<p>Stellen wir uns einmal vor wir möchten eine Funktion implementieren die als Input ein Objekt empfängt mit Parametern zu einem Auto.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">var</span> car = { <span class="hljs-attr">speed</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">seats</span>: <span class="hljs-number">5</span> };
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accelerate</span>(<span class="hljs-params">car</span>) </span>{
  car.speed += <span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> car;
}</code></pre>
<p>Das obige Beispiel ist ebenfalls eine Funktion die nicht „pure“ ist, da sie ihren Eingabewert modifiziert und somit beim zweiten Aufruf bereits ein anderes Ergebnis als Ausgabewert hat als noch beim ersten Aufruf:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-built_in">console</span>.log(accelerate(car)) &gt; { <span class="hljs-attr">speed</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">seats</span>: <span class="hljs-number">5</span> };

<span class="hljs-built_in">console</span>.log(accelerate(car)) &gt; { <span class="hljs-attr">speed</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">seats</span>: <span class="hljs-number">5</span> };</code></pre>
<p>Wie sorgen wir also nun dafür, dass auch unser letztes Beispiel „pure“ wird? Indem wir den Eingabewert nicht mehr modifizieren und stattdessen jedes Mal ein neues Objekt erzeugen, basierend auf dem Eingabewert, und dieses neue Objekt aus der Funktion zurückgebend,</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">var</span> car = { <span class="hljs-attr">speed</span>: <span class="hljs-number">0</span> };
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accelerate</span>(<span class="hljs-params">car</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">speed</span>: car.speed + <span class="hljs-number">1</span>,
  };
}</code></pre>
<p>Neues Ergebnis:</p>
<pre><code class="hljs text language-text"><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">accelerate</span>(<span class="hljs-selector-tag">car</span>))
&gt; {<span class="hljs-attribute">speed</span>: <span class="hljs-number">1</span>}

<span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">accelerate</span>(<span class="hljs-selector-tag">car</span>))
&gt; {<span class="hljs-attribute">speed</span>: <span class="hljs-number">1</span>}</code></pre>
<p><strong>Gleicher Input: gleicher Output:</strong> wir sind „pure“!</p>
<p>Ihr wundert euch jetzt vielleicht warum ich euch das erzähle und hier mit langweiliger Theorie nerve, wo ihr doch eigentlich nur React lernen wollt (jedenfalls würde ich mir das an dieser Stelle denken, wenn ich mir vorstelle dieses Buch auch aus diesem Grund zu lesen).</p>
<p>React ist eine sehr liberale Library, die dem Entwickler sehr viele Freiheiten lässt. Aber eine Sache ist oberstes Gebot und da kennt React auch wirklich keinen Spaß: <strong>Komponenten müssen sich im Hinblick auf ihre Props wie „Pure Functions“ verhalten und bei gleichen Props stets die gleiche Ausgabe erzeugen!</strong></p>
<p>Haltet ihr euch da nicht dran, kann es bei der Arbeit mit React zu sehr eigenartigen Effekten kommen, zu unerwünschten und nicht nachvollziehbaren Ergebnissen führen und euch das Leben beim Bugfixing zur Hölle machen. Und genau aus diesem Grund lernt ihr ja React: weil ihr ein einfaches aber dennoch zugleich unglaublich mächtiges Tool haben wollt, mit denen ihr nach etwas Einarbeitung in unglaublich schneller Zeit wirklich professionelle User Interfaces entwickeln könnt, ohne euch dabei selbst in den Wahnsinn zu treiben. All das bietet euch React, solange ihr euch an diese Regel haltet.</p>
<p>Das hat für uns aber gleichzeitig den sehr angenehmen Nebeneffekt, dass sich Komponenten in der Regel auch sehr einfach testen lassen.</p>
<p>So und was bedeutet jetzt genau das <em>„readonly innerhalb einer Komponente“</em>? Das ist mit unserem neuen Wissen über „Pure Functions“ recht schnell erklärt: egal wie ich in der Komponente auf die Props zugreife, ob direkt über das <code>props</code>-Argument einer SFC (<em>„Stateless Functional Component“</em>), über den <code>constructor()</code> in einer Class-Component oder an beliebiger anderer Stelle innerhalb einer Class-Component mittels <code>this.props</code>: ich kann und darf (und will!) den Wert der hereingereichten Props nicht ändern.</p>
<p>Anders sieht das natürlich <strong>außerhalb</strong> aus. Hier kann ich den Wert problemlos ändern (vorausgesetzt natürlich, wir befinden uns nicht wiederum in einer Komponente, welche die Prop die wir modifizieren wollen selbst nur hereingereicht bekommen hat).</p>
<h4 id="was-nicht-möglich-ist">Was nicht möglich ist</h4>
<pre><code class="hljs jsx language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params">props</span>) </span>{
  props.number = props.number + <span class="hljs-number">1</span>;
  props.fullName = [props.firstName, props.lastName].join(<span class="hljs-string">' '</span>);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      ({props.number}) {props.fullName}{' '}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Example</span> <span class="hljs-attr">number</span>=<span class="hljs-string">{5}</span> <span class="hljs-attr">firstName</span>=<span class="hljs-string">"Manuel"</span> <span class="hljs-attr">lastName</span>=<span class="hljs-string">"Bieh"</span> /&gt;</span>,
  document.getElementById('app')
);</span></code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--danger">
<p>TypeError: Cannot add property number, object is not extensible</p>
</div>
<p>Hier versuche ich direkt die <code>number</code> und <code>fullName</code> Props innerhalb meiner Example-Komponente zu ändern, was natürlich nicht funktionieren kann, da wir ja gelernt haben, dass Props grundsätzlich readonly sind.</p>
<h4 id="was-allerdings-möglich-ist">Was allerdings möglich ist</h4>
<p>Manchmal möchte ich aber eben doch einen neuen Wert von einer hereingereichten Prop ableiten. Das ist auch gar kein Problem, React 17 bietet dafür sogar noch eine umfassende Funktion <code>getDerivedStateFromProps()</code>, auf die ich im entsprechenden Kapital nochmal gesondert und sehr detailliert eingehen werde.</p>
<p>Möchte ich aber eben nur mal eben einen Wert anzeigen der sich von der Prop ableitet, die ich als Komponente hereingereicht bekomme, geht das indem nur die Ausgabe auf Basis der Prop anpasse ohne zu probieren den Wert zurück zu schreiben.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">var</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react'</span>);
<span class="hljs-keyword">var</span> ReactDOM = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-dom'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      ({props.number + 1}) {[props.firstName, props.lastName].join(' ')}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Example</span> <span class="hljs-attr">number</span>=<span class="hljs-string">{5}</span> <span class="hljs-attr">firstName</span>=<span class="hljs-string">"Manuel"</span> <span class="hljs-attr">lastName</span>=<span class="hljs-string">"Bieh"</span> /&gt;</span>,
  document.getElementById('app')
);</span></code></pre>
<p><strong>Ausgabe:</strong></p>
<pre><code class="hljs jsx language-jsx">&lt;div&gt;(<span class="hljs-number">6</span>) Manuel Bieh&lt;<span class="hljs-regexp">/div&gt;</span></code></pre>
<p>In diesem Fall modifiziere ich also lediglich die Ausgabe basierend auf den <code>props</code>, nicht jedoch das <code>props</code>-Objekt selbst. Das ist überhaupt kein Problem.</p>
<h4 id="was-ebenfalls-möglich-ist">Was ebenfalls möglich ist</h4>
<p>Jetzt bleibt noch abschließend zu klären wie Props denn nun außerhalb einer Komponente geändert werden können, denn bisher war immer nur die Rede davon, dass Props nur innerhalb einer Komponente nicht verändert werden dürfen.</p>
<p>Auch das lässt sich am Besten anhand eines konkreten, allerdings noch recht abstrakten Beispiels erklären:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">var</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react'</span>);
<span class="hljs-keyword">var</span> ReactDOM = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-dom'</span>);

<span class="hljs-keyword">var</span> renderCounter = <span class="hljs-number">0</span>;
setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  renderCounter++;
  renderApp();
}, <span class="hljs-number">2000</span>);

<span class="hljs-keyword">const</span> App = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{props.renderCounter}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderApp</span>(<span class="hljs-params"></span>) </span>{
  ReactDOM.render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> <span class="hljs-attr">renderCounter</span>=<span class="hljs-string">{renderCounter}</span> /&gt;</span>,
    document.getElementById('app')
  );
}

renderApp();</span></code></pre>
<p>Was passiert hier? Zunächst einmal setzen wir eine Variable <code>renderCounter</code> auf den Anfangswert <code>0</code>. Diese Variable zählt für uns gleich mit wie oft wir unsere <code>App</code>-Komponente rendern oder genauer gesagt, wie oft wir im Endeffekt die <code>ReactDOM.render()</code> Funktion aufrufen, die dann entsprechend bei jedem Aufruf dafür sorgt, dass die <code>App</code>-Komponente erneut gerendert wird.</p>
<p>Anschließend starten wir einen Intervall, der die besagte Funktion regelmäßig alle 2000 Millisekunden ausführt. Dabei führt der Intervall nicht nur im 2 Sekunden-Takt die Funktion aus, sondern zählt auch gleichzeitig unsere <code>renderCounter</code> Variable um 1 hoch. Was hier jetzt passiert ist ganz spannend: wir modifizieren die <code>renderCounter</code> Prop unserer App <strong>„von außen“</strong>.</p>
<p>Die Komponente selbst bleibt dabei komplett „pure“. Wird sie aufgerufen mit:</p>
<pre><code class="hljs jsx language-jsx">&lt;App renderCounter={<span class="hljs-number">5</span>} /&gt;</code></pre>
<p>gibt sie uns als Ergebnis zurück:</p>
<pre><code class="hljs markup language-markup">&lt;<span class="hljs-keyword">div</span>&gt;<span class="hljs-number">5</span>&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre>
<p>Und zwar egal wie oft die Komponente inzwischen tatsächlich gerendert wurde. Gleicher Input, gleicher Output.</p>
<p>Innerhalb unserer Komponente sind und bleiben wir weiterhin „pure“. Wir modifizieren den Eingabewert nicht und wir haben in der Komponente auch keinerlei direkten Abhängigkeiten nach außen, die unser Render-Ergebnis beeinflussen könnten. Der Wert wird lediglich außerhalb unserer Komponente geändert und neu in die Komponente <strong>hereingegeben</strong>, was uns aber an dieser Stelle auch gar nicht weiter interessieren braucht, da es für uns lediglich wichtig ist, dass unsere Komponente mit gleichen Props auch weiterhin das gleiche Ergebnis liefert. Und das ist hier zweifellos gegeben. Wer die Props außerhalb unserer Komponente modifiziert, wie oft und in welcher Form ist uns ganz gleich, solange wir das nicht selber innerhalb unserer Komponente tun. Okay, Prinzip verstanden?</p>
<h4 id="props-sind-ein-abstrahiertes-funktionsargument">Props sind ein abstrahiertes Funktionsargument</h4>
<p>Da Props, reduziert man sie auf das Wesentliche, nichts anderes als ein Funktionsargument sind, können sie auch in dessen diversen Formen auftreten. Alles, was auch Functions oder Constructors in JavaScript als Argument akzeptieren, kann auch als Wert für eine Prop verwendet werden. Vom simplen String, über Objekte, Funktionen oder gar andere React-Elemente (die ja, wie wir bereits wissen, hinter den Kulissen auch nichts anderes als ein Funktionsaufruf sind) kann das nahezu alles sein, solange es eben ein valider Ausdruck ist.</p>
<pre><code class="hljs jsx language-jsx">&lt;MyComponent
  counter={<span class="hljs-number">3</span>}
  text=<span class="hljs-string">"example"</span>
  showStatus={<span class="hljs-literal">true</span>}
  config={{ <span class="hljs-attr">uppercase</span>: <span class="hljs-literal">true</span> }}
  biggerNumber={<span class="hljs-built_in">Math</span>.max(<span class="hljs-number">27</span>, <span class="hljs-number">35</span>)}
  arbitraryNumbers={[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">28</span>, <span class="hljs-number">347</span>, <span class="hljs-number">1538</span>]}
  dateObject={<span class="hljs-built_in">Date</span>}
  dateInstance={<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()}
  icon={
    &lt;svg x=<span class="hljs-string">"0px"</span> y=<span class="hljs-string">"0px"</span> width=<span class="hljs-string">"32px"</span> height=<span class="hljs-string">"32px"</span>&gt;
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"#CC3300"</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"16"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"16"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"16"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></span>
  }
  callMe={() =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Somebody called me'</span>);
  }}
/&gt;</code></pre>
<p>Auch wenn die meisten Props hier inhaltlich wenig Sinn ergeben und nur zur Veranschaulichung dienen, so sind sie dennoch syntaktisch korrektes JSX, demonstrieren wie mächtig sie sind und in welchen verschiedenen Formen sie auftreten können.</p>
<h3 id="props-sind-nicht-auf-eine-verschachtelungsebene-beschränkt">Props sind nicht auf eine Verschachtelungsebene beschränkt</h3>
<p>Eine Komponente die Props empfängt kann diese problemlos auch an Kind-Komponenten weiterreichen. Dies kann einerseits hilfreich sein wenn man große Komponenten in mehrere kleinere Komponenten unterteilt und gewisse Props an Kind-Komponenten weitergegeben werden müssen, kann aber bei komplexen Anwendungen teilweise dazu führen dass es schwer erkenntlich wird wo der genaue Ursprung einer Prop ist und wo ich anfangen muss zu suchen, wenn ich den Wert einer Prop ändern möchte.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;h1&gt;{props.name}&lt;/h1&gt;
      &lt;UserImage image={props.image} /&gt;
      &lt;ListOfPosts items={props.posts} /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(
  &lt;User name={user.name} image={user.image} posts={user.posts} /&gt;,
  document.getElementById('app')
);</code></pre>
<h3 id="die-wichtigsten-punkte-im-überblick">Die wichtigsten Punkte im Überblick</h3>
<div class="hint hint--success">
<p>Komponenten müssen sich hinsichtlich ihrer Props als „Pure Functions“ verhalten und bei gleichen Props stets die gleiche Ausgabe erzeugen.</p>
<ul>
<li>Props sind innerhalb einer Komponente grundsätzlich als <strong>readonly</strong> zu betrachten</li>
<li>Komponenten können eine <strong>beliebige Menge an Props</strong> übergeben bekommen.</li>
<li>In JSX übergibt man Props in ähnlicher Form wie in HTML Attribute</li>
<li>Anders als in HTML, sind in JSX diverse Arten von Werten erlaubt. Werte die nicht vom Typ String sind, werden dabei in <strong>geschweifte Klammern</strong> gefasst</li>
<li>Props können <strong>sämtliche JavaScript-Ausdrücke</strong> („Expressions“) als Wert entgegennehmen</li>
<li>Empfangene Props können beliebig viele Ebenen tief im Komponenten-Baum an Kind-Elemente weitergegeben werden</li>
</ul>
</div>
</div>
<div class="chapter">
  <h1 id="state-und-lifecycle-methods">State und Lifecycle-Methods</h1>
<p>Kommen wir zu dem, was die Arbeit mit React erstmal wirklich effizient macht: <strong>State</strong>, <strong>stateful Components</strong> und die sogenannten <strong>Lifecycle-Methods</strong>.</p>
<p>Wie im Kapitel über Komponenten bereits angesprochen können <strong>stateful Components</strong> einen eigenen Zustand, den <strong>State</strong>, halten, verwalten und verändern. Dabei gilt der Grundsatz: <strong>ändert sich der State einer Komponente, löst dies immer auch ein Re-Rendering der Komponente aus!</strong> Dieses Verhalten kann in <strong>Class Components</strong> auch explizit unterbunden werden, was in einigen Fällen sinnvoll ist. Aber der Grundsatz bleibt unverändert: eine State-Änderung löst ein Re-Rendering einer Komponente und ihrer Kind-Komponenten aus.</p>
<p>Das ist insofern hilfreich, als dass wir nicht mehr manuell <code>ReactDOM.render()</code> aufrufen müssen wann immer wir meinen dass sich etwas an unserem Interface geändert hat, sondern die Komponenten dies stattdessen selbst entscheiden können.</p>
<p>Neben dem State an sich gibt es auch eine handvoll sogenannter <strong>Lifecycle-Methoden</strong>. Dies sind Methoden die <strong>optional</strong> in einer <strong>Class Component</strong> definiert werden können und von React bei bestimmten Anlässen aufgerufen werden. Beispielsweise wenn eine Komponente erstmals gemountet wird, die Komponente neue Props empfangen oder sich der State innerhalb der Komponente geändert hat.</p>
<h2 id="eine-erste-stateful-component">Eine erste stateful Component</h2>
<p>Der <strong>State</strong> innerhalb einer Komponente ist verfügbar über die Instanz-Eigenschaft <code>this.state</code> und ist somit innerhalb einer <strong>Komponente</strong> gekapselt. Weder Eltern- noch Kind-Komponenten können ohne weiteres auf den State einer anderen Komponente zugreifen.</p>
<p>Um in einer Komponente einen initialen Zustand zu definieren gibt es zwei einfache Wege, einen dritten, von der Funktionalität her etwas erweiterten Weg lernen wir später noch mit der <strong>Lifecycle-Methode</strong> <code>getDerivedStateFromProps()</code> kennen.</p>
<p><strong>Initialen State</strong> kann man definieren, indem man im Constructor die Instanz-Eigenschaft <code>this.state</code> setzt:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">this</span>.state = {
      <span class="hljs-attr">counter</span>: props.counter,
    };
  }
}</code></pre>
<p>… oder indem man den State als <strong>ES2017</strong> <strong>Class Property</strong> definiert, was deutlich kürzer ist, jedoch momentan noch das <strong>Babel-Plugin</strong> <code>@babel/plugin-proposal-class-properties</code> (vor Babel 7: <code>babel-plugin-transform-class-properties</code>) benötigt:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">counter</span>: <span class="hljs-keyword">this</span>.props.counter,
  };
}</code></pre>
<p><strong>Create-React-App</strong> unterstützt die <strong>Class Property Syntax</strong> standardmäßig und da viele React-Projekte heute vollständig oder zumindest zu gewissen Teilen auf dem CRA-Setup oder Varianten davon basieren, kommt diese Syntax heute in den meisten Projekten zum Einsatz und kann genutzt werden. Sollte dies mal in einem Projekt nicht der Fall zu sein, empfehle ich dringend die Installation und Nutzung des Babel-Plugins, da es wirklich viele unnötige Zeilen Code bei der täglichen Arbeit mit React einspart, während es gleichzeitig in nur wenigen Minuten eingerichtet ist.</p>
<p>Ist der <strong>State</strong> erst einmal definiert, können wir innerhalb der <strong>Class Component</strong> mittels <code>this.state</code> <strong>lesend</strong> auf ihn zugreifen. <strong>Lesend</strong> ist hier ein entscheidendes Stichwort. Denn auch wenn es prinzipiell möglich ist den State direkt über <code>this.state</code> zu verändern sollte dies aus verschiedenen Gründen vermieden werden.</p>
<h2 id="den-state-verändern-mit-thissetstate">Den State verändern mit this.setState()</h2>
<p>Um State zu verändern stellt React eine eigene Methode innerhalb einer <strong>Class Component</strong> bereit:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">this</span>.setState(updatedState);</code></pre>
<p>Wann immer der State innerhalb einer Komponente verändert werden soll, sollte dafür <code>this.setState()</code> verwendet werden. Der Aufruf von <code>this.setState()</code> führt dann dazu, dass React entsprechende <strong>Lifecycle-Methoden</strong> (wie bspw. <code>componentDidUpdate()</code>) ausführt und eine Komponente <strong>neu rendert!</strong> Würden wir den State stattdessen direkt verändern, also bspw. <code>this.state.counter = 1;</code> schreiben, hätte dies vorerst keinerlei Auswirkungen auf unsere Komponente und alles würde aussehen wie bisher, da der Render-Prozess <strong>nicht</strong> ausgelöst werden würde!</p>
<p>Die Methode ist von der Funktionsweise her allerdings etwas komplexer als es auf den ersten Moment aussehen mag. Und so wird nicht einfach nur der alte State durch den neuen State ersetzt und ein Re-Rendering ausgelöst. Es passieren auch noch allerhand andere Dinge. Der Reihe nach.</p>
<p>Zuerst einmal kann die Funktion <strong>zwei verschiedene Arten von Argumenten</strong> entgegennehmen. Das ist einerseits ein <strong>Objekt</strong> mit neuen oder aktualisierten State-Eigenschaften, sowie andererseits eine <strong>Updater-Funktion,</strong> die wiederum ein Objekt zurückgibt oder <code>null</code>, falls nichts geändert werden soll. Bestehende gleichnamige Eigenschaften innerhalb des State-Objekts werden dabei <strong>überschrieben</strong>, alle anderen bleiben <strong>unangetastet!</strong> Möchten wir eine Eigenschaft im State zurücksetzen, müssen wie diese dazu also explizit auf <code>null</code> oder <code>undefined</code> setzen. Der übergebene State wird also immer mit dem bestehenden State <strong>zusammengefügt</strong>, niemals <strong>ersetzt!</strong></p>
<p>Nehmen wir nochmal unseren oben definierten State mit einer <code>counter</code> Eigenschaft, deren initialer Wert für dieses Beispiel erst einmal <code>0</code> ist. Nun verändern wir den State und möchten diesem zusätzlich eine <code>date</code> Eigenschaft mit dem aktuellen Datum hinzufügen. Übergeben als Objekt wäre unser Aufruf:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">this</span>.setState({
  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
});</code></pre>
<p>Nutzen wir stattdessen eine <strong>Updater-Funktion</strong>, wäre unser Aufruf:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
  };
});</code></pre>
<p>Oder kurz:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
});</code></pre>
<p>Unsere Komponente hat anschließend den neuen State:</p>
<pre><code class="hljs javascript language-javascript">{
  <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
}</code></pre>
<p>Um sicherzustellen stets auf den aktuellen State zuzugreifen, sollte eine <strong>Updater-Funktion</strong> verwendet werden, die den jeweils aktuellen State als ersten Parameter übergeben bekommt. Ein beliebter Fehler der vielen Entwicklern bei der Arbeit mit React schon passiert ist, ist es direkt nach einem <code>setState()</code>-Aufruf auf <code>this.state</code> zuzugreifen und sich zu wundern, dass der State noch immer der alte ist.</p>
<div class="hint hint--danger">
<p>React „sammelt“ schnell aufeinanderfolgende <code>setState()</code>-Aufrufe und <strong>führt diese nicht unmittelbar aus</strong>, um unnötig häufiges und überflüssiges Re-Rendering von Komponenten zu vermeiden. Schnell aufeinanderfolgende <code>setState()</code>-Aufrufe werden später in gesammelter Form als <strong>Batch-Prozess</strong> ausgeführt. Das ist wichtig zu wissen, da wir nicht unmittelbar nach einem <code>setState()</code>-Aufruf mittels <code>this.state</code> auf den neu gesetzten State zugreifen können.</p>
</div>
<p>Stellen wir uns eine Situation vor in der unser <code>counter</code>-State dreimal in schneller Abfolge erhöht werden soll. Intuitiv würde man nun vermutlich folgenden Code schreiben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">counter</span>: <span class="hljs-keyword">this</span>.state.counter + <span class="hljs-number">1</span> });
<span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">counter</span>: <span class="hljs-keyword">this</span>.state.counter + <span class="hljs-number">1</span> });
<span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">counter</span>: <span class="hljs-keyword">this</span>.state.counter + <span class="hljs-number">1</span> });</code></pre>
<p>Was denkst du, wie ist der neue State wenn der initiale State <code>0</code> war? <code>3</code>? Falsch. Er ist <code>1</code>! Hier kommt der angesprochene <strong>Batching-Mechanismus</strong> von React zum Zug. Um ein sich zu schnell aktualisierendes User Interface zu vermeiden, wartet React hier erst einmal ab. Am Ende kann man den obigen Code simpel ausgedrückt <strong>vom Funktionsprinzip her</strong> in etwa gleichsetzen mit:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">this</span>.state = <span class="hljs-built_in">Object</span>.assign(
  <span class="hljs-keyword">this</span>.state,
  { <span class="hljs-attr">counter</span>: <span class="hljs-keyword">this</span>.state.counter + <span class="hljs-number">1</span> },
  { <span class="hljs-attr">counter</span>: <span class="hljs-keyword">this</span>.state.counter + <span class="hljs-number">1</span> },
  { <span class="hljs-attr">counter</span>: <span class="hljs-keyword">this</span>.state.counter + <span class="hljs-number">1</span> }
);</code></pre>
<p>Die <code>counter</code>-Property überschreibt sich hier während eines Batch-Updates also immer wieder selbst, nimmt aber stets <code>this.state.counter</code> als Basiswert für die Erhöhung um 1. Nachdem alle State-Updates ausgeführt wurden, ruft React dann erneut die <code>render()</code>-Methode der Komponente auf.</p>
<p>Bei der Verwendung einer <strong>Updater-Funktion</strong> wird dieser Funktion dabei der jeweils aktuellste State als Parameter übergeben und wir haben Zugriff auf den zum Zeitpunkt des Funktionsaufrufs gültigen State:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">counter</span>: state.counter + <span class="hljs-number">1</span> });
<span class="hljs-keyword">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">counter</span>: state.counter + <span class="hljs-number">1</span> });
<span class="hljs-keyword">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">counter</span>: state.counter + <span class="hljs-number">1</span> });</code></pre>
<p>In diesem Fall nutzen wir eine solche <strong>Updater-Funktion</strong> und aktualisieren jeweils den aktuellsten Wert. Der Wert von <code>this.state.counter</code> wäre hier also wie erwartet <code>3</code>, da wir über den übergebenen <code>state</code>-Parameter mit jedem Aufruf auf den aktuellen State zugreifen. Grundsätzlich ist es allerdings zu empfehlen sich die benötigten Werte erst einmal zu erzeugen und anschließend gesammelt in einem einzigen <code>setState()</code>-Aufruf zu übergeben. So ist sichergestellt, dass es keine unnötigen zwischenzeitlichen <code>render()</code>-Aufrufe mit im nächsten Moment direkt wieder veraltetem State gibt.</p>
<p>Sollte es doch einmal nötig werden unmittelbar nach einem <code>setState()</code>-Aufruf auf den eben neu gesetzten State zuzugreifen bietet React die Möglichkeit als optionalen zweiten Parameter eine Callback-Funktion zu übergeben. Diese wird aufgerufen <strong>nachdem</strong> der State aktualisiert wurde, so dass in dieser mittels <code>this.state</code> sicher auf den dann neu gesetzten State zugegriffen werden kann.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">time</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleTimeString() }, () =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Neue Zeit:'</span>, <span class="hljs-keyword">this</span>.state.time);
});</code></pre>
<h2 id="lifecycle-methoden">Lifecycle-Methoden</h2>
<p><strong>Stateful Class Components</strong> bieten gegenüber ihren vereinfachten Kollegen, den <strong>Stateless Functional Components</strong> noch einen weiteren wichtigen Mehrwert: die sogenannten Lifecycle-Methoden (gelegentlich auch als Lifecycle-Hooks bezeichnet). Diese können als Methode einer Class Component implementiert werden und werden zu unterschiedlichen Zeitpunkten während eines Komponenten-Lebenszyklus (daher der Name) ausgeführt.</p>
<p>Der Lifecycle einer Methode beginnt in dem Moment, in der diese <strong>instanziiert</strong> wird, also innerhalb einer <code>render()</code>-Methode einer Eltern-Komponente tatsächlich Teil des zurückgegebenen Element-Baumes ist und endet, wenn die Komponente aus dem Baum der zu rendernden Elemente entfernt wird. Währenddessen gibt es noch Lifecycle-Methoden die auf Updates und auf Fehler reagieren. Oder eben darauf, dass sie nun entfernt („unmounted“) werden.</p>
<h3 id="überblick-über-die-lifecycle-methoden">Überblick über die Lifecycle-Methoden</h3>
<p>Im folgenden die Liste der Lifecycle-Methoden in der Reihenfolge wann und in welcher Phase diese durch React aufgerufen werden, sofern diese in einer Komponente definiert wurden:</p>
<h4 id="mount-phase">Mount-Phase</h4>
<p>Die folgenden Methoden werden <strong>einmalig</strong> aufgerufen wenn die Komponente erstmals gerendert werden, also, vereinfacht gesagt, erstmals zum DOM hinzugefügt werden:</p>
<ul>
<li><code>constructor(props)</code></li>
<li><code>static getDerivedStateFromProps(nextProps, prevState)</code></li>
<li><code>componentWillMount(nextProps, nextState)</code> (deprecated in React 17)</li>
<li><code>render()</code></li>
<li><code>componentDidMount()</code></li>
</ul>
<h4 id="update-phase">Update-Phase</h4>
<p>Die folgenden Methoden werden aufgerufen wenn Komponenten entweder durch die Hereingabe neuer Props von außen oder durch die Veränderung des eigenen States ein Update erhalten oder oder explizit die von React bereitgestellte <code>forceUpdate()</code>-Methode aufgerufen wird:</p>
<ul>
<li><code>componentWillReceiveProps(nextProps)</code> (deprecated in React 17)</li>
<li><code>static getDerivedStateFromProps(nextProps, prevState)</code></li>
<li><code>shouldComponentUpdate(nextProps, nextState)</code></li>
<li><code>componentWillUpdate(nextProps, nextState)</code> (deprecated in React 17)</li>
<li><code>render()</code></li>
<li><code>getSnapshotBeforeUpdate(prevProps, prevState)</code></li>
<li><code>componentDidUpdate(prevProps, prevState, snapshot)</code></li>
</ul>
<h4 id="unmount-phase">Unmount-Phase</h4>
<p>Hier gibt es nur eine Methode, diese wird aufgerufen sobald die Komponente aus dem DOM entfernt wird. Dies ist nützlich um bspw. Event-Listener oder <code>setTimeout()</code>/<code>setInterval()</code>-Aufrufe, die beim Mounting der Komponente hinzugefügt wurden, wieder zu entfernen:</p>
<ul>
<li><code>componentWillUnmount()</code></li>
</ul>
<h4 id="fehlerbehandlung">Fehlerbehandlung</h4>
<p>Zuletzt gibt es noch eine Methode die in React 16 neu hinzukam und immer dann aufgerufen wird wenn während des Renderings, in einer der Lifecycle-Methoden oder im Constructor einer <strong>Kind-Komponente</strong> ein Fehler geworfen wird:</p>
<ul>
<li><code>componentDidCatch()</code></li>
</ul>
<p>Komponenten die eine <code>componentDidCatch()</code>-Methode implementieren werden auch als <strong>Error Boundary</strong> bezeichnet und dienen dazu eine Alternative zum fehlerhaften Elementenbaum darzustellen. Dies kann eine High Level Komponente sein (bezogen auf die Komponenten-Hierarchie), die grundsätzliche eine Fehler-Seite anzeigt und den Nutzer auffordert die Anwendung neu zu laden sollte ein Fehler auftreten, dies kann aber auch eine Low Level Komponente sein die nur einen kurzen Fehlertext neben einem Button ausgibt, sollte die Aktion die der Button ausgelöst hat einen Fehler geworfen haben.</p>
<h3 id="lifecycle-methoden-in-der-praxis">Lifecycle-Methoden in der Praxis</h3>
<p>Werfen wir einmal einen Blick darauf wie sich die <strong>Lifecycle-Methoden</strong> in einer einfachen Komponente verhalten. Zu diesem Zweck implementieren wir beispielhalber eine Komponente die sekündlich ihren eigenen State verändert und jeweils die aktuelle Zeit ausgibt. Dazu wird beim <strong>Mounting</strong> der Komponente, also in der <code>componentDidMount()</code>-Methode, ein Interval gestartet, welches den State der Komponente aktualisiert, wodurch ein Rerendering ausgelöst und wieder die aktuelle Zeit angezeigt wird:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
  };

  componentDidMount() {
    <span class="hljs-keyword">this</span>.intervalId = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
        <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
      }));
    }, <span class="hljs-number">1000</span>);
  }

  componentWillUnmount() {
    clearTimeout(<span class="hljs-keyword">this</span>.intervalId);
  }

  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{this.state.date.toLocaleTimeString()}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
  }
}

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Hier sehen wir die Lifecycle-Methoden <code>componentDidMount()</code> und <code>componentWillUnmount()</code> im Einsatz. Wir definieren einen default <strong>State</strong> mit einer Eigenschaft <code>date</code>, die eine Instanz des Date-Objekts hält. Beim <strong>Mounting</strong> der Komponente (<code>componentDidMount()</code>) wird dann via <code>setInterval()</code> der Intervall gestartet und dessen Intervall ID in der Instanz-Eigenschaft <code>this.intervalId</code> gespeichert. Da der Intervall sekündlich die <code>setState()</code>-Methode aufruft, verursacht die Komponente auch regelmäßig ein Re-Rendering, d.h. die <code>render()</code>-Methode wird erneut aufgerufen und zeigt wieder die aktuelle Zeit an.</p>
<p>Da die Intervall-Funktion grundsätzlich unabhängig von der React-Komponente ist und abgesehen davon, dass sie die <code>setState()</code>-Methode der Komponente aufruft, keinerlei Verbindung zu ihr hat, kümmert sich React auch nicht automatisch darum, dass der Intervall-Aufruf der Funktion gestoppt wird wenn wir die Komponente nicht mehr weiter benötigen. Dafür müssen wir selber sorgen und genau zu diesem Zweck hält React für uns die nächste Lifecycle-Methode bereit: <code>componentWillUnmount()</code>.</p>
<p>Diese Methode wird unmittelbar bevor React die Komponente aus dem DOM entfernt aufgerufen und kann dazu benutzt werden um bspw. noch laufende XHRs abzubrechen, Event Listener zu entfernen oder eben einen laufenden Funktionsintervall zu beenden. Genau das tun wir hier: bevor die Komponente entfernt wird, rufen wir <code>clearTimeout()</code> auf und übergeben der Funktion die Intervall ID, die wir zuvor in der entsprechenden Instanz-Eigenschaft gespeichert haben.</p>
<p>Sollten wir dies einmal vergessen werden wir im Development-Modus von React aber spätestens beim Aufruf von <code>this.setState()</code> in einer bereits entfernten Komponente mit einer Warnung erinnert:</p>
<div class="hint hint--danger">
<p><strong>Warning:</strong> Can't call setState (or forceUpdate) on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.<br />
 in Clock</p>
</div>
<p>Anders als in einigen vorherigen Beispielen rufen wir hier die <code>ReactDOM.render()</code>-Methode nur ein einziges mal auf. Die Komponente kümmert sich ab dann „um sich selbst“ und löst einen Render-Vorgang aus, sobald sich ihr <strong>State</strong> aktualisiert hat. Dies ist die übliche Vorgehensweise bei der Entwicklung von Anwendungen die auf React basieren. Ein einziger <code>ReactDOM.render()</code>-Aufruf und ab dort verwaltet sich die App sozusagen von alleine, erlaubt Interaktion mit dem Benutzer, reagiert auf Zustandsänderungen und rendert regelmäßig das Interface neu.</p>
<h3 id="das-zusammenspiel-von-state-und-props">Das Zusammenspiel von State und Props</h3>
<p>Wir haben jetzt Beispiele gesehen für Komponenten, die Props verarbeiten und für Komponenten, die <strong>stateful</strong> sind, also ihren eigenen State verwalten. Doch es gibt noch eine ganze Menge mehr zu entdecken. Erst die Kombination mehrerer verschiedener Komponenten macht React erst zu dem mächtigen Werkzeug, das es ist. Eine Komponente kann dabei einen eigenen <strong>State</strong> haben und diesen gleichzeitig an Kind-Komponenten über deren <strong>Props</strong> weitergeben. So ist nicht nur die strikte Trennung von Business-Logik und Darstellung/Layout möglich sondern es erlaubt uns auch wunderbar Aufgaben basierte Komponenten zu entwickeln, die jeweils nur einen kleinen Teil der Applikation abbilden.</p>
<p>Bei der Trennung von Business- und Layout-Komponenten ist im React Jargon meist die Rede von <strong>Smart</strong> (Business-Logik) und <strong>Dumb</strong> (Layout) Components. <strong>Smart Components</strong> sollten dabei möglichst wenig bis gar nicht mit der Darstellung des User Interfaces betraut werden, während <strong>Dumb Components</strong> frei von jeglicher Business-Logik oder Seiteneffekten sein sollten, sich also tatsächlich auf die reine Darstellung von statischen Werten konzentrieren.</p>
<p>Schauen wir uns also das Zusammenspiel mehrerer Komponenten in einem weiteren Beispiel an:</p>
<pre><code class="hljs jsx language-jsx">const ShowDate = ({ date }) =&gt; &lt;div&gt;Heute ist {date}&lt;/div&gt;;

const ShowTime = ({ time }) =&gt; &lt;div&gt;Es ist {time} Uhr&lt;/div&gt;;

class DateTime extends React.Component {
  state = {
    date: new Date(),
  };

  componentDidMount() {
    this.intervalId = setInterval(() =&gt; {
      this.setState(() =&gt; ({
        date: new Date(),
      }));
    });
  }

  componentWillUnmount() {
    clearInterval(this.intervalId);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;ShowDate date={this.state.date.toLocaleDateString()} /&gt;
        &lt;ShowTime time={this.state.date.toLocaleTimeString()} /&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(&lt;DateTime /&gt;, document.getElementById('root'));</code></pre>
<p>Zugegeben: das Beispiel ist sehr konstruiert, demonstriert aber leicht verständlich das Zusammenspiel mehrerer Komponenten. Die <code>DateTime</code> Komponente ist in diesem Sinne unsere <strong>Logik-Komponente</strong>: sie kümmert sich darum die Zeit zu "besorgen" und zu aktualisieren, überlässt dann aber den <strong>Darstellungs-Komponenten</strong> deren Ausgabe, indem sie das Datum (<code>ShowDate</code>) bzw. die Zeit (<code>ShowTime</code>) über die Props übergeben bekommt.</p>
<p>Die Darstellungs-Komponenten selbst sind dabei als simple Stateless Functional Components implementiert, da diese selbst keinen eigenen State besitzen und daher kurz und knackig als SFC implementiert werden können.</p>
<h3 id="die-rolle-der-lifecycle-methoden-im-zusammenspiel-der-komponenten">Die Rolle der Lifecycle-Methoden im Zusammenspiel der Komponenten</h3>
<p>Eingangs habe ich neben den bisher in den Beispielen verwendeten <code>componentDidMount()</code> und <code>componentWillMount()</code> noch einige weitere <strong>Lifecycle-Methoden</strong> erwähnt. Auch diese werden, sofern in einer Class Component implementiert, zu den verschiedenen Anlässen von React berücksichtigt.</p>
<p>Zu diesem Zweck wollen wir einmal eine Übungskomponente erstellen, welche die verschiedenen <strong>Lifecycle-Methoden</strong> als Debug-Nachricht in der Browser-Konsole ausgibt. Genau genommen sind es zwei Komponenten, von denen eine als Eltern-Komponente, die andere als Kind-Komponente dient, die von ihrer Eltern-Komponente Props hineingereicht bekommt (und in diesem Fall einfach ignoriert).</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> log = <span class="hljs-function">(<span class="hljs-params">method, component</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[<span class="hljs-subst">${component}</span>]`</span>, method);
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParentComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {};

  <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props);
    log(<span class="hljs-string">'constructor'</span>, <span class="hljs-string">'parent'</span>);
  }

  <span class="hljs-keyword">static</span> getDerivedStateFromProps() {
    log(<span class="hljs-string">'getDerivedStateFromProps'</span>, <span class="hljs-string">'parent'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  componentDidMount() {
    log(<span class="hljs-string">'componentDidMount'</span>, <span class="hljs-string">'parent'</span>);
    <span class="hljs-keyword">this</span>.intervalId = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      log(<span class="hljs-string">'state update'</span>, <span class="hljs-string">'parent'</span>);
      <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
        <span class="hljs-attr">time</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleTimeString(),
      }));
    }, <span class="hljs-number">2000</span>);
  }

  shouldComponentUpdate() {
    log(<span class="hljs-string">'shouldComponentUpdate'</span>, <span class="hljs-string">'parent'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  getSnapshotBeforeUpdate() {
    log(<span class="hljs-string">'getSnapshotBeforeUpdate'</span>, <span class="hljs-string">'parent'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  componentDidUpdate() {
    log(<span class="hljs-string">'componentDidUpdate'</span>, <span class="hljs-string">'parent'</span>);
  }

  componentWillUnmount() {
    log(<span class="hljs-string">'componentWillUnmount'</span>, <span class="hljs-string">'parent'</span>);
    clearInterval(<span class="hljs-keyword">this</span>.intervalId);
  }

  render() {
    log(<span class="hljs-string">'render'</span>, <span class="hljs-string">'parent'</span>);
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">time</span>=<span class="hljs-string">{this.state.time}</span> /&gt;</span>;
  }
}

class ChildComponent extends React.Component {
  state = {};

  constructor(props) {
    super(props);
    log('constructor', 'child');
  }

  static getDerivedStateFromProps() {
    log('getDerivedStateFromProps', 'child');
    return null;
  }

  componentDidMount() {
    log('componentDidMount', 'child');
  }

  shouldComponentUpdate() {
    log('shouldComponentUpdate', 'child');
    return true;
  }

  getSnapshotBeforeUpdate() {
    log('getSnapshotBeforeUpdate', 'child');
    return null;
  }

  componentDidUpdate() {
    log('componentDidUpdate', 'child');
  }

  componentWillUnmount() {
    log('componentWillUnmount', 'child');
  }

  render() {
    log('render', 'child');
    return <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{this.props.time}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>;
  }
}

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">ParentComponent</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Diese beiden Komponenten führen zuverlässig zur folgenden Ausgabe:</p>
<pre><code class="hljs text language-text"><span class="hljs-string">[parent]</span> constructor
<span class="hljs-string">[parent]</span> getDerivedStateFromProps
<span class="hljs-string">[parent]</span> render
<span class="hljs-string">[child]</span> constructor
<span class="hljs-string">[child]</span> getDerivedStateFromProps
<span class="hljs-string">[child]</span> render
<span class="hljs-string">[child]</span> componentDidMount
<span class="hljs-string">[parent]</span> componentDidMount
<span class="hljs-string">[parent]</span> state update
<span class="hljs-string">[parent]</span> shouldComponentUpdate
<span class="hljs-string">[parent]</span> render
<span class="hljs-string">[child]</span> getDerivedStateFromProps
<span class="hljs-string">[child]</span> shouldComponentUpdate
<span class="hljs-string">[child]</span> render
<span class="hljs-string">[child]</span> getSnapshotBeforeUpdate
<span class="hljs-string">[parent]</span> getSnapshotBeforeUpdate
<span class="hljs-string">[child]</span> componentDidUpdate
<span class="hljs-string">[parent]</span> componentDidUpdate
<span class="hljs-string">[parent]</span> componentWillUnmount
<span class="hljs-string">[child]</span> componentWillUnmount</code></pre>
<p>Oh wow. Hier passiert also eine ganze Menge. Gehen wir also Zeile für Zeile durch und starten mit der Mount-Phase.</p>
<h4 id="constructorprops"><code>constructor(props)</code></h4>
<p>Als Erstes wird stets der <code>constructor</code> der <code>ParentComponent</code>-Komponente aufgerufen. React geht hier von „außen nach innen“ vor. Also Komponenten, die weiter oben in der Komponenten-Hierarchie stehen, werden zuerst instanziiert und anschließend deren <code>render()</code>-Methode aufgerufen. Dies ist notwendig, da React ansonsten nicht wüsste welche Kind-Komponenten überhaupt verarbeitet und berücksichtigt werden sollen, da React nur solche Kind-Komponenten berücksichtigt, die auch tatsächlich von der <code>render()</code>-Methode ihrer jeweiligen Eltern-Komponente zurückgegeben werden.</p>
<p>Der Constructor bekommt als Parameter die Props der Komponente übergeben und sollte diese über <code>super(props)</code> an seine Elternklasse (in der Regel ist das die <code>React.Component</code> oder <code>React.PureComponent</code> Klasse) weitergeben, da <code>this.props</code> ansonsten im Constuctor <code>undefined</code> ist, was zu unerwünschtem Verhalten und Bugs führen kann.</p>
<p>In vielen Fällen ist der Constructor heute gar nicht mehr notwendig wenn mit dem Babel-Plugin „Class Properties“ gearbeitet wird und sowohl State als auch Instanz-Methoden als Klassen-Eigenschaft implementiert werden. Ist dies nicht der Fall, ist der Constructor der Ort, um einen initialen State zu setzen (bspw. <code>this.state = { }</code>) und Instanz-Methoden mittels <code>.bind()</code> an die jeweilige Klassen-Instanz zu binden (bspw. <code>this.handleClick = this.handleClick.bind(this)</code>). Letzteres ist notwendig, da Instanz-Methoden bei der Verwendung als Event-Listener innerhalb von JSX sonst ihren Bezug zur Komponente verlieren würden und <code>this</code> nicht auf die Instanz der Komponente verweisen würde.</p>
<h4 id="static-getderivedstatefrompropsnextprops-prevstate"><code>static getDerivedStateFromProps(nextProps, prevState)</code></h4>
<p>Auf den Constructor folgt die statische <code>getDerivedStateFromProps()</code>-Methode. Da dies eine <strong>statische</strong> Methode ist (und als solche wie auch in unserem Beispiel oben mit dem Keyword <code>static</code> ausgezeichnet werden muss) hat sie keinerlei Zugriff auf die Instanz der Komponente mittels <code>this</code>. Die Methode dient dazu, um, basierend auf den in die Komponente hineingereichten Props und ggf. dem letzten State, den <strong>nächsten State</strong> der Komponente zu berechnen. Dieser wird als Objekt aus der Methode zurückgegeben. Sind keine Änderungen am State notwendig, soll <code>null</code> zurückgegeben werden. Dabei ist das Verhalten identisch zu <code>this.setState()</code>, und es wird nur der Teil des States aktualisiert, der sich auch im zurückgegebenen Objekt befindet. Diese Eigenschaften werden mit dem <strong>letzten State</strong> zu einem <strong>neuen State</strong> zusammengeführt.</p>
<p>Die Methode ist innerhalb der Community kontrovers diskutiert worden, da sie die nun als <strong>deprecated</strong> gekennzeichnete <strong>Lifecycle-Methode</strong> <code>componentWillReceiveProps()</code> ablöst, jedoch anders als diese, keinen Zugriff auf die Instanz der Komponente erlaubt. Die React-Entwickler haben diesen Schritt damit begründet dass diese beim überarbeiteten asynchronen Rendering von Komponenten zu unerwünschten Verhalten führen kann und haben die Methode (ebenso wie <code>componentWillMount()</code> und <code>componentWillUpdate()</code>) als „unsicher“ erkärt. Mit dem Begriff ist dabei explizit nicht die Sicherheit (im Sinne von Sicherheitslücken) gemeint sondern lediglich die Tatsache, dass Komponenten, die diese Lifecycle-Methoden verwenden in React 17 Bugs und anderen unerwünschten Effekte hervorrufen können.</p>
<p>Die <code>getDerivedStateFromProps()</code>-Methode sollte außerdem frei von Side Effects bleiben (also bspw. keine XHRequests veranlassen) sondern lediglich den neuen State der Komponenten-Instanz auf Basis der jeweiligen aktuellen Props berechnen bzw. <strong>ableiten</strong> (= derive). Anders als der Constructor wird die Methode nicht nur beim Mounting, also dem „Einhängen“ in den DOM, der Komponente aufgerufen sondern auch wenn die Komponente erneut Props empfängt. Diese müssen sich dabei nicht zwangsweise geändert haben.</p>
<h4 id="render"><code>render()</code></h4>
<p>Ist die Instanz einer Komponente erstellt und ihr State abgeleitet, ruft React bereits die <code>render()</code>-Methode auf. Die <code>render()</code>-Methode beschreibt unser User Interface und somit auch, welche Kind-Komponenten gerendert werden sollen. In unserem obigen Beispiel haben wir nur eine Kind-Komponente: die <code>ChildComponent</code> Komponente.</p>
<p>Und so geht hier das Spiel erneut los: <code>constructor()</code>, <code>getDerivedStateFromProps()</code> und anschließend wird auch die <code>render()</code>-Methode der Kind-Komponente aufgerufen. Also das exakt selbe Verhalten wie auch schon bei der <code>ParentComponent</code> Komponente. Die Kind-Komponente aus dem Beispiel hat hier keine weiteren eigenen Kind-Komponenten. Hätte sie diese, würden auch hier die obigen Lifecycle-Methoden ausgeführt werden, bis React bei diesem Ast irgendwann auf eine Komponente trifft, die keinerlei eigenen React-Komponenten mehr zurückgibt, sondern DOM-Elemente wie <code>div</code>, <code>p</code>, <code>section</code>, <code>span</code>, etc. (natürlich auch Kombinationen dieser) oder <code>null</code> oder eben ein Array der wiederum ebenfalls keine Komponenten enthält.</p>
<h4 id="componentdidmount"><code>componentDidMount()</code></h4>
<p>Ist eine solche Komponente erreicht, ist die <code>componentDidMount()</code>-Methode an der Reihe. Diese Methode wird aufgerufen sobald eine Komponente und all ihre Kind-Komponenten gerendert wurden. Ab diesem Moment kann auf die DOM-Node der Komponente zugegriffen werden falls notwendig. Die Methode ist außerdem der richtige Ort um bspw. Timeouts oder Intervalle zu starten oder Netzwerk-Requests bspw. via XHR/Fetch zu veranlassen.</p>
<p>Die Methode wird „von innen nach außen“ aufgerufen. Also erst sind die Kind-Komponenten an der Reihe sobald diese gerendert wurden, dann kommen die Eltern-Komponenten dran. So können wir in der obigen Log-Ausgabe auch gut sehen, dass dort erst einmal die <code>componentDidMount()</code>-Methode der <code>ChildComponent</code> aufgerufen wird, erst danach die der <code>ParentComponent</code>.</p>
<p>In unserem Beispiel starten wir in der <code>ParentComponent</code> einmalig einen <code>setTimeout()</code> Aufruf, der nach 2000 Millisekunden den State der Komponente ändert, um diejenigen Lifecycle-Methods zu demonstrieren, die beim Update einer Komponente aufgerufen werden. Die Mount-Phase ist damit abgeschlossen und alle weiteren Änderungen am State der gemounteten Komponenten führen dazu, dass React die Lifecycle-Methods aus der Update-Phase aufruft. Dies ist hier eben nach 2000 Millisekunden der Fall, wenn die ParentComponent ihren eigenen State mittels <code>this.setState()</code> modifiziert.</p>
<h4 id="shouldcomponentupdatenextprops-nextstate"><code>shouldComponentUpdate(nextProps, nextState)</code></h4>
<p>Findet ein Update einer Komponente statt, das ist immer der Fall wenn die Komponente ihren State verändert oder von außen Props hereingereicht bekommt, wird <code>shouldComponentUpdate()</code> aufgerufen. Doch Vorsicht, hier gibt es einen Unterschied je nachdem ob sich die Props geändert haben oder der State: bekommt eine Komponente neue Props von außen, wird zuvor <code>getDerivedStateFromProps()</code> aufgerufen.</p>
<p>Die <code>shouldComponentUpdate()</code>-Methode dient als „Hilfe“ mit der React mitgeteilt werden kann ob ein kostspieliges Re-Rendering überhaupt nötig ist. Die Methode bekommt die <strong>nächsten Props</strong> und den <strong>nächsten State</strong> als Parameter übergeben und kann auf deren Basis eine Entscheidung treffen ob ein Rendering ausgeführt werden soll. Die Methode muss dabei entweder <code>true</code> zurückgeben, damit wird ein Re-Rendering ausgelöst wird oder <code>false</code>, wodurch der Aufruf von sowohl <code>componentDidUpdate()</code> , <code>getSnapshotBeforeUpdate()</code> als auch <code>render()</code> in dieser Komponente unterbunden wird.</p>
<p>In komplexen Anwendungen ist es oftmals der Fall, dass der Update-Zyklus nur ausgelöst wird weil sich in einem anderen Teil der Anwendung, in einer Eltern-Komponente etwas geändert hat, diese Änderung aber für Kind-Komponenten irrelevant ist. Die <code>shouldComponentUpdate()</code>-Methode ist dann sehr hilfreich wenn es um die Optimierung der Rendering-Performance geht, da so unnötige Re-Renderings verhindert werden.</p>
<p>Würden wir in unserer obigen <code>ParentComponent</code> aus der <code>shouldComponentUpdate()</code>-Methode prinzipiell <code>false</code> zurückgeben wäre unsere Log-Ausgabe um einiges kürzer: die Zeilen 14-18 würden fehlen. Die Komponente würde nicht neu gerendert werden, ein Aufruf der render()-Methode fände nicht statt, damit würde auch die <code>ChildComponent</code> nicht neu gerendert werden und folglich auch deren Update-Hooks nicht aufgerufen werden.</p>
<p>Im Code-Beispiel geben wir aber <code>true</code> zurück. Dadurch wird folglich auch die <code>render()</code>-Methode der <code>ParentComponent</code> aufgerufen. Diese rendert wiederum erneut die <code>ChildComponent</code> die den aktualisierten <strong>State</strong> der <code>ParentComponent</code> in ihren <strong>Props</strong> übergeben bekommt und schon befinden wir uns im Update-Zyklus der <code>ChildComponent</code>.</p>
<p>Hier wird wie schon beim Mount-Zyklus <code>getDerivedStateFromProps()</code> aufgerufen um einen neuen State basierend auf den neuen Props abzuleiten. Anschließend wird auch hier <code>shouldComponentUpdate()</code> aufgerufen. Hier könnten wir bspw. prüfen ob sich die für diese Komponente relevanten Props überhaupt geändert haben und könnten dann im Fall, dass sie das nicht getan haben, ein Re-Rendering der Komponente sparen, indem wir ganz einfach <code>false</code> zurückgeben. Tun wir nicht, also folgt als nächstes der obligatorische Aufruf der <code>render()</code>-Funktion. Direkt darauf folgend wird nun die nächste Lifecycle-Methode aufgerufen.</p>
<h4 id="getsnapshotbeforeupdateprevprops-prevstate"><code>getSnapshotBeforeUpdate(prevProps, prevState)</code></h4>
<p>Diese Methode ist noch recht neu und wurde in React 16.3 zusammen mit <code>getDerivedStateFromProps()</code> neu eingeführt, um den Anforderungen für das neue asynchrone Rendering in React gerecht zu werden. Sie bekommt die <strong>letzten Props</strong> und den <strong>letzten State</strong> übergeben und hat letztmals Zugriff auf den aktuellen Zustand des HTML Dokuments, genauer gesagt dem DOM, bevor React die möglichen Änderungen aus dem letzten <code>render()</code>-Aufruf anwendet.</p>
<p>Dies kann nützlich sein wenn man sich bspw. die aktuelle Scrollposition in einer langen Tabelle oder Liste merken möchte um bei einem Update der Liste wieder zur entsprechenden Zeile springen zu können. Die Methode kann hier einen beliebigen Wert oder <code>null</code> zurückgeben. Das, was <code>getSnapshotBeforeUpdate()</code> zurückgibt, wird dann als dritter Parameter an die nächste Lifecycle-Methode, <code>componentDidUpdate()</code> übergeben.</p>
<p>Aus meiner Erfahrung wird diese Methode nur sehr selten verwendet, wahrscheinlich am seltensten von allen Lifecycle-Methoden, da bei der Arbeit mit React auch nur sehr selten direkt auf DOM-Elemente zugegriffen werden muss. Viele Dinge bei denen man bei einer imperativen Vorgehensweise auf die DOM API zurückgegriffen hätte, lassen sich hier direkt im abstrakten Virtual DOM, also über JSX lösen.</p>
<h4 id="componentdidupdateprevprops-prevstate-snapshot"><code>componentDidUpdate(prevProps, prevState, snapshot)</code></h4>
<p>Als letzte Methode aus dem Update-Zyklus ist dann <code>componentDidUpdate()</code> an der Reihe. Diese wird aufgerufen nachdem <code>getDerivedStateFromProps()</code> den neuen State abgeleitet hat, nachdem <code>shouldComponentUpdate()</code>, sofern implementiert, <code>true</code> zurückgegeben hat und nachdem <code>getSnapshotBeforeUpdate()</code> einen Snapshot des letzten Stands des DOM erstellt hat.</p>
<p>Die Methode bekommt als Parameter die <strong>letzten Props</strong> und den <strong>letzten State</strong> übergeben, d.h. die jeweiligen Props und den jeweiligen State bevor die Komponente aktualisiert wurde, und, sollte die Komponente eine <code>getSnapshotBeforeUpdate()</code>-Methode besitzen, deren Rückgabewert als dritten Parameter.</p>
<p>Ähnlich wie bereits <code>componentDidMount()</code> wird auch <code>componentDidUpdate()</code> „von innen nach außen“ aufgelöst, also werden erst die <code>componentDidMount()</code>-Methoden der Kind-Komponente(n) aufgerufen, danach die der Eltern-Komponente(n). Diese Methode ist der ideale Ort um Side Effects auszulösen, also bspw. XHRs zu starten, wenn sich gewisse Eigenschaften der Komponente geändert haben. Dies lässt sich durch einen simplem Vergleich der aktuellen Props mit den als Parameter übergebenen letzten Props bzw. dem aktuellen State mit den letzten State festgestellt werden kann.</p>
<p>Auch ist es in dieser Komponente sicher auf den <strong>aktuellen DOM</strong> zuzugreifen, sollte dies doch einmal notwendig sein. Zu dem Zeitpunkt an dem diese Methode aufgerufen wird, hat React die notwendigen Änderungen, die sich aus dem möglicherweise geänderten JSX aus der <code>render()</code>-Methode ergeben, bereits durchgeführt und in den DOM übertragen.</p>
<p>Und damit ist neben dem <strong>Mount-Zyklus</strong> auch der <strong>Update-Zyklus</strong> abgeschlossen. Während der Mount-Zyklus <strong>immer nur einmal</strong> durchlaufen wird, nämlich dann wenn eine Komponente <strong>erstmals</strong> gerendert wird, kann der Update-Zyklus, solange die Komponente gemountet ist, beliebig häufig angestoßen werden und wird immer durchlaufen, sobald eine Komponente ihren State ändert oder neue Props bezieht.</p>
<h4 id="componentwillunmount"><code>componentWillUnmount()</code></h4>
<p>Zugegeben, im obigen Log habe ich etwas geschummelt, denn die <code>componentWillUnmount()</code>-Methode wird immer dann (und nur dann) ausgeführt wenn eine Komponente komplett aus dem DOM entfernt wird. Das wird sie im dazugehörigen Code-Beispiel allerdings nie. Eine Komponente gilt dann als unmounted, wenn sie über den Aufruf von <code>ReactDOM.unmountComponentAtNode()</code> explizit entfernt wird (das gilt insbesondere für Mount-Nodes) oder wenn sie implizit nicht mehr aus der render()-Methode einer Eltern-Komponente zurückgegeben wird.</p>
<p>Immer dann wird die <code>componentWillUnmount()</code>-Methode einer Komponente aufgerufen. Natürlich wie bei allen Methoden, abgesehen von <code>render()</code>, nur dann wenn sie auch implementiert wurde. Diese Lifecycle-Methode ist essentiell wenn es um das „Aufräumen“ geht. Hier können und <strong>sollten</strong> all die Funktionen aufgerufen werden die benötigt sind, damit die Komponente keine „Spuren hinterlässt“. Das können noch ausstehende Timeouts (<code>setTimeout</code>) oder fortlaufende Intervalle (<code>setInterval</code>) sein aber auch DOM-Modifikationen die außerhalb des eigenen Komponenten-JSX vorgenommen wurden, noch laufende Netzwerkverbindungen bzw. XHR/Fetch-Aufrufe oder auch eigene Event Listener, die mittels der DOM API Methode <code>Element.addEventListener()</code> hinzugefügt wurden.</p>
<p>Event Listener. Gutes Stichwort. Darum kümmern wir uns im nächsten Kapitel, denn in den meisten Fällen ist der Einsatz von <code>addEventListener()</code> in React nicht mehr nötig, da React ein eigenes Event-System mitbringt um für bessere Übersicht zu sorgen.</p>
<h3 id="diagramm-der-lifecycle-methoden">Diagramm der Lifecycle-Methoden</h3>
<p class="has-image"><span><img src="./assets/.gitbook/lifecycle-methods-2.png" alt="Diagram der verschiedenen Lifecycle-Methods in ihren jeweiligen Phasen (CC0 Dan Abramov)" /><span class="caption">Diagram der verschiedenen Lifecycle-Methods in ihren jeweiligen Phasen (CC0 Dan Abramov)</span></span></p>
</div>
<div class="chapter">
  <h1 id="event-handling">Event-Handling</h1>
<p>Ein wesentlicher Teil bei der Entwicklung von Anwendungen mit einem komplexen User Interfaces ist natürlich die Interaktion zwischen Benutzer und dem Interface an sich. Insbesondere in Form von <strong>Events</strong>.</p>
<p>Ich drücke einen Knopf und es passiert etwas. Ich schreibe einen Text in ein Feld und es passiert etwas. Ich wähle ein Element aus einer Liste und es passiert etwas. In einfachem JavaScript stellt uns der Browser dafür die Methoden <code>addEventListener()</code> und <code>removeEventListener()</code> bereit. Auf diese beiden Event-Methoden kann in React in den meisten Fällen nahezu komplett verzichtet werden, da React ein eigenes System zum Definieren von Benutzerinteraktion gleich mitbringt. Und zwar, nicht erschrecken: über <strong>Inline-Events</strong>.</p>
<p>Diese <strong>Inline-Events</strong> haben rein äußerlich sehr große Ähnlichkeit zu den HTML Event-Attributen (also bspw. <code>&lt;button onclick="myFunction" /&gt;</code>) und doch ist ihre Funktionsweise grundlegend anders.</p>
<p>Da wurde uns Web-Entwicklern über Jahre immer wieder beigebracht, dass man seine Event-Listener sauber von seinem Markup trennen sollte, <strong>Separation of Concerns</strong>, dann kommt React daher und macht wieder einfach alles anders.</p>
<p>Und das ist in diesem Fall auch gut so, denn durch die Verwendung eines eigenen Systems zur Verwaltung von Events, nimmt uns React hier wieder eine ganze Menge Arbeit ab und ermöglicht es uns außerdem sehr leicht im Komponenten-Kontext zu bleiben, indem wir alle Event-Handler als <strong>Klassen-Methoden</strong> implementieren können und so sowohl Darstellungslogik als auch Verhaltenslogik in einer einzigen Komponente kapseln können. Kein mühsames und unübersichtliches hin- und herspringen zwischen Controllern und Views!</p>
<h3 id="unterschiede-zur-nativen-event-api">Unterschiede zur nativen Event API</h3>
<p>Events in React und JSX werden wie erwähnt sehr ähnlich definiert wie HTML Event-Attribute. Doch es gibt einige Unterschiede. So werden Events in React in <strong>CamelCase</strong>-Form definiert, statt in <strong>Lowercase</strong>. Somit wird aus <code>onclick</code> in React <code>onClick</code>, aus <code>onmouseover</code> wird <code>onMouseOver</code>, <code>ontouchstart</code> wird zu <code>onTouchStart</code> usw.</p>
<p>Der dem Event-Handler übergebene erste Parameter ist auch kein Objekt vom Typ <code>Event</code>, sondern ein sogenannter <code>SyntheticEvent</code>, ein React eigener Wrapper um das native Event-Objekt. Dieser Wrapper ist Teil des React Event Systems und dient als eine Art Normalisierungsschicht, um Cross-Browser-Kompatibilität zu gewährleisten. Dabei hält diese sich, anders als so mancher Browser, strikt an die <a href="https://www.w3.org/TR/DOM-Level-3-Events/">Event-Spezifikation des W3C</a>.</p>
<p>Ein weiterer Unterschied zur nativen Browser-Event API ist der, dass explizit <code>preventDefault()</code> aufgerufen werden muss um das Standardverhalten des Browsers bei einem Event zu unterdrücken statt lediglich <code>false</code> aus dem Event-Handler zurückzugeben.</p>
<p>Und nicht zuletzt, ist der im Event-Attribut (bzw. Event-<strong>Prop</strong> in JSX) angegebene Wert eine <strong>Referenz zu einer Funktion</strong> statt wie in HTML ein String. Folglich benötigen wir hier die geschweiften Klammern um JSX mitzuteilen, dass es sich um einen JavaScript-Ausdruck handelt.</p>
<p>Wie das aussieht? So:</p>
<pre><code class="hljs jsx language-jsx">&lt;button onClick={validateInput}&gt;Validate&lt;<span class="hljs-regexp">/button&gt;</span></code></pre>
<p>Wohingegen ein vergleichbarer Event in HTML wie folgt aussähe:</p>
<pre><code class="hljs markup language-markup">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">"validateInput"</span>&gt;Validate&lt;/<span class="hljs-keyword">button</span>&gt;</code></pre>
<p>Dieses Vorgehen, das auf den ersten Blick auf einige vielleicht erst einmal etwas eigenartig anmuten könnte bringt aber einige großartige Vorteile mit sich. Und so bekommen wir, wie eingangs bereits angesprochen, Cross-Browser-Kompatibilität „for free“. React registriert dabei im Hintergrund die Events sauber mittels <code>addEventListener()</code> und entfernt diese auch automatisch wieder für uns, sobald die Komponente entfernt (<em>unmounted</em>) wird. Praktisch!</p>
<h3 id="scopes-in-event-handlern">Scopes in Event-Handlern</h3>
<p>Bei der Verwendung von ES2015-Klassen in React ist für gewöhnlich so, dass Event-Handler als Methoden der Klassen-Komponente implementiert werden. Hierbei muss jedoch beachtet werden, dass <strong>Klassen-Methoden nicht automatisch an die Instanz gebunden werden</strong>. Klingt kompliziert, bedeutet aber lediglich, dass <code>this</code> in eurem Event-Handler grundsätzlich erstmal <code>undefined</code> ist.</p>
<p>Hierzu ein kurzes Beispiel:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span>,
  };

  increase() {
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({
      <span class="hljs-attr">counter</span>: state.counter + <span class="hljs-number">1</span>,
    }));
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{this.state.counter}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.increase}</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}</code></pre>
<p>Hier definieren wir also einen <code>onClick</code>-Event um den Zähler jeweils um <code>1</code> zu erhöhen, sobald der Benutzer auf den Button <code>+1</code> klickt. Beim Klick auf den Button sieht unser Benutzer aber stattdessen:</p>
<div class="hint hint--danger">
<p><strong>TypeError</strong></p>
<p>Cannot read property 'setState' of undefined</p>
</div>
<p>Und warum? <strong>Scoping!</strong> Da wir uns beim Klick auf den Button im Event-Handler <code>increase()</code> außerhalb der Komponenten-Instanz bewegen, können wir eben auch nicht auf <code>this.setState()</code> zugreifen. Dies ist kein fehlerhaftes Verhalten von React sondern das Standardverhalten von ES2015-Klassen. Um dieses Problem zu lösen gibt es nun verschiedene Möglichkeiten.</p>
<h4 id="method-binding-in-der-render-methode">Method-Binding in der render()-Methode</h4>
<p>Die trivialste Methode ist das Binden der Methode innerhalb der <code>render()</code>-Methode. Dazu fügen wir ein <code>.bind(this)</code> an die Referenz zur Klassen-Methode:</p>
<pre><code class="hljs jsx language-jsx">&lt;button onClick={<span class="hljs-keyword">this</span>.increase.bind(<span class="hljs-keyword">this</span>)}&gt;+<span class="hljs-number">1</span>&lt;<span class="hljs-regexp">/button&gt;</span></code></pre>
<p>Die Methode wird nun <strong>im Scope der Komponenten-Instanz</strong> aufgerufen und unser Counter zählt problemlos hoch. Dieses Muster sieht man relativ häufig, da es einfach implementiert ist, hat jedoch einen grundlegenden Nachteil. Denn es wird bei jedem Aufruf der Methode „on-the-fly“ eine neue Funktion erzeugt, die nicht mehr mit der vorherigen identisch ist. Ein simpler Check in einer <code>shouldComponentUpdate()</code>-Methode, der auf Gleichheit von <code>this.props.increase === prevProps.increase</code> prüft, würde somit stets <code>false</code> ergeben und ggf. ein Re-Rendering einer Komponente veranlassen, auch wenn sich die Funktion an sich nicht geändert hat. Dies ist ein potentielles <strong>Performance-Bottleneck</strong> und sollte daher möglichst vermieden werden!</p>
<h4 id="method-binding-im-constructor">Method-Binding im Constructor</h4>
<p>Eine andere, sauberere Möglichkeit eine Methode an eine Klassen-Instanz zu binden ist, dies im Constructor bei der Instanziierung einer Klasse zu tun.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props);
    <span class="hljs-keyword">this</span>.state = {
      <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span>,
    };
    <span class="hljs-keyword">this</span>.increase = <span class="hljs-keyword">this</span>.increase.bind(<span class="hljs-keyword">this</span>);
  }
  <span class="hljs-comment">// […]</span>
}</code></pre>
<p>Auf diesem Weg wird die Methode nur <strong>einmal</strong> an die Instanz gebunden. Ein eventueller Check auf Gleichheit von Methoden würde also <code>true</code> ergeben und unnötige Re-Renderings könnten bei der Verwendung sinnvoller <code>shouldComponentUpdate()</code>-Checks vermieden werden. Allerdings bringt dieser Weg auch eine ganze Menge Overhead mit sich. Vorausgesetzt wir nutzen nicht ohnehin bereits einen Constructor, müssen wir diesen nun implementieren. Dazu sollten wir die <code>super(props);</code> Methode aufrufen um die <strong>Props</strong> der Komponente an die <code>React.Component</code> Eltern-Klasse zu übergeben. Letztendlich schreiben wir noch zweimal den Namen der Methode die wir binden wollen indem wir sie sozusagen mit der an <code>this</code> gebundenen Version von sich selbst überschreiben.</p>
<p>Das ist dennoch schon mal besser als die erste Methode, auch wenn es mehr Schreibarbeit ist, da wir uns potentielle Performance-Bottlenecks ersparen. Aber es gibt noch eine weitere, einfache Möglichkeit um mit minimalem Mehraufwand eine Methode an eine Instanz zu binden.</p>
<h4 id="benutzung-von-class-properties">Benutzung von Class Properties</h4>
<p><strong>Achtung:</strong> dieser Weg setzt die Verwendung des Babel-Plugins <code>@babel/plugin-proposal-class-properties</code> voraus. Da dies jedoch wie bereits in der Einleitung beschrieben in den meisten React-Setups zum Standard gehört, gehe ich also davon aus, dass <strong>Class Properties</strong> genutzt werden können. ist dies nicht der Fall, sollten Event-Handler-Methoden immer im Constructor gebunden werden!</p>
<p>Aber wie binden wir jetzt unsere Methode indem wir <strong>Class Properties</strong> nutzen? Streng genommen: indem wir schummeln! Statt eine echte Klassen-Methode zu implementieren wie im Eingangsbeispiel, definieren wir eine <strong>Public Class Property</strong> die als Wert eine per <strong>Arrow Function</strong> an die jeweilige Klasse gebundene Function zugewiesen bekommt. Das sieht dann wie folgt aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span>,
  };
  increase = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({
      <span class="hljs-attr">counter</span>: state.counter + <span class="hljs-number">1</span>,
    }));
  };
}</code></pre>
<p>Der entscheidende Faktor liegt hier in der ersten Zeile. Statt:</p>
<pre><code class="hljs jsx language-jsx">increase() { … }</code></pre>
<p>Schreiben wir:</p>
<pre><code class="hljs jsx language-jsx">increase = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { … }</code></pre>
<p><strong>Problem gelöst!</strong></p>
<p>Der Unterschied liegt hier wie erwähnt darin, dass wir im ersten Beispiel eine <strong>echte Klassen-Methode</strong> implementieren und im zweiten Fall stattdessen einer gleichnamigen Eigenschaft dieser Klasse eine <strong>Arrow Function als Wert</strong> zuweisen. Da diese kein eigenes <code>this</code> bindet, greifen wir in dieser auf das <code>this</code> der Klassen-Instanz zu.</p>
<h3 id="events-außerhalb-des-komponenten-kontexts">Events außerhalb des Komponenten-Kontexts</h3>
<p>Die Verwendung von React schließt auch die Implementierung von nativen Browser-Events nicht aus. Allerdings sollte nach Möglichkeit immer das React eigene Event-System verwendet werden, da dieses Cross-Browser-Kompatibilität mitbringt, nach dem W3C Standard für Browser-Events arbeitet und zahlreiche Optimierungen vornimmt.</p>
<p>Gelegentlich ist es jedoch notwendig Events außerhalb des Komponenten-Kontexts zu definieren. Ein Klassisches Beispiel sind <code>window.onresize</code> oder <code>window.onscroll</code> Events. Hier bietet React keine Möglichkeit von Haus aus um globale Events außerhalb des Komponenten spezifischen JSX zu definieren. Hier ist dann die <code>componentDidMount()</code>-Methode der richtige Ort um diese zu definieren. Dabei sollte allerdings auch stets darauf geachtet werden, dass Events die mittels <code>addEventListener()</code> definiert werden <strong>immer auch entfernt werden!</strong></p>
<p>Der richtige Ort <strong>dafür</strong> ist dann die <code>componentWillUnmount()</code>-Methode. Werden eigene definierte globale Events nicht entfernt, werden diese mit jedem Mounting einer Komponente <strong>erneut</strong> hinzugefügt und auch erneut <strong>mehrmals</strong> aufgerufen, was letztendlich ebenfalls zu <strong>Performance-Bottlenecks</strong> und sogar zu <strong>Memory-Leaks</strong> führen kann.</p>
<h3 id="arbeiten-mit-dem-syntheticevent-objekt">Arbeiten mit dem <code>SyntheticEvent</code> Objekt</h3>
<p><strong>React übergibt Event-Handlern kein natives Event-Objekt</strong> sondern ein eigenes Objekt vom Typ <code>SyntheticEvent</code>. Dies dient insbesondere dazu, Cross-Browser-Kompatibles Verhalten zu gewährleisten. React hält den originalen Event aber in der Objekt-Eigenschaft <code>nativeEvent</code> bereit. Sollte also jemals der Bedarf bestehen auf den Original-Event zuzugreifen (ist mir bisher noch nie passiert): ihr findet ihn in der <code>e.nativeEvent</code> Eigenschaft.</p>
<p>Das <code>SyntheticEvent</code>-Objekt hat aber noch eine weitere Besonderheit im Vergleich mit dem nativen Event-Objekt, denn es ist <strong>kurzlebig</strong>. Aus Performance-Gründen wird das Objekt <strong>nullified</strong> nach dem Aufruf des Event-Callbacks, also kurz gesagt: es wird zurückgesetzt auf den Ausgangszustand. Ein Zugriff auf Eigenschaften des Event-Objekts außerhalb des originalen Event-Handlers ist daher nicht ohne Weiteres möglich.</p>
<p>Was bedeutet das? Nun, folgendes Beispiel:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextRepeater</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {};

  handleChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({
      <span class="hljs-attr">value</span>: e.target.value,
    }));
  };

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{this.handleChange}</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{this.state.value}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    );
  }
}</span></code></pre>
<p>Wir registrieren einen <code>onChange</code>-Event, der bei einer Änderung im Textfeld den eingegebenen Wert in einem Paragraphen unter dem Textfeld wieder ausgibt. Um im Event-Handler auf den eingegebenen Wert zuzugreifen, das kennt ihr möglicherweise bereits aus nativem JavaScript oder von jQuery-Events, Stelle das <code>Event</code>-Objekt die Eigenschaft <code>target</code> bereit. Damit bekommen wir das Element, auf dem der Event stattgefunden hat, in unserem Beispiel also das Textfeld. Dieses wiederum besitzt eine <code>value</code> Eigenschaft mittels der wir dann auf den aktuellen Wert des Textfelds zugreifen, um diesen in unseren State zu schreiben.</p>
<p>Hier haben wir aber nun mit einem Fallstrick zu tun: der <code>this.setState()</code>-Aufruf nutzt eine <strong>Updater-Funktion</strong>, also einen Callback. Dieser findet außerhalb des eigentlichen Event-Handler Scopes statt. Das bedeutet der <code>SyntheticEvent</code> wurde zu diesem Zeitpunkt bereits wieder zurückgesetzt und <code>e.target</code> existiert zum Zeitpunkt des Aufrufs der Updater-Funktion schon gar nicht mehr:</p>
<div class="hint hint--danger">
<p><strong>TypeError</strong></p>
<p>Cannot read property 'value' of null</p>
</div>
<p>Die einfachste Lösung wäre hier statt der Updater-Funktion ein Object-Literal zu verwenden:</p>
<pre><code class="hljs jsx language-jsx">handleChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">this</span>.setState({
    <span class="hljs-attr">value</span>: e.target.value,
  });
};</code></pre>
<p>Damit wäre unser Problem in dem Fall zwar gelöst, das hilft uns aber trotzdem nicht sonderlich weiter. Denn auf das gleiche Problem stoßen wir auch, wenn wir auf Eigenschaften des <code>SyntheticEvent</code>-Objekts bspw. in einem <code>setTimeout()</code>-Callback zugreifen wollen. Wir müssen uns also etwas anderes einfallen lassen.</p>
<h4 id="werte-in-variablen-schreiben">Werte in Variablen schreiben</h4>
<p>In den meisten Fällen sollte es ausreichen wenn einzelne Werte, auf die später im Callback zugegriffen werden, soll in eine Variable geschrieben werden. Im Callback wird dann nicht mehr auf den <code>SyntheticEvent</code> zugegriffen sondern lediglich auf die Variable, die einen Wert aus dem <code>SyntheticEvent</code> zugewiesen bekommen hat.</p>
<pre><code class="hljs jsx language-jsx">handleChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> value = e.target.value;
  <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
    <span class="hljs-attr">value</span>: value,
  }));
};</code></pre>
<p>Klappt. Bonuspunkte für Eleganz gibt es bei der Verwendung von <strong>Object Destructuring</strong> und dem <strong>Object Property Shorthand</strong>:</p>
<pre><code class="hljs jsx language-jsx">handleChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { value } = e.target;
  <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({ value }));
};</code></pre>
<h4 id="persistieren-von-syntheticevents-mittels-epersist">Persistieren von <code>SyntheticEvents</code> mittels <code>e.persist()</code></h4>
<p>Theoretisch möglich, in der Praxis aus meiner Erfahrung eher irrelevant: das <code>SyntheticEvent</code>-Objekt stellt eine eigene Methode <code>persist()</code> bereit, mit der eine Referenz zum entsprechenden Event beibehalten (also persistiert) werden kann. Ein möglicher Anwendungsfall wäre hier, das gesamte <code>SyntheticEvent</code>-Objekt an eine Callback-Funktion <strong>außerhalb</strong> des Event-Handlers weiterzugeben.</p>
<p>Sollte das jedoch notwendig sein, lohnt es sich aber womöglich darüber nachzudenken ob der Code der externen Callback-Funktion nicht besser im Event-Handler selbst besser aufgehoben wäre. Unsere Beispielfunktion von oben sieht in diesem Fall so aus:</p>
<pre><code class="hljs jsx language-jsx">handleChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  e.persist();
  <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
    <span class="hljs-attr">value</span>: e.target.value,
  }));
};</code></pre>
<p>Zuerst rufen wir besagte <code>e.persist()</code>-Methode auf. Anschließend können wir auch in der <strong>Updater-Funktion</strong> sorglos auf <code>e.target</code> und dessen <code>value</code>-Eigenschaft zugreifen.</p>
<h3 id="fazit">Fazit</h3>
<div class="hint hint--info">
<ul>
<li>Zum Definieren von Events möglichst <strong>immer</strong> die Event-Props im JSX verwenden: <code>onChange</code>, <code>onMouseOver</code>, <code>onTouchStart</code>, <code>onKeyDown</code>, <code>onAnimationStart</code> usw. auch wenn es anfangs gewöhnungsbedürftig wirken sollte.</li>
<li>Event-Handler müssen explizit an die Klassen-Instanz gebunden werden wenn auf andere Klassen-Methoden wie bspw. <code>this.setState()</code> zugegriffen wird. Der eleganteste Weg hierfür sind <strong>Public Class Properties</strong> und <strong>Arrow Functions.</strong></li>
<li>Eigene Events über die <code>addEventListener()</code>-API zu definieren sollte möglichst vermieden werden. Lässt es sich einmal nicht vermeiden, unbedingt daran denken diese Events beim Unmounting der Komponente mittels <code>removeEventListener()</code> zu entfernen!</li>
<li><code>SyntheticEvent</code>-Objekte werden „nullified“. Vorsicht bei der Verwendung in Callback-Funktionen außerhalb des jeweiligen Event-Handlers! Hier ist es gut möglich, dass das Event-Objekt beim Aufruf des Callbacks mittlerweile nicht mehr existiert.</li>
<li>Mittels <code>event.persist()</code> kann erzwungen werden, dass das das Event-Objekt nicht durch React auf <code>null</code> gesetzt wird.</li>
</ul>
</div>
</div>
<div class="chapter">
  <h1 id="formulare">Formulare</h1>
<p>Formulare besitzen in React eine kleine Sonderstellung und funktionieren etwas anders als andere DOM-Elemente, da Formulare eine Art <strong>eigenen State</strong> besitzen, der erst einmal nichts mit dem React-State gemein hat.</p>
<p>Der State von Textfeldern besteht bspw. aus dem eingegebenen Wert, der State von Checkboxen oder Radio-Buttons resultiert aus der Tatsache ob diese ausgewählt sind oder nicht, Auswahllisten (<code>&lt;select&gt;&lt;/select&gt;</code>) halten als State den ausgewählten Wert bzw. bei Mehrfachauswahl die ausgewählten Werte. React ändert an diesem Verhalten grundsätzlich erstmal nichts. Wer möchte, kann das so beibehalten und muss sich um nichts weiter kümmern.</p>
<p>Im React-Jargon ist dann die Rede von <strong>Uncontrolled Components</strong>, also <strong>unkontrollierten Komponenten</strong>. Unkontrolliert deshalb, weil React sich nicht um das State-Management dieser Komponenten kümmert. Das State-Handling ist entweder vollständig unabhängig von React oder funktioniert nur aus Richtung der DOM Formular-Elemente hin zum React State, jedoch <strong>nicht in die entgegengesetzte Richtung</strong>. Von einem Update am React-State bekommt ein Formular-Element also nichts mit und zeigt weiter den gleichen Wert (oder Status bei Checkboxen, Selects und Radiobuttons) wie zuvor.</p>
<p>Demgegenüber stehen die <strong>Controlled Components</strong>, also <strong>kontrollierte Komponenten</strong>. Hier aktualisiert ein Update am React-State den Wert (oder Status) des Formular-Elements und ebenso aktualisiert ein Update am jeweiligen Formular-Element den React-State. <strong>Controlled Components</strong> sind etwas aufwändiger in der Implementierung, sind zugleich jedoch auch die „sicherere“ Variante, da wir nicht Gefahr laufen, dass beide States voneinander abweichen.</p>
<h2 id="uncontrolled-components--unkontrollierte-komponenten">Uncontrolled Components / unkontrollierte Komponenten</h2>
<p><strong>Unkontrollierte Komponenten</strong> können dabei im Wesentlichen in zwei verschiedenen Formen auftreten. Bei der ersten Variante werden einfach nur Formular-Elemente gerendert, die beim Abschicken bspw. rein serverseitig verarbeitet werden und in keiner Weise mit React interagieren. Ein komplett statisches Formular wenn man so will. React kümmert sich dabei <strong>nicht von alleine</strong> um die Anbindung an den React-State sondern <strong>lässt dem Entwickler hier sämtliche Freiheiten</strong>!</p>
<p>Bei der zweiten Variante werden Änderungen an einem Formular-Element <strong>in den React-State</strong> geschrieben um bspw. im Hintergrund eine Validierung der Daten vorzunehmen oder die eingegebenen Daten an anderer Stelle auszugeben. Eine Änderung am React-State an anderer Stelle der Anwendung hat dabei keinerlei direkten Einfluss auf die Formularfelder.</p>
<p>Ein Beispiel für eine solche unkontrollierte Komponente:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Uncontrolled</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">username</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">isValid</span>: <span class="hljs-literal">false</span>,
  };

  changeUsername = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> { value } = e.target;
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      <span class="hljs-attr">username</span>: value,
      <span class="hljs-attr">isValid</span>: value.length &gt; <span class="hljs-number">3</span>,
    }));
  };

  submitForm = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    e.preventDefault();
    alert(<span class="hljs-string">`Hallo <span class="hljs-subst">${<span class="hljs-keyword">this</span>.state.username}</span>`</span>);
  };

  render() {
    <span class="hljs-keyword">return</span> (
      &lt;form method="post" onSubmit={this.submitForm}&gt;
        &lt;p&gt;Dein Benutzername: {this.state.username}&lt;/p&gt;
        &lt;p&gt;
          &lt;input type="text" name="username" onChange={this.changeUsername} /&gt;
          &lt;input type="submit" disabled={!this.state.isValid} /&gt;
        &lt;/p&gt;
      &lt;/form&gt;
    );
  }
}</code></pre>
<p>Hier sehen wir ein einfaches Textfeld in das der Benutzer einen gewünschten Benutzernamen eintragen kann. Die <code>Uncontrolled</code> Komponente wird mittels <code>onChange</code>-Event von jeder Änderung in Kenntnis gesetzt und kann den Benutzernamen weiterverarbeiten. Da React hier nur <strong>passiv</strong> agiert, also bei einer Änderung am Textfeld über den neuen Wert in Kenntnis gesetzt wird, bewegen wir uns immer noch im Bereich der <strong>Uncontrolled Components</strong>.</p>
<p>Dies ist in einigen Fällen ausreichend, insbesondere wenn die Formulare noch nicht all zu komplex sind. Allerdings ist der React-State hier vom DOM State <strong>entkoppelt</strong> bzw. funktioniert nur <strong>in eine Richtung</strong>. Der React State wird aktualisiert sobald der <code>onChange</code>-Event des Textfelds ausgelöst wird. Allerdings bedeutet dies, dass nicht gleichzeitig auch unser Textfeld aktualisiert wird wenn der Wert im React State an anderer Stelle verändert wurde, bspw. weil der Response eines asynchronen Requests nach einiger Zeit eintrifft.</p>
<p>Ein Formularfeld gilt als <strong>kontrolliert</strong>, sobald ein <code>value</code>-Attribut gesetzt wird. Ab diesem Moment erwartet React, dass wir uns als Entwickler selbst darum kümmern den React-State mit dem Formularfeld zu synchronisieren. Möchten wir allerdings nur einmalig einen initialen Wert setzen ohne gleich die ganze Komponente zu einer <strong>Controlled Component</strong> zu machen, haben wir die Möglichkeit statt des <code>value</code>-Attributs das React eigene <code>defaultValue</code>-Attribut zu setzen (<code>defaultChecked</code> bei Checkboxen und Radiobuttons). Das Element bleibt dann weiterhin <strong>unkontrolliert</strong>, zeigt aber dennoch einen vorausgefüllten Wert (bzw. Status) an.</p>
<h2 id="controlled-components--kontrollierte-komponenten">Controlled Components / kontrollierte Komponenten</h2>
<p>Um sowohl State-Updates in Formularfeldern zu abzubilden als auch auf der anderen Seite benutzerseitige Änderungen an Formularfeldern in den React-State zu übertragen, benötigen wir eine <strong>Controlled Component</strong>. Hier überlassen wir das State-Handling eines Formular-Elements vollständig React. Dies bedeutet, dass wir das <code>value</code>-Attribut mit einem Wert befüllen den wir aus dem React-State beziehen und gleichzeitig auch einen geänderten Wert wieder zurück in den React-State überführen.</p>
<p>Das Ziel bei diesem Ansatz ist es, den React-State (oder einen anderen State-Container wie z.B. Redux) als <strong>Single Source of Truth</strong> zu betrachten, also als die <em>einzige Quelle der Wahrheit</em>. Relevant ist der Wert der im von React verwalteten State steht, das jeweilige Eingabefeld reflektiert dann zu jedem Zeitpunkt den Wert aus diesem State.</p>
<p>Schauen wir uns auch hierzu mal ein Beispiel an:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Controlled</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">username</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">isValid</span>: <span class="hljs-literal">false</span>,
  };

  changeUsername = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> { value } = e.target;
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      <span class="hljs-attr">username</span>: value,
      <span class="hljs-attr">isValid</span>: value.length &gt; <span class="hljs-number">3</span>,
    }));
  };

  submitForm = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    e.preventDefault();
    alert(<span class="hljs-string">`Hallo <span class="hljs-subst">${<span class="hljs-keyword">this</span>.state.username}</span>`</span>);
  };

  render() {
    <span class="hljs-keyword">return</span> (
      &lt;form method="post" onSubmit={this.submitForm}&gt;
        &lt;p&gt;{username}&lt;/p&gt;
        &lt;p&gt;
          &lt;input
            type="text"
            name="username"
            onChange={this.changeUsername}
            value={this.state.username}
          /&gt;
          &lt;input type="submit" disabled={!this.state.isValid} /&gt;
        &lt;/p&gt;
      &lt;/form&gt;
    );
  }
}</code></pre>
<p>Auf den ersten Blick unterscheidet sich die <code>Controlled</code> Komponente gar nicht sonderlich von der <code>Uncontrolled</code> Komponente im Absatz oben. Und tatsächlich ist der entscheidende Faktor der die unkontrollierte Komponente zu einer kontrollierten werden lässt einzig und allein das <code>value</code>-Attribut des <code>&lt;input /&gt;</code>-Elements. Ist ein solches vorhanden <strong>kontrolliert</strong> React das Formular-Element und erwartet, dass sich Änderungen am Eingabefeld entsprechend im State widerspiegeln. Wichtig ist außerdem der <code>onChange</code>-Handler, um den Wert bei einer Änderung jeweils in den React-State zu übertragen. Ein gern gemachter Fehler wenn das erste Mal mit Formularen in React gearbeitet wird ist, entsprechende Eingabefelder nicht mit dem React-State zu synchronisieren indem der neue Wert in den State geschrieben wird. Das Eingabefeld verändert sich dann nicht und zeigt weiterhin den alten Wert aus <code>this.state</code> an.</p>
<p>Hier gibt es noch einige weitere Dinge zu beachten. So darf der Wert des <code>value</code>-Attributes immer nur ein <strong>String</strong> sein, niemals <code>undefined</code> oder <code>null</code>.</p>
<p class="has-image"><span><img src="./assets/.gitbook/react-uncontrolled-null.png" alt="Warnung bei einem kontrollierten Textfeld mit dem value &quot;null&quot;" /><span class="caption">Warnung bei einem kontrollierten Textfeld mit dem value &quot;null&quot;</span></span></p>
<p>Eine Ausnahme sind hier <code>select</code>-Elemente die ein <code>multiple</code>-Attribut besitzen. Hier <strong>muss</strong> das <code>value</code>-Attribut ein <strong>Array</strong> sein.</p>
<p>Moment mal, denkt ihr euch jetzt vielleicht. Welches <code>value</code>-Attribut beim <code>&lt;select&gt;</code>? Optionen selektiere ich doch, indem ich das <code>selected</code>-Attribut bei der jeweiligen <code>&lt;option&gt;</code> setze! Und ja, das ist korrekt in HTML, in React funktioniert das ein klein wenig anders. Hier wird der kontrollierte Wert ebenfalls über das <code>value</code>-Attribut gesetzt. Dasselbe gilt übrigens auch für das <code>&lt;textarea&gt;</code>-Element, dessen Initialwert für gewöhnlich durch seinen <code>textContent</code> bestimmt wird. Nicht so in React.</p>
<p>React vereinheitlicht hier den Mechanismus zum ändern von Werten etwas und erfordert für die drei Elemente <code>input</code> (alle Typen mit Ausnahme <code>checkbox</code> und <code>radio</code>), <code>textarea</code> und <code>select</code> ein <code>value</code>-Attribut! Bei einfachen Werten muss dies <strong>immer ein String</strong> sein, bei einer Auswahlliste mit dem <code>multiple</code>-Attribut wie eben erwähnt ein <strong>Array bestehend aus Strings</strong>!</p>
<p>Darüber hinaus muss eine Änderung eines Formular-Elements <strong>immer auch zurück in den React-State übertragen werden</strong>. Dies kann mitunter etwas mühsam werden, insbesondere bei Checkboxen und Radiobuttons, bei denen nicht lediglich ein Wert geändert wird sondern der Status (<code>checked</code>) zu einem Wert.</p>
<p>Im folgenden möchte ich eine vollständig kontrollierte Komponente zeigen, die alle Grundtypen von Formular-Elementen die HTML beinhaltet (andere <code>input</code>-Elemente vom vom Typ <code>email</code>, <code>date</code>, <code>range</code>, etc. funktionieren identisch wie Eingabefelder vom Typ <code>text</code>).</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FullyControlledComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">text</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">textarea</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">checkbox</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">singleSelect</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">multipleSelect</span>: [],
  };

  changeValue = <span class="hljs-function">(<span class="hljs-params">{ target: { name, value } }</span>) =&gt;</span> {
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      [name]: value,
    }));
  };

  changeCheckbox = <span class="hljs-function">(<span class="hljs-params">{ target: { name, checked } }</span>) =&gt;</span> {
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      [name]: checked,
    }));
  };

  changeSelect = <span class="hljs-function">(<span class="hljs-params">{ target: { name, value, selectedOptions, multiple } }</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (multiple) {
      value = <span class="hljs-built_in">Array</span>.from(selectedOptions).map(<span class="hljs-function">(<span class="hljs-params">option</span>) =&gt;</span> option.value);
    }

    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      [name]: value,
    }));
  };

  render() {
    <span class="hljs-keyword">return</span> (
      &lt;form&gt;
        &lt;input
          type="text"
          name="text"
          value={this.state.text}
          onChange={this.changeValue}
        /&gt;

        &lt;textarea
          name="textarea"
          value={this.state.textarea}
          onChange={this.changeValue}
        /&gt;

        &lt;input
          type="checkbox"
          name="checkbox"
          checked={this.state.checkbox}
          onChange={this.changeCheckbox}
        /&gt;

        &lt;input
          type="radio"
          name="radio"
          value="1"
          checked={this.state.radio === '1'}
          onChange={this.changeValue}
        /&gt;
        &lt;input
          type="radio"
          name="radio"
          value="2"
          checked={this.state.radio === '2'}
          onChange={this.changeValue}
        /&gt;

        &lt;select
          name="singleSelect"
          value={this.state.singleSelect}
          onChange={this.changeValue}
        &gt;
          &lt;option value=""&gt;Bitte auswählen&lt;/option&gt;
          &lt;option value="1"&gt;One&lt;/option&gt;
          &lt;option value="2"&gt;Two&lt;/option&gt;
        &lt;/select&gt;

        &lt;select
          name="multipleSelect"
          value={this.state.multipleSelect}
          onChange={this.changeSelect}
          multiple
        &gt;
          &lt;option value="1"&gt;One&lt;/option&gt;
          &lt;option value="2"&gt;Two&lt;/option&gt;
        &lt;/select&gt;

        &lt;pre&gt;{JSON.stringify(this.state, null, 2)}&lt;/pre&gt;
      &lt;/form&gt;
    );
  }
}</code></pre>
<p>Kern des Formulars sind erst einmal die drei Event-Handler Methoden für die verschiedenen Formular-Element Typen: <code>changeValue</code>, <code>changeCheckbox</code> und <code>changeSelect</code>.</p>
<p>Sie werden jeweils beim onChange-Event der jeweiligen Formular-Elemente aufgerufen und bekommen ein Objekt vom Typ <code>SyntheticEvent</code> übergeben. Aus dessen <code>target</code>-Eigenschaft picken wir uns mittels <strong>ES2015 Object Destructuring</strong> wiederum einzelne Eigenschaften heraus um damit anschließend den State entsprechend zu aktualisieren.</p>
<p>Bei Elementen vom Typ <code>&lt;input type="text" /&gt;</code>, <code>&lt;input type="radio" /&gt;</code> und <code>&lt;textarea /&gt;</code> sind das <code>name</code>und <code>value</code>, bei <code>&lt;input type="checkbox" /&gt;</code> interessiert uns der <code>name</code> und die <code>checked</code>-Eigenschaft, bei <code>select</code>-Elementen interessiert uns in jedem Fall auch der <code>name</code> und dann, abhängig davon ob es eine einfache Auswahlliste ist oder eine Auswahlliste mit Mehrfachauswahl, wieder der <code>value</code>oder die <code>selectedOptions</code>. Ob wir eine es mit einer einfachen oder mehrfachen Auswahlliste zu tun haben finden wir mittels der <code>multiple</code>-Eigenschaft heraus, die wir uns ebenfalls aus der <code>e.target</code>-Eigenschaft herauspicken.</p>
<h3 id="veränderung-von-werten">Veränderung von Werten</h3>
<p>Wird ein Wert verändert, wie es bei Text-Eingabe oder Radiobuttons der Fall ist, setzen wir eine gleichnamige State-Eigenschaft auf den jeweiligen Wert, den der Benutzer eingegeben hat und mit dem er den <code>onChange</code>-Event getriggert hat. Da wir uns in einer kontrollierten Komponente befinden, funktioniert nun folgendes:</p>
<ol>
<li>Der Benutzer ändert mittels Texteingabe den Wert</li>
<li>Ein <code>onChange</code>-Event wird ausgelöst und im Event-Handler verarbeitet</li>
<li>Der Event-Handler setzt die State-Eigenschaft auf den neuen Wert</li>
<li>React re-rendert das User Interface und setzt die <code>value</code>-Eigenschaft des Eingabefelds auf den neuen Wert aus <code>this.state</code>.</li>
<li>Der Benutzer sieht seinen neu eingegebenen Wert.</li>
</ol>
<p>Für den Benutzer ist dies erstmal <strong>Business as Usual</strong>. Er bemerkt nicht, dass das Formular anders funktioniert als er das aus dem Browser kennt. Und doch hat sich hier React um die Logik im Hintergrund gekümmert und einen neuen „Frame“ im User Interface gezeichnet.</p>
<h3 id="veränderung-von-zuständen-bei-checkboxen-und-radiobuttons">Veränderung von Zuständen bei Checkboxen und Radiobuttons</h3>
<p>Checkboxen (<code>&lt;input type="checkbox" /&gt;</code>) funktionieren hier vom Ablauf im Hintergrund genauso, allerdings mit dem Unterschied das ihr Wert grundsätzlich gleich bleibt. Bei Checkboxen ändert sich statt des Werts der Zustand ihrer <code>checked</code>-Eigenschaft von <code>true</code> auf <code>false</code> oder andersherum. Sie gelten daher dann als kontrolliert, wenn ihre <code>checked</code>-Eigenschaft durch React gesteuert wird. Der <code>onChange</code>-Event bei Checkboxen teilt uns mittels <code>e.target.checked</code> mit, ob die eben geänderte Checkbox nun aktiviert (<code>true</code>) oder nicht aktiviert (<code>false</code>) ist. Diesen Status geben wir unverändert an den React-State weiter, React kümmert sich dann im Re-Rendering darum, dass der neue Status der Checkbox angezeigt wird.</p>
<p>Radiobuttons sind eine Art Hybrid-Element. Sie gelten wie Checkboxen ebenfalls als kontrolliert wenn ihr <code>checked</code>-Attribut durch React verwaltet wird. Allerdings gibt es für gewöhnlich mehrere Radiobuttons mit dem selben Namen, allerdings mit unterschiedlichen Werten in einem Dokument. Hier würde es also keinen Sinn machen den Wert zu einem Namen auf <code>true</code> oder <code>false</code> zu setzen, da uns der tatsächliche Wert des ausgewählten Radiobuttons interessiert. Hier schreiben wir also wie bei Text-Elementen den Wert des Radiobuttons in den State und prüfen dann beim Rendering des jeweiligen Radiobuttons selbst, ob der ausgewählte Wert aus dem State dem eigenen Wert entspricht: <code>checked={this.state.radio === "1"}</code>. Also in diesem Beispiel: setze <code>checked</code> auf <code>true</code> wenn der Wert eines Radiobuttons mit dem Namen <code>radio</code> gleich <code>1</code> ist.</p>
<h3 id="veränderung-des-status-bei-einfachen-oder-mehrfachen-auswahllisten">Veränderung des Status bei einfachen oder mehrfachen Auswahllisten</h3>
<p>Fangen wir mit dem einfachen Fall an: einfache <code>&lt;select&gt;</code>-Auswahllisten ändern ebenfalls wie Textfelder ihren Wert, lösen damit ein Re-Rendering aus und zeigen den ausgewählten Wert im neu gezeichneten User Interface an. Eine Ausnahme stellen hier mehrfache Auswahllisten dar.</p>
<p>Mehrfache Auswahllisten erwarten anders als Textfelder oder einfache Auswahllisten keinen String als Wert, sondern ein <strong>Array aus Strings</strong>. Diesen müssen wir uns allerdings selbst zusammenbasteln, da <code>e.target.value</code> bei Mehrfach-Auswahllisten nur einen einzigen Wert enthält, selbst bei der Auswahl mehrerer Optionen. Hier hilft uns <code>e.target.selectedOptions</code> weiter. Diese Eigenschaft ist ein Objekt vom Typ <code>HTMLCollection</code>, mit den <code>&lt;option&gt;</code>-Elementen die momentan ausgewählt sind. Dieses Objekt können wir mit der statischen Array-Methode <code>Array.from()</code> aus ES2015 ziemlich einfach in ein Array umwandeln. Indem wir mittels <code>Array.map()</code> über dieses iterieren, können wir außerdem ein neues Array erzeugen, das alle für uns relevanten Werte enthält:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-built_in">Array</span>.from(selectedOptions).map(<span class="hljs-function">(<span class="hljs-params">option</span>) =&gt;</span> option.value);</code></pre>
<p>Das so erzeugte, neue Array schreiben wir dann als neuen Wert in unseren State. Zuvor schauen wir jedoch erst einmal mittels <code>e.target.multiple</code> ob es sich überhaupt um ein <code>&lt;select&gt;</code> mit Mehrfachauswahl handelt, da nur dieses ein Array als <code>value</code> erwartet.</p>
<p>Alternativ wäre es natürlich auch möglich einfachen Auswahllisten die <code>changeValue</code>-Methode als Event-Handler zu übergeben und nur Mehrfach-Auswahllisten die <code>changeSelect</code>-Methode. Dann könnten wir uns in selbiger den Check sparen ob es sich um ein <code>multiple</code> Select handelt. Es auf die obigen Weise zu lösen hat aber den Vorteil, dass später der Typ von mehrfach auf einfach geändert werden könnte ohne dass man zusätzlich noch den Event-Handler ändern muss. Aber das bleibt am Ende natürlich euch selbst überlassen.</p>
<h3 id="besonderheiten-bei-kontrollierten-komponenten">Besonderheiten bei kontrollierten Komponenten</h3>
<p>Ich habe in den obigen Beispielen jeweils das <code>name</code>-Attribut der jeweiligen Elemente als Schlüssel benutzt um deren Wert im State zu speichern. Das ist insbesondere dann praktisch wenn man mit serverseitigem React arbeitet und bspw. Formulare auf Basis eines Datenbankschemas automatisch generiert und wieder verarbeitet. Voraussetzung für eine funktionierende kontrollierte Komponente ist das aber nicht. Es wird theoretisch weder ein <code>name</code>-Attribut benötigt noch muss schlussendlich der Name der State-Eigenschaft mit dem <code>name</code>-Attribut übereinstimmen.</p>
<p>Ihr könnt die gespeicherten Werte auch verschachteln, was sich anbietet wenn ihr in einer Komponente mehrere Formulare haben solltet (<strong>Achtung:</strong> React Antipattern!). Darüber hinaus muss nicht einmal zwingend der React-State verwendet werden um <strong>Controlled Components</strong> abzubilden. Im Gegenteil, in der Praxis wird stattdessen oftmals auch auf einen externen State-Container wie <strong>Redux</strong>, <strong>Unstated</strong> oder <strong>MobX</strong> zurückgegriffen.</p>
<h2 id="fazit">Fazit</h2>
<div class="hint hint--info">
<p>Formulare in React können in (von React) kontrollierter oder unkontrollierter Form auftreten.</p>
<p><strong>Unkontrollierte Komponenten</strong> reichen für simple Formulare oftmals aus, allerdings empfiehlt es sich, Formular-Komponenten von React kontrollieren zu lassen um eine <strong>Single Source of Truth</strong> zu haben. Dazu muss das <code>value</code> bzw. <code>checked</code>-Attribut von React verwaltet werden. Auf Entwicklerseite muss dann manuell auf Änderungen reagiert werden.</p>
<p>Anders als in herkömmlichem HTML erwartet React den Wert von Textareas, Selects und Inputfeldern mit Texteingabe im <code>value</code>-Attribut.</p>
</div>
</div>
<div class="chapter">
  <h1 id="listen-fragments-und-conditional-rendering">Listen, Fragments und Conditional Rendering</h1>
<p>Bis hier her habt ihr schon eine ganze Menge über React erfahren. Ihr wisst wofür die <strong>Props</strong> sind, was der <strong>State</strong> ist und wie er sich von den <strong>Props</strong> unterscheidet, ihr wisst wie eine React-Komponente implementiert wird, was der Unterschied einer React-<strong>Komponente</strong> und einem React-<strong>Element</strong> ist und wie ihr mit <strong>JSX</strong> einen Elementenbaum beschreibt, der später in eurer Anwendung gerendert wird. <strong>Lifecycle-Methoden</strong> helfen euch auf Änderungen eurer Daten zu reagieren. Damit habt ihr auch schon alles beisammen um eine simple React-Anwendung zu entwickeln.</p>
<p>Allerdings gibt es noch einige Details, die in den vorherigen Kapiteln bisher gar keine Erwähnung fanden oder ohne weitere Erklärung in Beispielen benutzt wurden, die aber, gerade wenn eure Anwendung anfängt komplexer zu werden zunehmend relevanter werden.</p>
<p>Im Speziellen betrifft das die Arbeit mit <strong>Listen</strong>, also Arrays mit Daten, sogenannte <strong>Refs</strong>, damit sind Referenzen zu DOM-Repräsentationen von React-Elementen gemeint, <strong>Fragments</strong>, eine spezielle Art Komponente, die keine Spuren im gerenderten Output hinterlässt und <strong>Conditional Rendering</strong>, also Unterscheidungsmöglichkeiten, wann ihr was rendert, basierend auf <strong>Props</strong> und <strong>State</strong>.</p>
<p>Die Themen haben eins gemeinsam: sie sind zu wichtig um sie nicht im Grundlagenteil dieses Buchs zu erwähnen aber gleichzeitig zu kurz um ihnen jeweils ein komplettes eigenes Kapitel zu widmen.</p>
<h2 id="listen">Listen</h2>
<p>Mit Listen sind hier tatsächlich stumpfe JavaScript-Arrays gemeint, also einfache <strong>Daten</strong>, durch die iteriert werden kann. Sie sind bei der Arbeit nicht nur mit React alltäglich und keine Anwendung kommt ohne sie aus. <strong>ES2015+</strong> bietet uns mit <code>Array.map()</code>, <code>Array.filter()</code> oder <code>Array.find()</code> schöne deklarative Methoden, die wir als Ausdrücke in JSX innerhalb von geschweiften Klammern <code>{}</code> nutzen können.</p>
<p>Welche Rolle Ausdrücke in JSX spielen und wie wir Ausdrücke in JSX nutzen können, habe ich bereits im Kapitel über JSX angesprochen. Kurz aufgefrischt: Arrays können als Ausdruck in JavaScript genutzt werden und somit auch in JSX. Das heißt sie können in geschweiften Klammern stehen und werden dann von beim Transpiling von JSX als Child-Node behandelt.</p>
<p>Das ist aber noch nicht alles, denn <code>Array.map()</code> kann bspw. modifizierte Items zurückgeben, die selbst wiederum JSX beinhalten. Das ist insofern praktisch, als dass es uns weitere Flexibilität verschafft und es uns ermöglicht Datensammlungen in React-Elemente zu verwandeln.</p>
<p>Nehmen wir als Beispiel an, wir wollen eine Liste aus Cryptocurrencies anzeigen. Unser Array mit den entsprechenden Daten hat die folgende Form:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> cryptos = [
  {
    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Bitcoin'</span>,
    <span class="hljs-attr">symbol</span>: <span class="hljs-string">'BTC'</span>,
    <span class="hljs-attr">quotes</span>: { <span class="hljs-attr">EUR</span>: { <span class="hljs-attr">price</span>: <span class="hljs-number">7179.92084586</span> } },
  },
  {
    <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Ethereum'</span>,
    <span class="hljs-attr">symbol</span>: <span class="hljs-string">'ETH'</span>,
    <span class="hljs-attr">quotes</span>: { <span class="hljs-attr">EUR</span>: { <span class="hljs-attr">price</span>: <span class="hljs-number">595.218568203</span> } },
  },
  {
    <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Litecoin'</span>,
    <span class="hljs-attr">symbol</span>: <span class="hljs-string">'LTC'</span>,
    <span class="hljs-attr">quotes</span>: { <span class="hljs-attr">EUR</span>: { <span class="hljs-attr">price</span>: <span class="hljs-number">117.690716234</span> } },
  },
];</code></pre>
<p>Dargestellt werden sollen die Daten erst einmal als einfache ungeordnete Liste in simplen HTML. Die entsprechende Komponente könnte dann zum Beispiel so aussehen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> CryptoList = <span class="hljs-function">(<span class="hljs-params">{ currencies }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    {currencies.map((currency) =&gt; (
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>
          {currency.name} ({currency.symbol})
        <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{currency.quotes.EUR.price.toFixed(2)} €<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    ))}
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
);</code></pre>
<p>Und würde dann etwa so benutzt werden:</p>
<pre><code class="hljs jsx language-jsx">&lt;CryptoList currencies={cryptos} /&gt;</code></pre>
<p>Heraus kommt eine Liste mit den entsprechenden Kryptowährungen und ihrem jeweiligen Preis. Allerdings bekommen wir auch direkt eine Warnung von React an den Kopf geworfen:</p>
<p class="has-image"><span><img src="./assets/.gitbook/react-missing-key.png" alt="Fehlermeldung bei fehlender key-Prop in einer durch einen Iterator erzeugten Liste" /><span class="caption">Fehlermeldung bei fehlender key-Prop in einer durch einen Iterator erzeugten Liste</span></span></p>
<p>React erwartet bei allen Arrays und von einem Iterator zurückgegebenen Werten eine <code>key</code>-Prop. Diese dient dazu dem Reconciler (also dem React-Vergleichsalgorithmus) eine Möglichkeit zu geben, um Listen-Elemente zu identifizieren und letztendlich vergleichen zu können. Der Reconciler erkennt dadurch welche Array-Elemente hinzugefügt, entfernt oder modifiziert wurden. Die <code>key</code>-Prop nimmt dabei die Funktion einer eindeutigen ID ein und muss <strong>innerhalb dieses Arrays einmalig</strong> sein. In der Praxis wird hier typischerweise die ID eines Datensatzes verwendet.</p>
<p>In unserem Fall haben wir eine solche ID vorliegen, das oberste Element das aus der <code>map()</code>-Methode zurückgegeben wird würde also korrekt so aussehen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> CryptoList = <span class="hljs-function">(<span class="hljs-params">{ currencies }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    {currencies.map((currency) =&gt; (
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{currency.id}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>
          {currency.name} ({currency.symbol})
        <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{currency.quotes.EUR.price.toFixed(2)} €<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    ))}
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
);</code></pre>
<p>Der Key muss dabei nur <strong>innerhalb eines Arrays/Iterators inmitten seiner Geschwister-Elemente einmalig sein, nicht innerhalb der Komponente!</strong> Dies bedeutet, dass wir die gleiche <code>CryptoList</code>-Komponente mit den gleichen Keys an anderer Stelle, auch in der gleichen Komponente, problemlos noch ein zweites Mal verwenden könnten. Nur eben nicht innerhalb dieses einen Loops.</p>
<p>Sind zu einer Liste aus Datensätzen keine eindeutigen Schlüssel vorhanden, kann als letzter Ausweg der <strong>Index</strong> des Array-Elements verwendet werden. Davon wird jedoch <strong>ausdrücklich abgeraten</strong>, da dies zu Problemen bei der Performance sowie zu unvorhersehbarem Verhalten beim Rendering des User Interfaces führen kann.</p>
<p>Wichtig ist außerdem, dass die <code>key</code>-Prop immer <strong>direkt in der von der Iterator-Funktion</strong> zurückgegebenen <strong>Toplevel-Komponente</strong> oder dem <strong>Array-Element</strong> vorhanden sein muss, nicht in der von dieser Komponente zurückgegebenen JSX.</p>
<p>Um besser zu veranschaulichen was das genau bedeutet, machen wir aus unserem obigen Listen-Element eine eigene kleine <code>CryptoListItem</code>-Komponente:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> CryptoListItem = <span class="hljs-function">(<span class="hljs-params">{ name, symbol, quotes }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>
      {name} ({symbol})
    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{quotes.EUR.price.toFixed(2)} €<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
);</code></pre>
<p>Was fällt auf? Richtig: die <code>key</code>-Prop die wir zuvor hinzugefügt haben ist nun nicht mehr da. Unser <code>map()</code>-Aufruf würde sich dafür wie folgt verändern:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> CryptoList = <span class="hljs-function">(<span class="hljs-params">{ currencies }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    {currencies.map((currency) =&gt; (
      <span class="hljs-tag">&lt;<span class="hljs-name">CryptoListItem</span>
        <span class="hljs-attr">key</span>=<span class="hljs-string">{currency.id}</span>
        <span class="hljs-attr">name</span>=<span class="hljs-string">{currency.name}</span>
        <span class="hljs-attr">symbol</span>=<span class="hljs-string">{currency.symbol}</span>
        <span class="hljs-attr">quotes</span>=<span class="hljs-string">{currency.quotes}</span>
      /&gt;</span>
    ))}
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
);</span></code></pre>
<p>Obwohl es das <code>&lt;li&gt;&lt;/li&gt;</code>-Element ist welches letztendlich gerendert wird, muss dennoch die <code>&lt;CryptoListItem /&gt;</code>-Komponente die <code>key</code>-Prop bekommen, da sie es ist, die von <code>Array.map()</code> an der entsprechenden Stelle im JSX zurückgegeben wird.</p>
<p>Offtopic: die <code>CryptoList</code>-Komponente könnte durch Verwendung der <strong>Object-Spread Syntax</strong> weiter vereinfacht werden:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> CryptoList = <span class="hljs-function">(<span class="hljs-params">{ currencies }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    {currencies.map((currency) =&gt; (
      <span class="hljs-tag">&lt;<span class="hljs-name">CryptoListItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{currency.id}</span> {<span class="hljs-attr">...currency</span>} /&gt;</span>
    ))}
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
);</span></code></pre>
<p>Auf diese Art werden alle Eigenschaften des <code>currency</code>-Objekts entsprechend als gleichnamige Props an die <code>CryptoListItem</code>-Komponente übertragen.</p>
<p>Bei der direkten Arbeit mit Arrays, ohne einen Iterator wie <code>Array.map()</code> sähe das analog dazu so aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> MyList = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    {[<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"1"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"2"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"3"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>]}
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
);</code></pre>
<h2 id="fragments">Fragments</h2>
<p>Fragments sind eine Art Spezial-Komponente und dienen hilfsweise dazu gültiges JSX zu erzeugen ohne dabei sichtbare Spuren in der gerenderten Ausgabe zu hinterlassen. Gültiges JSX in dem Sinne, als das die <code>render()</code>-Methode immer nur ein Element auf oberster Ebene zurückgeben darf. Also etwa:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Bullet Point 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Bullet Point 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Bullet Point 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
  );
}</code></pre>
<p>Aber eben nicht so etwas wie:</p>
<pre><code class="hljs jsx language-jsx">render() {
  return (
    &lt;li&gt;Bullet Point 1&lt;/li&gt;
    &lt;li&gt;Bullet Point 2&lt;/li&gt;
    &lt;li&gt;Bullet Point 3&lt;/li&gt;
  );
}</code></pre>
<p>Hier geben wir aus der <code>render()</code>-Methode direkt und ohne umschließendes Eltern-Element mehrere <code>li</code>-Elemente zurück, was zu einer Fehlermeldung führt. Manchmal ist dies aber notwendig, bspw. wenn sich das umschließende Element in einer Eltern-Komponente befinden soll, die Kind-Elemente aber durch eine eigene Komponente erzeugt werden soll.</p>
<p>Innerhalb einiger Elemente (<code>table</code>, <code>ul</code>, <code>ol</code>, <code>dl</code>, …) ist es aber nicht erlaubt bspw. ein <code>div</code>-Element als Zwischenebene zu verwenden, um die Regel zu erfüllen stets nur ein einzelnes Root-Element aus einer Komponente zurückzugeben. In diesem Fall kommt das Fragment ins Spiel und würde angewendet auf das obige Beispiel folgende Änderung bedeuten um valides JSX zu erzeugen:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Bullet Point 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Bullet Point 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Bullet Point 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span>
  );
}</span></code></pre>
<p>Dabei gilt auch hier die Regel, dass iterativ, also durch eine Schleife, erzeugte Ausgabe eine key-Prop besitzen muss. Mit der Fragment Helper-Komponente ist dies möglich. Schauen wir uns ein weiteres, etwas umfassenderes und praxisnäheres Beispiel an:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> TicketMeta = <span class="hljs-function">(<span class="hljs-params">{ metaData }</span>) =&gt;</span> (
  &lt;dl&gt;
    {Object.entries(metaData).map(([property, value]) =&gt; (
      &lt;React.Fragment key={property}&gt;
        &lt;dt&gt;{property}&lt;/dt&gt;
        &lt;dd&gt;{value}&lt;/dd&gt;
      &lt;/React.Fragment&gt;
    ))}
  &lt;/dl&gt;
);

ReactDOM.render(
  &lt;TicketMeta
    metaData={{
      createdAt: '2018-06-09',
      author: 'Manuel Bieh',
      category: 'General',
    }}
  /&gt;,
  document.getElementById('root')
);</code></pre>
<p>Die so erzeugte Ausgabe wäre die folgende:</p>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>createdAt<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>2018-06-09<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>author<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>Manuel Bieh<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>category<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>General<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span></code></pre>
<p>Hier wäre es beispielsweise nicht möglich ein <code>div</code> oder <code>span</code> oder ein sonstiges Element um <code>&lt;dt&gt;&lt;dt&gt;</code> und <code>&lt;dd&gt;&lt;/dd&gt;</code> zu wrappen. Dies würde zu folgender Ausgabe führen:</p>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>createdAt<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>2018-06-09<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>author<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>Manuel Bieh<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>category<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>General<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span></code></pre>
<p>… und wäre damit ungültiges HTML, da ein <code>dl</code>-Element nur <code>dt</code> und <code>dd</code> als Kind-Element erlaubt. Das Fragment hilft uns hier also gültiges JSX zu erzeugen, ohne dabei gleichzeitig das HTML ungültig werden zu lassen. Dies war in React bis zur Einführung von Fragments in Version 16.3. ein Problem was dazu führte, dass Komponenten unnötig kompliziert implementiert werden mussten um weder gegen JSX- noch gegen HTML-Regeln zu verstoßen.</p>
<p><em>[<strong>TODO</strong>: sprachlich eine Katastrophe. Vielleicht nochmal den einen oder anderen Satz glatt ziehen und Beispiele und Erklärungen zur Short Syntax &lt;&gt;&lt;/&gt; einfügen]</em></p>
<h2 id="conditional-rendering">Conditional Rendering</h2>
<p><strong>Conditional Rendering</strong>, also das Rendering von Komponenten auf Basis verschiedener Bedingungen ist ein zentrales Konzept in React. Da React-Komponenten unter der Haube lediglich eine Komposition aus JavaScript-Funktionen, -Objekten und -Klassen sind, funktionieren und verhalten sich Bedingungen hier exakt wie auch in herkömmlichem JavaScript.</p>
<p>Eine React-Komponente rendert <strong>Zustände</strong> eines <strong>User Interfaces</strong> basierend auf ihren <strong>Props</strong> und ihrem <strong>aktuellen State</strong>, optimalerweise <strong>frei von Seiten-Effekten.</strong> Um also korrekt auf diese verschiedenen Parameter reagieren zu können machen wir uns Rendering-Funktionen zu nutze, die an verschiedene Bedingungen geknüpft sind. Ist mein Parameter A, rendere dies, ist mein Parameter B, rendere das. Habe ich eine Liste mit Daten, zeige mir die Daten in einer HTML-Liste an. Habe ich keinerlei Daten, zeige mir stattdessen einen Platzhalter an.</p>
<p>Was einfach klingt, ist es im Grunde genommen auch. Aber man sollte die richtigen Wege kennen, insbesondere in JSX. Die <code>render()</code>-Funktion von Komponenten, also sowohl von <strong>Class Components</strong> als auch <strong>Stateless Functional Components</strong> kann grundsätzlich ein <strong>React-Element</strong> (natürlich auch in Form von JSX), einen <strong>String</strong>, eine <strong>Nummer</strong>, <code>null</code>, für den Fall, dass nichts gerendert werden soll oder ein <strong>Array</strong> aus den zuvor genannten Typen zurückgeben.</p>
<p>Darüber hinaus gibt es einige Möglichkeiten die <code>render()</code>-Methoden in den Komponenten übersichtlich zu halten. Diese Möglichkeiten werde ich euch hier vorstellen.</p>
<h3 id="ifelse">if/else</h3>
<p>Die wohl einfachste und wahrscheinlich auch gängigste Form des <strong>Conditional Renderings</strong> ist ein klassisches <code>if</code>/<code>else</code>-Konstrukt.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> NotificationList = <span class="hljs-function">(<span class="hljs-params">{ items }</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (items.length) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
        {items.map((notification) =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>{notification.title}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        ))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
    );
  }
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Keine neuen Benachrichtigungen<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
};</code></pre>
<p>Einfacher Anwendungsfall. Wir haben eine Komponente <code>NotificationList</code>, die eine Liste an Items in Form einer Prop entgegen nimmt. Enthält diese Liste Einträge, werden diese als simple ungeordnete Liste ausgegeben. Ist die Liste hingegen leer, lassen wir unsere Komponente stattdessen eben einen Hinweis ausgeben, dass keine neuen Benachrichtigungen vorhanden sind.</p>
<p>Ein weiteres Beispiel mit einem komplexeren Fall. Wir haben einen Wert und möchten diesen editierbar machen. Unsere Komponente kennt zwei verschiedene Modi: <code>edit</code> und <code>view</code>. Je nachdem ob wir uns <strong>View-Mode</strong> oder im <strong>Edit-Mode</strong> befinden, möchten wir nur den Text anzeigen oder ein vorausgefülltes Textfeld mit dem jeweiligen letzten aktuellen Wert.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { render } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EditableText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span>,
  };

  <span class="hljs-keyword">static</span> getDerivedStateFromProps(nextProps, prevState) {
    <span class="hljs-keyword">if</span> (prevState.value === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">value</span>: nextProps.initialValue || <span class="hljs-string">''</span>,
      };
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  handleChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> { value } = e.target;
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      value,
    }));
  };

  setMode = <span class="hljs-function">(<span class="hljs-params">mode</span>) =&gt;</span> () =&gt; {
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      mode,
    }));
  };

  render() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.mode === <span class="hljs-string">'edit'</span>) {
      <span class="hljs-keyword">return</span> (
        &lt;div&gt;
          &lt;input
            type="text"
            value={this.state.value}
            onChange={this.handleChange}
          /&gt;
          &lt;br /&gt;
          &lt;button onClick={this.setMode('view')}&gt;Done&lt;/button&gt;
        &lt;/div&gt;
      );
    }

    return (
      &lt;div&gt;
        {this.state.value}
        &lt;br /&gt;
        &lt;button onClick={this.setMode('edit')}&gt;Edit&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

render(
  &lt;EditableText initialValue="Example" /&gt;,
  document.getElementById('root')
);</code></pre>
<p>Der für dieses Kapitel relevante Teil spielt sich innerhalb der <code>render()</code>-Methode der Komponente ab. Wir prüfen hier auf den Wert der State-Eigenschaft <code>mode</code>, ist dieser <code>edit</code>, geben wir direkt das Eingabefeld zurück („early return“). Ist dieses nicht <code>edit</code>, gehen wir davon aus, dass der „Standardfall“ eintritt, der in diesem Falle der Ansichtsmodus (<code>view</code>) wäre. Der <code>else</code>-Teil der Condition ist hier also gar nicht nötig und würde lediglich unnötig Komplexität hinzufügen. Gerendert wird jeweils der Text, einmal editierbar als <code>value</code> eines <code>input</code>-Felds, einmal lediglich als Textknoten und dazu jeweils ein Button, um die State-Eigenschaft <code>mode</code> der Komponente zwischen <code>view</code> und <code>edit</code> hin und her zu wechseln.</p>
<p>Derartige <code>if</code>, <code>if</code>/<code>else</code> oder <code>if</code>/<code>else if</code>/<code>else</code>-Konstrukte sind in verschiedenen Varianten, auf die ich hier gleich noch eingehen werde, eine häufige Form wenn es darum geht eine Ausgabe auf Basis von <strong>State</strong> und <strong>Props</strong> innerhalb einer Komponente zu erzeugen.</p>
<h3 id="null">null</h3>
<p>Nein, die Überschrift ist kein Fehler. <code>null</code> zurückzugeben ist wohl der einfachste Fall für <strong>Conditional Rendering.</strong> Gibt die <code>render()</code>-Methode einer Komponente <code>null</code> zurück, wird diese nicht gerendert und erscheint daher auch nicht im DOM. Dies kann manchmal sinnvoll sein, bspw. wenn eine Fehler-Komponente nur dann angezeigt werden soll wenn auch ein Fehler aufgetreten ist.</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.state.error) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"error-message"</span>&gt;</span>{this.state.error.message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}</code></pre>
<p>Hier wird geprüft ob im State der Komponente eine error-Eigenschaft gesetzt ist. Ist dies nicht der Fall, wird <code>null</code> zurückgegeben und somit auch nichts gerendert. Existiert die Eigenschaft hingegen, wird die entsprechende Fehlermeldung in einem <code>div</code> ausgegeben, wozu wir wieder auf das Conditional Rendering mit einem einfachen <code>if</code> zurückgreifen.</p>
<h3 id="ternary-operator">Ternary Operator</h3>
<p>Dies waren Beispiele für Bedingungen die relativ grundlegende Unterschiede in ihren Komponenten ausgeben. Oftmals möchte man allerdings nur kleine Unterschiede ausgeben, etwa eine CSS-Klasse hinzufügen wenn ein bestimmter State gesetzt ist. Hier hilft uns der Ternary Operator weiter. Kurze Auffrischung: der <strong>Ternary Operator</strong> ist ein Ausdruck und hat die Form <code>Bedingung ? Erfüllt : Nicht Erfüllt</code>. Also etwa: <code>isLoggedIn ? 'Logout' : 'Login';</code></p>
<p>Und damit hätten wir auch schon unser erstes Beispiel für die Verwendung des <strong>Ternary Operators</strong> innerhalb von JSX. Er kann sowohl innerhalb von Props verwendet werden als auch einfach um, je nach Bedingung, verschiedene Elemente zu rendern. Ein konkreter Anwendungsfall für das eben genannte Beispiel wäre die Ausgabe von Text in Abhängigkeit zu einer Bedingung:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">const</span> { isLoggedIn } = <span class="hljs-keyword">this</span>.props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>{ isLoggedIn ? 'Logout' : 'Login' }<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  );
}</code></pre>
<p>In diesem Fall würden wir stets einen Button ausgeben, dieser hätte aber abhängig von seiner <code>isLoggedIn</code>-Prop entweder die Beschriftung <strong>Logout</strong> oder <strong>Login</strong>.</p>
<p>Genau in der gleichen Form kann der <strong>Ternary Operator</strong> in Props verwendet werden. Nehmen wir an wir wollen ein Liste mit Benutzern ausgeben, von denen einige deaktiviert wurden. In diesem Fall möchten wir eine Klasse setzen um diese mittels CSS markieren zu können. Ein entsprechendes Markup könnte dann bspw. so aussehen:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">const</span> { user } = <span class="hljs-keyword">this</span>.props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{user.isDisabled</span> ? '<span class="hljs-attr">is-disabled</span>' <span class="hljs-attr">:</span> '<span class="hljs-attr">is-active</span>'}&gt;</span>{user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}</code></pre>
<p>Deaktivierte Benutzer würden hier mit einer Klasse <code>is-disabled</code> gekennzeichnet, aktive Benutzer hingegen mit einer Klasse <code>is-active</code>.</p>
<p>Auch komplexeres JSX lässt sich mittels <strong>Ternary Operator</strong> abbilden. Dazu muss lediglich die allgemein gültige Regel befolgt werden, dass sich über mehrere Zeilen erstreckendes JSX in Klammern gefasst werden muss:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">const</span> { country } = <span class="hljs-keyword">this</span>.props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>State:<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      {country === 'de' ? (
        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"state"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"bw"</span>&gt;</span>Baden-Württemberg<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"by"</span>&gt;</span>Bayern<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"be"</span>&gt;</span>Berlin<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"bb"</span>&gt;</span>Brandenburg<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
          […]
        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
      ) : (
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"state"</span> /&gt;</span>
      )}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  );
}</span></code></pre>
<p>In diesem Fall rendern wir also eine Select-Liste mit allen deutschen Bundesländern wenn das zuvor ausgewählte Land <strong>Deutschland</strong> (<code>de</code>) ist, in allen anderen Fällen zeigen wir dem Benutzer nur ein Textfeld an, in das dieser sein entsprechendes Bundesland frei eintragen kann. Hier sollte jedoch immer abgewogen werden ob dies sinnvoll ist, denn der <strong>Ternary Operator</strong> kann insbesondere in komplexerem JSX schnell unübersichtlich werden.</p>
<h3 id="logical-and--und-logical-or-">Logical AND (<code>&amp;&amp;</code>) und Logical OR (<code>||</code>)</h3>
<p>Der <strong>Logical Operator</strong> hat auf den ersten Blick Ähnlichkeit zum <strong>Ternary Operator</strong>, jedoch mit dem Unterschied dass er noch kürzer und prägnanter ist. Anders als beim <strong>Ternary Operator</strong> wird hier kein „zweiter Fall“ benötigt, also ein Wert der verwendet wird, falls die Bedingung nicht erfüllt ist. Ist die Bedingung in einem <strong>Logical AND Operator</strong> nicht erfüllt, ist der Ausdruck <code>undefined</code> und verursacht somit keinerlei sichtbare Ausgabe im User Interface:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">const</span> { isMenuVisible } = <span class="hljs-keyword">this</span>.props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
      { isMenuVisible &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">Menu</span> /&gt;</span> }
    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span>
  );
}</code></pre>
<p>In diesem Fall würde eine Komponente prüfen ob der Wert der <code>isMenuVisible</code>-Prop <code>true</code> ist <strong>und</strong> dann eine <code>Menu</code>-Komponente anzeigen. Ist der Wert <code>false</code>, gibt der Ausdruck <code>undefined</code> zurück und die Komponente rendert dementsprechend keine Ausgabe an dieser Stelle.</p>
<p>In Verbindung mit dem <strong>Logical OR Operator</strong> kann hier ein Fall wie beim <strong>Ternary Operator</strong> herbeigeführt werden:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">const</span> { isLoggedIn } = <span class="hljs-keyword">this</span>.props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>{ isLoggedIn &amp;&amp; 'Logout' || 'Login' }<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  );
}</code></pre>
<p>Die Beschriftung des Buttons ist in diesem Fall <strong>Logout</strong>, wenn die <code>isLoggedIn</code> <strong>Prop</strong> <code>true</code> ist, der Benutzer also eingeloggt ist oder <strong>Login</strong> wenn der Benutzer nicht eingeloggt ist.</p>
<h3 id="eigene-render-methoden">Eigene <code>render()</code>-Methoden</h3>
<p>Eine Möglichkeit um die Übersicht bei <strong>Conditional Rendering</strong> zu erhöhen ist, bestimmte Teile aus der <code>render()</code>-Methode in eigene <code>renderXY()</code>-Methoden zu verfrachten. Die <code>render()</code>-Methode stellt so gesehen den Kern einer Komponente dar, ist sie doch dafür verantwortlich zu entscheiden, was ein Benutzer später auf seinem Bildschirm sieht. Sie sollte also nicht zu komplex werden, nicht unnötig viel Logik enthalten und lesbar sein.</p>
<p>Nicht unüblich ist es daher sehr komplexe und lange <code>render()</code>-Methoden in kleine übersichtliche Häppchen zu unterteilen und als eigene Klassenmethoden zu implementieren. Dies führt bei sinnvoller Benamung der jeweiligen Methoden meist zur Erhöhung und zu besserer Verständlichkeit des Codes. Meist werden die einzelnen <code>render()</code>-Methoden noch mit <code>if</code>-Blöcken kombiniert:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Countdown</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  renderTimeLeft() {
    <span class="hljs-comment">// […]</span>
  }

  renderTimePassed() {
    <span class="hljs-comment">// […]</span>
  }

  render() {
    <span class="hljs-keyword">const</span> { currentDate, eventDate } = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">if</span> (currentDate &lt; eventDate) {
      <span class="hljs-comment">// currentDate is before eventDate so render countdown</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.renderTimeLeft();
    }
    <span class="hljs-comment">// time is over so render how much time has passed since then</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.renderTimePassed();
  }
}</code></pre>
<p>Dies <strong>kann</strong> bei kluger Verwendung die Lesbarkeit einer <code>render()</code>-Methode erhöhen, führt aber unweigerlich auch dazu, dass sich die Komplexität einer Komponente (im etwas geringeren Maß) erhöht. Viele Leute – ich zähle mich dazu – raten daher eher dazu Teile des Codes wiederum in eigene gekapselte <strong>Stateless Functional Components</strong> auszulagern statt <code>renderXY()</code>-Methoden zu verwenden.</p>
<div class="hint hint--info">
<p>Sobald die Überlegung ansteht eine weitere <code>render()</code>-Methode innerhalb einer Komponente zu implementieren sollte darüber nachgedacht werden, stattdessen eine eigene, separate <strong>Stateless Functional Component</strong> zu erstellen.</p>
</div>
<h3 id="eigene-komponenten-bei-komplexen-conditions">Eigene Komponenten bei komplexen Conditions</h3>
<p>Statt weiterer <code>render()</code>-Methoden innerhalb einer Komponente können wie eben bereits angesprochen auch eigene, neue, bevorzugterweise <strong>Stateless Functional Components</strong> erstellt werden. Diese bekommen dann entsprechende <strong>Props</strong> aus ihrer Eltern-Komponente hereingereicht und kümmern sich dann als eigenständige, unabhängige, wiederverwendbare und testbare Komponente um die Anzeige der ihnen übergebenen Daten.</p>
<p>An erster Stelle sollte die Überlegung stehen wie einfach sich die Daten aus der ursprünglichen Eltern-Komponente in die neue(n) Kind-Komponente(n) übertragen lassen und vor allem welche Daten überhaupt in eine neue Komponente ausgelagert werden sollten. Dabei sollte beachtet werden dass die neuen Komponenten selbst wiederum nicht wieder zuviel Logik oder gar State enthalten sollten.</p>
<p>Dieses Vorgehen bietet sich vor allem dann an wenn immer wiederkehrende Elemente in einer Komponente verwendet wird oder eine <code>render()</code>-Methode eben zu groß und unübersichtlich wird.</p>
<p>Stellen wir uns ein Formular vor, das aus zumeist sehr ähnlichen Textfeldern besteht. Jedes Textfeld befindet sich in einem eigenen Paragraphen, hat ein Label und natürlich auch ein <code>type</code>-Attribute. Zum Label gehört außerdem auch eine id, die ebenfalls angegeben werden muss für jedes Feld:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">return</span> (
    &lt;form&gt;
      &lt;p&gt;
        &lt;label for="email"&gt;
          Email
        &lt;/label&gt;
        &lt;br /&gt;
        &lt;input type="email" name="email" id="email" /&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;label for="password"&gt;
          Password
        &lt;/label&gt;
        &lt;br /&gt;
        &lt;input type="password" name="password" id="password" /&gt;
      &lt;/p&gt;
      &lt;input type="submit" value="Send" /&gt;
    &lt;/form&gt;
  );
}</code></pre>
<p>In diesem Fall haben wir lediglich zwei Formularfelder. Oft ist es aber bereits in durchschnittlich komplexen Anwendungen so, dass es deutlich größere Formulare mit deutlich mehr Feldern gibt. Doch bereits in diesem Fall kann es sinnvoll sein die sich wiederholenden Felder in eigene Komponenten auszulagern, da wir uns viel Schreibarbeit ersparen können.</p>
<p>Wir erstellen also zunächst eine <code>TextField</code>-Komponente und lagern das sich wiederholende JSX aus unserer Formular-Komponente dorthin aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> TextField = <span class="hljs-function">(<span class="hljs-params">{ id, label, ...HTMLInputAttributes }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">{id}</span>&gt;</span>{label}<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> {<span class="hljs-attr">...HTMLInputAttributes</span>} <span class="hljs-attr">id</span>=<span class="hljs-string">{id}</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
);

export default TextField;</span></code></pre>
<p>Unsere neue Komponente empfängt eine <code>id</code>, die wir benötigen, um das Label mit dem Eingabefeld zu verknüpfen und ein Label als solches. Mittels <strong>Object Rest/Spread</strong> fügen wir dem <code>input</code>-Element dann außerdem alle weiteren Props, die der Komponente übergeben werden, als Attribut hinzu.</p>
<p>Unsere Komponente von oben sieht dann wie folgt aus:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">return</span> (
    &lt;form&gt;
      &lt;TextField name="email" label="Email" id="email" type="email" /&gt;
      &lt;TextField name="password" label="Password" id="password" type="password" /&gt;
      &lt;input type="submit" value="Send" /&gt;
    &lt;/form&gt;
  );
}</code></pre>
<p>Aus einem langen und potentiell sehr unübersichtlichen Markup haben wir also eine übersichtliche, prägnante <code>render()</code>-Methode gemacht die auf oberster Ebene aus wenigen Komponenten besteht. Möchten wir in Zukunft außerdem eine Änderung vornehmen die sich auf alle Textfelder auswirkt, bspw. eine neue Klasse hinzufügen, muss dies nur noch an einer einzigen Stelle geändert werden, in der neuen <code>TextField</code>-Komponente.</p>
</div>
<div class="chapter">
  <h1 id="iii-–-erweiterte-konzepte">III – Erweiterte Konzepte</h1>
</div>
<div class="chapter">
  <h1 id="higher-order-components">Higher Order Components</h1>
<p><strong>Higher Order Components</strong> (meist abgekürzt: <strong>HOC</strong> oder <strong>HOCs</strong>) waren und sind ein sehr zentrales Konzept bei der Arbeit mit React. Sie erlauben es Komponenten mit wiederverwendbarer Logik zu implementieren und sind angelehnt an <strong>Higher Order Functions</strong> aus der funktionalen Programmierung. Das Prinzip hinter derartigen Funktionen ist, dass sie eine Funktion als Parameter entgegennehmen und eine neue Funktion zurückgeben. Im Fall von React wird das Prinzip auf Komponenten angewandt. Daher der von den <strong>Higher Order</strong> <em><strong>Functions</strong></em> abgeleitete Name <strong>Higher Order</strong> <em><strong>Component</strong></em>.</p>
<p>Zum leichteren Verständnis gleich ein erstes einfaches Beispiel:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> withFormatting = <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    bold = <span class="hljs-function">(<span class="hljs-params">string</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>{string}<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span></span>;
    };
    italic = <span class="hljs-function">(<span class="hljs-params">string</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>{string}<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span></span>;
    };
    render() {
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> <span class="hljs-attr">bold</span>=<span class="hljs-string">{this.bold}</span> <span class="hljs-attr">italic</span>=<span class="hljs-string">{this.italic}</span> /&gt;</span>;
    }
  };
};</span></code></pre>
<p>Hier haben wir eine Funktion <code>withFormatting</code> definiert, die eine React-Komponente entgegen nimmt. Die Funktion gibt dabei eine neue React-Komponente zurück welche die <em>in die Funktion herein gegebene Komponente</em> rendert und ihr dabei die Props <code>bold</code> und <code>italic</code> übergibt. Die hereingegebene Komponente kann nun auf diese Props zugreifen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> FormattedComponent = withFormatting(<span class="hljs-function">(<span class="hljs-params">{ bold, italic }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    Dieser Text ist {bold('fett')} und {italic('kursiv')}.
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
));</code></pre>
<p>Typischerweise werden <strong>Higher Order Components</strong> benutzt um Logik darin zu kapseln. In diesem Zusammenhang ist auch oft die Rede von <strong>Smart</strong> und <strong>Dumb Components</strong> also: <strong>schlaue</strong> und <strong>dumme</strong> Komponenten. Die Smart Components (zu denen Higher Order Components zählen) sind dann dazu da um Business Logik abzubilden, mit APIs zu kommunizieren oder Verhaltenslogik zu verarbeiten. <em>Dumme</em> Komponenten hingegen bekommen weitestgehend statische Props übergeben und beschränken den Logik-Teil auf reine Darstellungslogik. Also bspw. ob ein Benutzerbild oder, falls dieses nicht vorhanden ist, stattdessen ein Platzhalterbild angezeigt wird. In diesem Zusammenhang fällt auch oft der Begriff <strong>Container Component</strong> (für <em>Smart</em> Components) und <strong>Layout Components</strong> (für <em>Dumb</em> Components).</p>
<p>Doch wozu das überhaupt? Eine solche strikte Unterteilung in Business Logik und Darstellungslogik macht echte komponentenbasierte Entwicklung erst einmal möglich. Sie erlaubt es Layout Komponenten zu erstellen die keinerlei Kenntnis von etwaigen APIs haben und nur stumpf die Daten darstellen die ihnen übergeben werden, völlig egal woher diese kommen. Gleichzeitig erlaubt sie es auch den Business Logik Komponenten sich um die reine Business Logik zu kümmern, völlig gleichgültig wie die Daten letzten Endes dargestellt werden.</p>
<p>Stellen wir uns ein gängiges Beispiel aus der Interface Entwicklung einmal vor: die Umschaltung zwischen einer <strong>Listen-</strong> und einer <strong>Karten-Ansicht</strong>. Hier würde sich eine <strong>Container-Komponente</strong> darum kümmern die Daten zu beschaffen die relevant sind für den Benutzer. Sie würde die beschafften Daten dann an die frei konfigurierbare <strong>Layout-Komponente</strong> übergeben. Solange beide Komponenten sich an das vom Entwickler vorgebene Interface (Stichwort <strong>PropTypes</strong>) halten sind beide Komponenten beliebig austauschbar und können vollkommen unabhängig voneinander entwickelt und <strong>getestet</strong> werden!</p>
<p>Genug Theorie. Zeit für ein weiteres Beispiel. Wir wollen uns eine Liste mit den 10 größten Kryptowährungen laden und ihren momentanen Preis anzeigen. Dazu erstellen wir eine <strong>Higher Order Component</strong> die sich diese Daten über die frei zugängliche Coinmarketcap API beschafft und an eine Layout-Komponente übergibt.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> withCryptoPrices = <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    state = {
      <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">items</span>: [],
    };

    componentDidMount() {
      <span class="hljs-keyword">this</span>.loadData();
    }

    loadData = <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
        <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">true</span>,
      }));

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> cryptoTicker = <span class="hljs-keyword">await</span> fetch(
          <span class="hljs-string">'https://api.coinmarketcap.com/v2/ticker/?limit=10&amp;convert=EUR'</span>
        );
        <span class="hljs-keyword">const</span> cryptoTickerResponse = <span class="hljs-keyword">await</span> cryptoTicker.json();

        <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
          <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">items</span>: <span class="hljs-keyword">this</span>.convertResponseToArray(cryptoTickerResponse),
        }));
      } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
          <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>,
        }));
      }
    };

    convertResponseToArray = <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.entries(response.data).map(<span class="hljs-function">(<span class="hljs-params">[id, item]</span>) =&gt;</span> item);
    };

    render() {
      <span class="hljs-keyword">const</span> { isLoading, items } = <span class="hljs-keyword">this</span>.state;
      <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span>
          <span class="hljs-attr">isLoading</span>=<span class="hljs-string">{isLoading}</span>
          <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span>
          <span class="hljs-attr">loadData</span>=<span class="hljs-string">{this.loadData}</span>
        /&gt;</span>
      );
    }
  };
};</span></code></pre>
<p>Voilà, fertig ist die <strong>HOC</strong> für die Abfrage der Crypto-Preise auf coinmarketcap.com. Doch die <strong>Higher Order Component</strong> allein reicht noch nicht. Wir benötigen nun auch noch eine Layout-Komponente, an die wir die Verantwortung delegieren die Daten entsprechend anzuzeigen.</p>
<p>Hierzu erstellen wir eine möglichst generische <code>PriceTable</code>-Komponente, die selbst keinerlei Kenntnis davon hat ob sie nun die aktuellen Joghurtpreise aus dem örtlichen Supermarkt darstellt oder Preise von Kryptowährungen auf irgendeiner beliebigen Börse. Entsprechend nennen wir sie auch sehr generisch <code>PriceTable</code>:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> PriceTable = <span class="hljs-function">(<span class="hljs-params">{ isLoading, items, loadData }</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (isLoading) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading prices. Please be patient.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
  }

  <span class="hljs-keyword">if</span> (!items || items.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
        No data available. <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{loadData}</span>&gt;</span>Try again<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
    );
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
      {items.map((item) =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
            {item.name} ({item.symbol})
          <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>EUR {item.quotes.EUR.price}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
      ))}
      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colSpan</span>=<span class="hljs-string">"2"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{loadData}</span>&gt;</span>Refresh<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span>
  );
};</code></pre>
<p>Die Komponente kennt drei Props: <code>isLoading</code>, um ihr mitzuteilen, dass die Daten die sie einmal darstellen soll aktuell noch geladen werden, <code>items</code>, was ein Array aus „Artikeln“ mit Preisen repräsentiert und <code>loadData</code>, eine Funktion um erneut einen API-Request zu starten um die neuen Daten zu beziehen.</p>
<p>Beide Komponenten funktionieren vollkommen unabhängig voneinander. Die <code>PriceTable</code> kann nicht nur Crypto-Preise anzeigen, die <code>withCryptoPrices</code>-Komponente muss ihre Daten nicht zwangsweise in einer <code>PriceTable</code> darstellen. Wir haben hier also zwei vollständig gekapselte und wiederverwendbare Komponenten erstellt!</p>
<p>Doch wie bringen wir die beiden nun zusammen? Ganz einfach indem wir die <code>PriceTable</code>-Komponente als Parameter an die <code>withCryptoPrices</code>-Komponente übergeben. Aha! Und das sieht wie folgt aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> CryptoPriceTable = withCryptoPrices(PriceTable);</code></pre>
<p>Rendern wir nun eine Instanz der <code>CryptoPriceTable</code>, stößt die <strong>Higher Order Component</strong> beim <code>componentDidMount()</code> einen API-Request an und übergibt das Ergebnis dieses Requests an die ihr übergebene <code>PriceTable</code>-Komponente. Diese kümmert sich anschließend nur noch um die entsprechende Darstellung.</p>
<pre><code class="hljs jsx language-jsx">ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CryptoPriceTable</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Dadurch ergeben sich großartige Möglichkeiten für uns. Erst einmal sind beide Komponenten unabhängig voneinander testbar. Mehr dazu gibt es im entsprechenden Kapitel, wo wir uns nochmal gezielt anschauen wie einfach man insbesondere Layout-Komponenten mittels Snapshot-Tests testen kann.</p>
<p>Weiter haben wir nun eben die Möglichkeit auch andere Layout-Komponenten mit der <code>withCryptoPrices</code>-HOC zu „verbinden“. Um dieses mächtige Konzept einmal anhand eines Beispiels zu verdeutlichen, geben wir die Preise nun im CSV-Format aus. Unsere HOC bleibt dabei völlig unverändert. Unsere Layout-Komponente könnte wie folgt implementiert werden:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> PriceCSV = <span class="hljs-function">(<span class="hljs-params">{ isLoading, items, loadData, separator = <span class="hljs-string">';'</span> }</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (isLoading) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading prices. Please be patient.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
  }

  <span class="hljs-keyword">if</span> (!items || items.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
        No data available. <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{loadData}</span>&gt;</span>Try again<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
    );
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>
      {items.map(
        ({ name, symbol, quotes }) =&gt;
          `${name}${separator}${symbol}${separator}${quotes.EUR.price}\n`
      )}
    <span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span></span>
  );
};</code></pre>
<p>Und damit haben wir auch schon unsere CSV-Layout-Komponente implementiert. Wieder schauen wir zuerst ob noch Daten geladen werden, anschließend schauen wir erneut ob <code>items</code> vorhanden sind. Hier könnte man anfangen darüber nachzudenken auch dies in einer weiteren HOC zu bündeln, denn HOCs lassen sich beliebig ineinander schachteln, sind es doch am Ende lediglich Funktionen die als Parameter an andere Funktionen weitergegeben werden.</p>
<p>Zuletzt rendern wir den tatsächlichen Output: wir iterieren durch die Liste der <code>items</code>, picken uns über die <strong>Object Destructuring</strong> Syntax die für uns relevanten Eigenschaften <code>name</code>, <code>symbol</code> und <code>quotes</code> heraus und umschließen die einzelnen Zeilen mit einem <code>pre</code>-Element um den Zeilenumbruch am Ende der Zeile korrekt darzustellen.</p>
<p>Anders als bei der <code>PriceTable</code> haben wir hier allerdings noch eine weitere (optionale) Prop eingeführt: <code>separator</code> - um der Render-Komponente mitzuteilen welches Trennzeichen sie bei der Darstellung der Daten verwenden soll. Die Prop kann wie in JSX üblich bei der Verwendung der Komponente als simple Prop angegeben werden:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> CryptoCSV = withCryptoPrices(PriceCSV);

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CryptoCSV</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">","</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Allerdings wird dafür eine Änderung an unserer ursprünglichen <code>withCryptoPrices</code>-HOC notwendig. Momentan werden lediglich die fest definierten Props <code>isLoading</code>, <code>items</code> und <code>loadData</code> an die Kind-Komponente (<code>WrappedComponent</code>) übergeben:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span>
    <span class="hljs-attr">isLoading</span>=<span class="hljs-string">{isLoading}</span>
    <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span>
    <span class="hljs-attr">loadData</span>=<span class="hljs-string">{this.loadData}</span>
  /&gt;</span>
);</span></code></pre>
<p>Damit die in <code>&lt;CryptoCSV separator="," /&gt;</code> angegebene <code>separator</code>-Prop auch korrekt an die <code>PriceCSV</code>-Komponente übergeben wird, müssen wir unserer <strong>HOC</strong> mitteilen, dass sie auch alle weiteren Props an die <code>WrappedComponent</code> übergibt. Je nach Einsatzzweck können weitere erlaubte Props entweder explizit übergeben werden oder aber, es werden einfach <strong>sämtliche</strong> weiteren Props übergeben:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span>
    {<span class="hljs-attr">...this.props</span>}
    <span class="hljs-attr">isLoading</span>=<span class="hljs-string">{isLoading}</span>
    <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span>
    <span class="hljs-attr">loadData</span>=<span class="hljs-string">{this.loadData}</span>
  /&gt;</span>
);</span></code></pre>
<p>Entscheidend ist hier Zeile 3: mittels <code>{...this.props}</code>. Über die Spread-Syntax leiten wir hier sämtliche Props an die Kind-Komponente weiter.</p>
<div class="hint hint--info">
<p><strong>Higher Order Components</strong> sind ein schönes Mittel um Logik zu „zentralisieren“ und seine Anwendung somit übersichtlicher zu strukturieren. Logik kann dabei sehr unkompliziert aus den Komponenten entfernt werden, die nur für das Rendering, also die Darstellungslogik sorgen sollten. Obwohl sie ein sehr zentrales Konzept in React waren und noch immer sind, sind sie gleichzeitig ein sehr altes Konzept.</p>
<p>Zwar werden <strong>Higher Order Components</strong> noch immer häufig verwendet und gegen ihre Verwendung ist nichts einzuwenden. Allerdings gibt es mittlerweile neuere Konzepte und seit den neuesten Updates vor allem neue Wege um eine ähnliche Funktionalität in vielen Fällen in noch übersichtlicher Form zu erreichen. Zwei davon sind <strong>Functions as a Child</strong> und die neue <strong>Context API</strong>, die in Version 16.3.0 ihren Weg in React gefunden hat. Diese werden in den folgenden Kapiteln beschrieben.</p>
</div>
</div>
<div class="chapter">
  <h1 id="functions-as-a-child-und-render-props">Functions as a Child und Render Props</h1>
<p><strong>Functions as a Child</strong> (kurz: <em>FaaC</em>) und <strong>Render Props</strong> werden in der offiziellen React-Dokumentation jeweils separat beschrieben, wobei <strong>Functions as Children</strong> im Kapitel zu <strong>Render Props</strong> ebenfalls erwähnt werden. Da beide vom Prinzip her ziemlich identisch funktionieren, möchte ich die beiden Konzepte in einem Kapitel beschreiben. Doch erst einmal: worum geht es überhaupt?</p>
<p>Bei <strong>Functions as a Child</strong> (in der offiziellen Doku auch als <strong>Function as Children</strong> bezeichnet) und bei <strong>Render Props</strong> handelt es sich um Patterns die ähnlich wie <strong>Higher Order Components</strong> Business- oder Applikations-Logik in einer Art übergeordneten Komponente bündeln. Anders als bei <strong>Higher Order Components</strong> wird jedoch keine neue Komponente zurückgegeben, dieser dann entsprechende Daten als Props übergeben werden sondern es wird eine Funktion aufgerufen, die die entsprechenden Daten als Parameter übergeben bekommt. Beim <strong>Function as Children-</strong>Pattern ist diese Funktion ein Kind-Element der Komponente (also: <code>this.props.children</code>), beim <strong>Render Props-</strong>Pattern eine Prop die in den meisten Fällen den Namen <code>render</code> (also: <code>this.props.render</code>) hat, aber auch jeden anderen Namen haben könnte.</p>
<p>Wir wissen bereits, dass der Wert einer Prop in JSX jeder beliebige valide Ausdruck in JavaScript sein kann. Auch aufgerufene Funktionen können Ausdrücke zurückgeben und so können wir nicht nur Strings, Booleans, Arrays, Objekte, andere React Elements oder <code>null</code> als Wert für unsere Props verwenden sondern eben auch den return-Wert einer aufgerufenen Funktion. Wir haben auch gelernt, dass <code>children</code> in React nur eine Art Sonderform einer Prop sind und so haben die folgenden beiden Zeilen jeweils das gleiche Rendering-Ergebnis zur Folge:</p>
<pre><code class="hljs jsx language-jsx">&lt;MyComponent&gt;Ich bin ein Child-Element&lt;/MyComponent&gt;
&lt;MyComponent children="Ich bin ein Child-Element" /&gt;</code></pre>
<p>In der <code>MyComponent</code>-Komponente kann dann mittels <code>props.children</code> auf den <em>Ich bin ein Child-Element</em> Text zugegriffen werden.</p>
<p>Dies können wir uns zu nutze machen und eben auch Funktionen übergeben die dann in der <code>render()</code>-Methode einer Komponente aufgerufen werden. Die Idee dahinter ist, dass auf diesem Weg beliebige Daten von einer Komponente in die nächste übergeben werden können. Ähnlich wie bei <strong>Higher Order Components</strong>, jedoch mit etwas mehr Flexibilität. So müssen wir z.B. nicht die ganze Komponente mit einer <strong>Higher Order Component</strong> „verbinden“ sondern können dies einfach mittendrin im JSX unserer Komponente tun. Denken wir zurück an die <code>withFormatting</code> HOC aus dem vorherigen Kapitel. Eine entsprechende als <strong>Function as a Child (FaaC)</strong> Komponente implementiert könnte etwa so aussehen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> bold = <span class="hljs-function">(<span class="hljs-params">string</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>{string}<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span></span>;
};

<span class="hljs-keyword">const</span> italic = <span class="hljs-function">(<span class="hljs-params">string</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>{string}<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span></span>;
};

<span class="hljs-keyword">const</span> Formatter = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> props.children !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'children prop must be a function!'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">return</span> props.children({ bold, italic });
};</code></pre>
<p>Wir definieren also wieder eine <code>bold</code> und eine <code>italic</code> Funktion, prüfen in der <code>Formatter</code>-Komponente ob die übergebene <code>children</code>-Prop eine Funktion ist und rufen diese Funktion auf. Weiter übergeben wir ihr als einzigen Parameter ein Objekt mit den Eigenschaften <code>bold</code> mit der <code>bold</code>-Funktion als Wert sowie <code>italic</code> mit der <code>italic</code>-Funktion als Wert. Gleichzeitig geben wir die aufgerufene Funktion aus der Komponente zurück.</p>
<p>Bei der Verwendung dieser <strong>Function as Children</strong>-Komponente wird dann eben eine Funktion im JSX als Kind-Element übergeben. Dies funktioniert wie folgt:</p>
<pre><code class="hljs jsx language-jsx">&lt;div&gt;
  &lt;p&gt;Dieser Text hat keinerlei Kenntnis der Formatter-Funktionen&lt;/p&gt;
  &lt;Formatter&gt;
    {({ bold }) =&gt; &lt;p&gt;Dieser Text hingegen {bold('sehr wohl')}&lt;/p&gt;}
  &lt;/Formatter&gt;
&lt;/div&gt;</code></pre>
<p>Der Nutzen dieses Ansatzes ist die besagte Flexibilität, da wir nun nicht mehr die ganze Komponente selbst mit einer Higher Order Funktion verbinden müssen nur um vielleicht an einer einzigen Stelle auf dessen wiederverwendbare Funktionalität zurückgreifen zu können. Anders als bei Higher Order Components ist es auf diese Art auf möglich Parameter direkt aus dem JSX an die Function as a Child Komponente zu übergeben und so mit dieser zu kommunizieren.</p>
<p>Schauen wir uns dazu noch einmal unser zweites Beispiel aus dem Kapitel über Higher Order Components an, die Preisliste der Kryptowährungen, und implementieren diese als Function as a Child:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoPrices</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">items</span>: [],
  };

  componentDidMount() {
    <span class="hljs-keyword">this</span>.loadData();
  }

  loadData = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">true</span>,
    }));

    <span class="hljs-keyword">const</span> { limit } = <span class="hljs-keyword">this</span>.props;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> cryptoTicker = <span class="hljs-keyword">await</span> fetch(
        <span class="hljs-string">`https://api.coinmarketcap.com/v2/ticker/?limit=<span class="hljs-subst">${limit ||
          <span class="hljs-number">10</span>}</span>&amp;convert=EUR`</span>
      );
      <span class="hljs-keyword">const</span> cryptoTickerResponse = <span class="hljs-keyword">await</span> cryptoTicker.json();

      <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
        <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">items</span>: <span class="hljs-keyword">this</span>.convertResponseToArray(cryptoTickerResponse),
      }));
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
        <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>,
      }));
    }
  };

  convertResponseToArray = <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.entries(response.data).map(<span class="hljs-function">(<span class="hljs-params">[id, item]</span>) =&gt;</span> item);
  };

  render() {
    <span class="hljs-keyword">const</span> { isLoading, items } = <span class="hljs-keyword">this</span>.state;
    <span class="hljs-keyword">const</span> { children } = <span class="hljs-keyword">this</span>.props;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> children !== <span class="hljs-string">'function'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">return</span> children({
      isLoading,
      items,
      <span class="hljs-attr">loadData</span>: <span class="hljs-keyword">this</span>.loadData,
    });
  }
}</code></pre>
<p>Auf den ersten Blick sieht die Komponente gar nicht mal so anders aus als die Higher Order Component aus dem vorherigen Kapitel. Doch wer genau hinschaut erkennt:</p>
<ul>
<li>Es wird keine weitere Komponente mehr erzeugt und zurückgegeben sondern es wird direkt mit der Komponente gearbeitet</li>
<li>Die <code>loadData</code>-Methode greift auf this.props zu um daraus die <code>limit</code>-Prop abzulesen. Diese wird benutzt um sie als Parameter für den API Call zu verwenden.</li>
<li>Die <code>render()</code>-Methode gibt nun keine in die Komponente herein gegebene Komponente mehr zurück sondern ruft stattdessen die <code>children</code>-Funktion aus, die sie aus ihren eigenen Props bekommt.</li>
<li>Die <code>children</code>-Funktion hingegen bekommt den Lade-Status (<code>isLoading</code>), sowie letztendlich die items zurück.</li>
</ul>
<p>Die Verwendung dieser Komponente ist dann ähnlich zu der aus dem ersten Beispiel mit dem kleinen Unterschied, dass wir der Komponente optional eine <code>limit</code> Prop übergeben können:</p>
<pre><code class="hljs jsx language-jsx">&lt;div&gt;
  &lt;h1&gt;Current Crypto Currency Prices&lt;/h1&gt;
  &lt;CryptoPrices limit={5}&gt;
    {({ isLoading, items }) =&gt;
      isLoading ? (
        &lt;p&gt;Loading prices. Please be patient.&lt;/p&gt;
      ) : (
        &lt;ul&gt;
          {items.map((item) =&gt; (
            &lt;li&gt;
              {item.name} ({item.symbol}): EUR {item.quotes.EUR.price}
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
      )
    }
  &lt;/CryptoPrices&gt;
&lt;/div&gt;</code></pre>
<p>An dieser Stelle kommt ebenfalls auch wieder die <code>PriceTable</code>-Komponente ins Spiel. Diese erwartete genau die drei Props die wir aus der <code>CryptoPrices</code>-Komponente zurückgeben. Na, so ein Zufall! Schauen wir uns das doch einmal an, wie wir die beiden miteinander verbinden können:</p>
<pre><code class="hljs jsx language-jsx">&lt;CryptoPrices limit={<span class="hljs-number">5</span>}&gt;
  {({ isLoading, items, loadData }) =&gt; (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">PriceTable</span> <span class="hljs-attr">isLoading</span>=<span class="hljs-string">{isLoading}</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span> <span class="hljs-attr">loadData</span>=<span class="hljs-string">{loadData}</span> /&gt;</span>
  )}
<span class="hljs-tag">&lt;/<span class="hljs-name">CryptoPrices</span>&gt;</span></span></code></pre>
<p>Oder um es mittels der Spread-Syntax kurz zu machen:</p>
<pre><code class="hljs jsx language-jsx">&lt;CryptoPrices limit={<span class="hljs-number">5</span>}&gt;{(props) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">PriceTable</span> {<span class="hljs-attr">...props</span>} /&gt;</span>}<span class="hljs-tag">&lt;/<span class="hljs-name">CryptoPrices</span>&gt;</span></span></code></pre>
<p>Auf diese Art und Weise haben wir eine sehr hohe Flexibilität gewährleistet, müssen Komponenten jedoch nicht starr über eine HOC mit der Logik verbinden, was uns einiges an „organisatorischem Aufwand“ erspart.</p>
<p>Doch Vorsicht: Functions as a Child-Komponenten haben auch eine Einschränkung die Higher Order Components nicht haben. Nämlich können die Daten die wir aus einer FaaC-Komponente beziehen <strong>nur innerhalb von JSX</strong> verwendet werden! Möchten wir also relativ abstrakte Methoden über eine höher in der Komponenten-Hierarchie stehende Logik-Komponente bereitstellen ist dies mit einer FaaC-Komponente erst einmal nicht oder nur umständlich möglich!</p>
<h3 id="render-props">Render Props</h3>
<p>Doch Moment mal, wie war das jetzt eigentlich mit den <strong>Render Props</strong> und was ist das jetzt genau und wie unterscheiden sich diese von <strong>Function as Children</strong>-Komponenten?</p>
<p>Vereinfacht gesagt: nur durch den Namen der Prop. Einige populäre Libraries aus der React-Welt hatten irgendwann damit angefangen <code>render</code> als Name für Props zu benutzen die Funktionen als Wert erwarten. Und so würde unsere CryptoPrices-Komponente wenn wir statt <code>children</code> eine <code>render</code>-Prop benutzen so aussehen:</p>
<pre><code class="hljs jsx language-jsx">&lt;CryptoPrices limit={<span class="hljs-number">5</span>} render={(props) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">PriceTable</span> {<span class="hljs-attr">...props</span>} /&gt;</span>} /&gt;</span></code></pre>
<p>Innerhalb der <code>CryptoPrices</code>-Komponente muss es dann natürlich heißen:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">const</span> { isLoading, items } = <span class="hljs-keyword">this</span>.state;
  <span class="hljs-keyword">const</span> { render } = <span class="hljs-keyword">this</span>.props;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> render !== <span class="hljs-string">"function"</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-comment">// Achtung: dieses render() hat nichts mit der gleichnamigen Komponenten Methode</span>
  <span class="hljs-comment">// zu tun sondern kommt über this.props.render in die Komponente hinein!</span>
  <span class="hljs-keyword">return</span> render({
    isLoading,
    items,
    <span class="hljs-attr">loadData</span>: <span class="hljs-keyword">this</span>.loadData
  });
}</code></pre>
<p>Ist also ein Stück weit auch Geschmackssache. Dabei seid ihr natürlich auf den Namen <code>render</code> nicht nicht festgelegt sondern könnt einfach jeder beliebigen Prop einfach eine Funktion übergeben und diese somit zu einer <em>„Render Prop“</em> machen.</p>
<p>Dabei ist es auch möglich beliebig viele solcher Props in einer Komponente zu haben. Wollt ihr beispielsweise eine Komponente implementieren die euch eine Tabelle ausgibt, die sowohl einen Tabellenkopf sowie auch einen Body besitzt, wobei beide jeweils Daten aus der Komponente beziehen ist auch dies kein Problem!</p>
<h3 id="render-props-und-faacs-in-verbindung-mit-higher-order-components">Render Props und FaaCs in Verbindung mit Higher Order Components</h3>
<p>Zum Abschluss noch ein kleiner Trick. Solltet ihr tatsächlich einmal eine <strong>Higher Order Component</strong> benötigen und ihr habt bereits eine <strong>FaaC-</strong> oder <strong>Render Prop</strong>-Komponente, könnt ihr diese auch zu einer HOC machen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withCryptoPrices</span>(<span class="hljs-params">WrappedComponent</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    render() {
      <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CryptoPrices</span>&gt;</span>
          {(cryptoPriceProps) =&gt; (
            <span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> {<span class="hljs-attr">...this.props</span>} {<span class="hljs-attr">...cryptoPriceProps</span>} /&gt;</span>
          )}
        <span class="hljs-tag">&lt;/<span class="hljs-name">CryptoPrices</span>&gt;</span>
      );
    }
  };
}</span></code></pre>
<p>In der Praxis wird dieser Fall erfahrungsgemäß eher selten eintreffen.</p>
<div class="hint hint--info">
<p>Das <strong>Function as a Child</strong>-Pattern und das nahezu identische <strong>Render-Props</strong>-Pattern wird verwendet um Business Logik von Darstellungs-Komponenten zu trennen. Sie sind eine sehr leichtgewichtige Alternative zu <strong>Higher Order Components</strong>, die so ziemlich den gleichen Anwendungsfall bedienen.</p>
<p>Sie lassen sich anders als HOCs jedoch auch innerhalb einer <code>render()</code>-Methode von Komponenten verwenden und müssen nicht starr mit einer Komponente „verknüpft“ werden. Dies macht sie noch etwas flexibler in ihren Einsatzmöglichkeiten als <strong>Higher Order Components</strong> ohne dabei an Übersichtlichkeit einzubüßen.</p>
</div>
</div>
<div class="chapter">
  <h1 id="context-api">Context API</h1>
<p>Die <strong>Context API</strong> wurde in React sehr lange Zeit eher stiefmütterlich behandelt und wurde erst einmal nur prototypisch implementiert und als experimentell bezeichnet ehe sie in React <strong>16.3.</strong> in grundlegend überarbeiteter Form offizieller Teil von React wurde.</p>
<p>Sie wurde dafür konzipiert, um Daten innerhalb einer Komponenten-Hierarchie an sog. <em>Konsumenten</em> zu verteilen ohne dabei Props an jede einzelne Komponente explizit übergeben zu müssen. Dies kann in einigen Fällen sehr mühsam sein wenn es sich um Daten handelt die von vielen Komponenten innerhalb des Baumes gemeinsam immer wieder verwendet werden. Dazu gehören bspw. Sprach-Einstellungen oder ein globales Style-Schema („Theme“).</p>
<p>In solchen Fällen bietet sich die <strong>Context API</strong> an, die jeweils aus einem <strong>Context</strong> <em><strong>Provider</strong></em> und beliebig vielen <strong>Context</strong> <em><strong>Consumern</strong></em> besteht. Der <strong>Provider</strong> dient hier als eine Art zentrale Instanz für die jeweilige Datenstruktur, der <strong>Consumer</strong> kann dann die entsprechenden Daten <em>konsumieren</em>, die vom Provider bereitgestellt werden. Sozusagen eine „semi-globale“ Dateninstanz, die nur für einen bestimmten Baum innerhalb der Komponenten-Hierarchie gilt.</p>
<p>Die Datenstruktur kann dabei durchaus auch sehr komplex sein und ist nicht bspw. auch einfache Datentypen wie Strings oder Arrays beschränkt. Eine Anwendung kann dabei auch beliebig viele Contexts besitzen (bspw. einen für die vom Benutzer eingestellte Sprache, einen für das Style-Schema, etc.) und auch ein Provider selbst kann mit wechselnden Werten mehrfach verwendet werden. Aber eins nach dem anderen.</p>
<h3 id="api">API</h3>
<p>Zur Erstellung eines neuen <strong>Contexts</strong> stellt React die Methode <code>createContext</code> bereit:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> LanguageContext = React.createContext(defaultValue);</code></pre>
<p>Mit lediglich dieser einen Zeile haben wir bereits einen neuen <strong>Context</strong> erstellt. Der <strong>Context</strong> besteht nun aus einer <strong>Provider-</strong> und eine <strong>Consumer-</strong>Komponente: <code>LanguageContext.Provider</code> sowie <code>LanguageContext.Consumer</code>.</p>
<p>Innerhalb unserer Anwendung kann der <strong>Context</strong> nun genutzt werden, indem ein bestimmter Baum von einem Provider umschlossen wird:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// LanguageContext.js</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">const</span> LanguageContext = React.createContext(<span class="hljs-string">'de'</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> LanguageContext;</code></pre>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> LanguageContext <span class="hljs-keyword">from</span> <span class="hljs-string">'./LanguageContext'</span>;

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LanguageContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{</span>'<span class="hljs-attr">en</span>'}&gt;</span>
    {/* innerhalb dieses Baums steht uns nun der Wert 'de' zur Verfügung */}
  <span class="hljs-tag">&lt;/<span class="hljs-name">LanguageContext.Provider</span>&gt;</span>
);

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.getElementById('#root'));</span></code></pre>
<p>Möchten wir in einer Komponente nun auf den Wert des <strong>Contexts</strong> zugreifen, umschließen wir eine Komponente und machen uns das <strong>Function as a Child</strong> Prinzip das wir uns im vorherigen Kapitel angeschaut haben zu nutze:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// DisplaySelectedLanguage.js</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> LanguageContext <span class="hljs-keyword">from</span> <span class="hljs-string">'./LanguageContext'</span>;

<span class="hljs-keyword">const</span> DisplaySelectedLanguage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LanguageContext.Consumer</span>&gt;</span>
    {(value) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Die ausgewählte Sprache ist {value}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>}
  <span class="hljs-tag">&lt;/<span class="hljs-name">LanguageContext.Consumer</span>&gt;</span>
);

export default DisplaySelectedLanguage;</span></code></pre>
<p>Wir können nun an einer beliebigen Stelle innerhalb unserer Anwendung die <code>SelectedLanguage</code> Komponente verwenden und haben dort immer den jeweils vom Provider bereitgestellten Wert verfügbar. Ändert sich der Wert im <strong>Provider</strong> werden auch alle <strong>Consumer-</strong>Komponenten unterhalb des entsprechenden Providers mit dem aktualisierten Wert neu gerendert!</p>
<p>Ein vollständiges, wenn auch recht konstruiertes Beispiel kann dann wie folgt aussehen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> LanguageContext <span class="hljs-keyword">from</span> <span class="hljs-string">'./LanguageContext'</span>;
<span class="hljs-keyword">import</span> DisplaySelectedLanguage <span class="hljs-keyword">from</span> <span class="hljs-string">'./DisplaySelectedLanguage'</span>;

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  &lt;LanguageContext.Provider value="en"&gt;
    &lt;header&gt;Herzlich willkommen&lt;/header&gt;
    &lt;div className="content"&gt;
      &lt;div className="sidebar" /&gt;
      &lt;div className="mainContent"&gt;
        &lt;DisplaySelectedLanguage /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;footer&gt;© 2019&lt;/footer&gt;
  &lt;/LanguageContext.Provider&gt;
);

ReactDOM.render(&lt;App /&gt;, document.getElementById('#root'));</code></pre>
<p>Obwohl wir keinerlei <strong>Props</strong> an die <code>DisplaySelectedLanguage</code>-Komponente übergeben hat diese dennoch Kenntnis von der aktuell ausgewählten Sprache und zeigt korrekt an:</p>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Die ausgewählte Sprache ist en<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>
<p>Ändert sich der <code>value</code> einer Provider-Komponente werden alle Consumer-Komponenten die sich innerhalb dieses Providers befinden neu gerendert!</p>
<p>Erweitern wir das Beispiel können wir uns so eine relativ simple kleine Komponentenstruktur aufbauen, um bspw. Mehrsprachigkeit in einer Anwendung zu realisieren.</p>
<p>Im folgenden Beispiel legen wir ein Objekt mit Übersetzungen an und geben ein relativ umfangreiches Objekt mit verschiedenen Datentypen (bestehend aus einem Array, einem String, einer Funktion um die Sprache zu wechseln und einem Objekt mit den eigentlichen Übersetzungen) in den Context herein:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> translationStore = {
  <span class="hljs-attr">de</span>: {
    <span class="hljs-attr">greeting</span>: <span class="hljs-string">'Guten Tag!'</span>,
    <span class="hljs-attr">headline</span>: <span class="hljs-string">'Heute lernen wir, wie Context funktioniert.'</span>,
  },
  <span class="hljs-attr">en</span>: {
    <span class="hljs-attr">greeting</span>: <span class="hljs-string">'Good day!'</span>,
    <span class="hljs-attr">headline</span>: <span class="hljs-string">'Today we learn how context works.'</span>,
  },
};

<span class="hljs-keyword">const</span> defaultLanguage = <span class="hljs-string">'de'</span>;

<span class="hljs-keyword">const</span> defaultLanguageContextValue = {
  <span class="hljs-attr">availableLanguages</span>: <span class="hljs-built_in">Object</span>.keys(translationStore),
  <span class="hljs-attr">changeLanguage</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'Funktion changeLanguage() nicht implementiert!'</span>);
  },
  <span class="hljs-attr">language</span>: defaultLanguage,
  <span class="hljs-attr">translations</span>: translationStore[defaultLanguage],
};

<span class="hljs-keyword">const</span> LanguageContext = React.createContext(defaultLanguageContextValue);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Localized</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  changeLanguage = <span class="hljs-function">(<span class="hljs-params">newLanguage</span>) =&gt;</span> {
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({
      <span class="hljs-attr">translations</span>: translationStore[newLanguage],
      <span class="hljs-attr">language</span>: newLanguage,
    }));
  };

  state = {
    ...defaultLanguageContextValue,
    <span class="hljs-attr">changeLanguage</span>: <span class="hljs-keyword">this</span>.changeLanguage,
  };

  render() {
    <span class="hljs-keyword">return</span> (
      &lt;LanguageContext.Provider value={this.state}&gt;
        {this.props.children}
      &lt;/LanguageContext.Provider&gt;
    );
  }
}

const Greeting = () =&gt; (
  &lt;LanguageContext.Consumer&gt;
    {(contextValue) =&gt; contextValue.translations.greeting}
  &lt;/LanguageContext.Consumer&gt;
);

const Headline = () =&gt; (
  &lt;LanguageContext.Consumer&gt;
    {(contextValue) =&gt; contextValue.translations.headline}
  &lt;/LanguageContext.Consumer&gt;
);

const LanguageSelector = () =&gt; {
  return (
    &lt;LanguageContext.Consumer&gt;
      {(contextValue) =&gt; (
        &lt;select
          onChange={(event) =&gt; {
            contextValue.changeLanguage(event.target.value);
          }}
        &gt;
          {contextValue.availableLanguages.map((language) =&gt; (
            &lt;option value={language}&gt;{language}&lt;/option&gt;
          ))}
        &lt;/select&gt;
      )}
    &lt;/LanguageContext.Consumer&gt;
  );
};

const App = () =&gt; (
  &lt;Localized&gt;
    &lt;LanguageSelector /&gt;
    &lt;p&gt;
      &lt;Greeting /&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;Headline /&gt;
    &lt;/p&gt;
  &lt;/Localized&gt;
);

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</code></pre>
<p>Zuerst definieren wir ein Objekt <code>defaultLanguageContextValue</code> welches den Default-Wert unseres neuen Context-Objekts darstellt. Dieses besteht aus:</p>
<ul>
<li>einem Objekt <code>translationStore</code>, welches alle vorhandenen Übersetzungen beinhaltet.</li>
<li>einer Standardsprache Deutsch (<code>de</code>) , die in der <code>language</code> Eigenschaft gespeichert wird</li>
<li>einem Array (<code>availableLanguages</code>) mit allen verfügbaren Sprachen aus dem <code>translationStore</code>-Objekt, den wir mittels <code>Object.keys()</code> dynamisch aus den Eigenschaften auf erster Ebene erzeugen (in unserem Beispiel also <code>['de', 'en']</code>).</li>
<li>einer Platzhalterfunktion (<code>changeLanguage()</code>), die später in der <code>Localized</code>-Komponente durch eine echte Implementierung ersetzt wird. Dies dient dazu, dass wir bei inkorrekter Benutzung des Contexts nicht Gefahr laufen eine Funktion aufzurufen die noch gar nicht existiert. In diesem Fall würde die Warnung ausgegeben werden <em>„Funktion changeLanguage() nicht implementiert!“</em>.</li>
</ul>
<p>Die <code>changeLanguage()</code>-Funktion kann erst später in der Komponente selbst implementiert werden, da React ansonsten keine Möglichkeit hätte mit Bordmitteln den State (also in diesem konkreten Fall die Sprache und die Übersetzungen) zu ändern, da State für React nur <strong>innerhalb einer Komponente</strong> existiert. So könnten wir zwar die aktuelle Spracheinstellung bspw. in einer globalen Variable speichern, React würde die Komponente dann bei einer Änderung aber nicht neu rendern, da sich weder Props noch State geändert haben, dies aber eine Bedingung ist, um React den Seitenbaum neu rendern zu lassen.</p>
<p>Die <code>Localized</code>-Komponente dient nun als Wrapper-Komponente für unseren neu erstellten Context. In ihr speichern (und ändern!) wir die vom Benutzer ausgewählte Sprache, indem wir den State entsprechend setzen. Wir speichern dazu das <code>defaultLanguageContextValue</code> Objekt im State der Komponente und implementieren hier zusätzlich die <code>changeLanguage()</code>-Methode. Diese empfängt eine Sprache (also <code>de</code> oder <code>en</code>), modifiziert den State entsprechend und holt sich die Übersetzungen für die neu ausgewählte Sprache aus dem <code>translationStore</code> Objekt und schreibt diese als <code>translations</code> neu in den State. Wechselt der User bspw. die Sprache von Deutsch (Voreinstellung) zu Englisch, überschreibt die Funktion alle deutschen Übersetzungen im State mit den englischen Übersetzungen. Durch den Aufruf von <code>this.setState()</code> wird ein Re-Rendering ausgelöst und alle Context-Consumer innerhalb des Komponenten-Baums werden mit dem aktualisierten Wert, den wir in der render()-Methode der Komponente an den Context-Provider übergeben, neu gerendert.</p>
<p>Das ganze klingt jetzt erstmal kompliziert, ist in der Praxis aber tatsächlich gar nicht so schwierig. Ich möchte an dieser Stelle daher dringend dazu ermutigen das obige Beispiel einmal live auszuprobieren.</p>
<p>Übrigens gibt es in der obigen Komponente einen Fallstrick: für gewöhnlich wird der State in einer Klassen-Komponente als erstes definiert und erst danach alle anderen Eigenschaften und Methoden der Klasse. In diesem Fall sind wir jedoch von der Konvention abgewichen und haben die <code>changeLanguage()</code>-Methode zuerst implementiert. Dies hat den einfachen Grund, dass <code>this.changeLanguage</code> ansonsten noch gar nicht definiert, also <code>undefined</code> wäre. Um dies zu umgehen, definieren wir die Methode bevor wir die <code>state</code>-Eigenschaft der Klasse konstruieren.</p>
<p>Nun ist unser Code-Beispiel noch relativ komplex und komplexer als er tatsächlich sein müsste. Und so haben wir hier für die Headline und den Grußtext jeweils eine eigene Komponente erstellt nur um in dieser jeweils einen Context-Consumer zu verwenden, um in diesem wiederum Zugriff auf das Objekt mit unseren Übersetzungen zu haben. Hier lässt sich der Code gleich so optimieren, dass wir eine generische Komponente erstellen um mit dieser direkt auf bestimmte Übersetzungen aus dem <code>translations</code>-Objekt zugreifen zu können. Wir nennen diese Komponente Translated und als einzige Prop erhält sie die Eigenschaft auf die wir im <code>translations</code>-Objekt zugreifen wollen. In unserem konkreten Beispiel kann das also <code>greeting</code> oder <code>headline</code> sein.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> Translated = <span class="hljs-function">(<span class="hljs-params">{ translationKey }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LanguageContext.Consumer</span>&gt;</span>
    {(contextValue) =&gt; contextValue.translations[translationKey]}
  <span class="hljs-tag">&lt;/<span class="hljs-name">LanguageContext.Consumer</span>&gt;</span>
);</span></code></pre>
<p>Unsere <code>App</code>-Komponente sieht dann entsprechend so aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  &lt;Localized&gt;
    &lt;LanguageSelector /&gt;
    &lt;p&gt;
      &lt;Translated translationKey="greeting" /&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;Translated translationKey="headline" /&gt;
    &lt;/p&gt;
  &lt;/Localized&gt;
);</code></pre>
<p>Die <code>Headline</code> und <code>Greeting</code> Komponenten aus dem vorherigen Beispiel können wir uns dann einfach sparen.</p>
<p><strong>Achtung:</strong> gerade bei Übersetzungen ist es nicht unüblich die Schlüssel für die Übersetzungen einfach kurz „key“ zu nennen und so hätte es durchaus einen gewissen Charme auch die Prop in der <code>Translated</code>-Komponente <code>key</code> zu nennen. So wäre das doch schön kurz und gut lesbar:</p>
<pre><code class="hljs jsx language-jsx">&lt;Translated key=<span class="hljs-string">"greeting"</span> /&gt;</code></pre>
<p>Hier macht uns React aber einen Strich durch die Rechnung, da <code>key</code> ein reservierter Name in JSX ist und zur Identifizierung von Elementen dient wenn diese Elemente in einem Array verwendet werden. Die genauen Gründe dazu sind im Kapitel über „Listen, Refs, Fragments und Conditional Rendering“ in „Die Grundlagen“ nachzulesen, dort konkret im Abschnitt „Listen“.</p>
<h3 id="verwendung-mehrerer-contexts">Verwendung mehrerer Contexts</h3>
<p>Es ist kein Problem auch mehrere Context-Provider innerhalb einer Komponenten-Hierarchie zu haben. Das Verschachteln von mehreren Provider-Komponenten ist also kein Problem. Selbst Provider vom selben Context-Typen können ineinander verschachtelt werden. Dabei wird den Consumer-Komponenten stets der Context-Value des nächst höheren Providers übergeben:</p>
<pre><code class="hljs jsx language-jsx">&lt;MyContext.Provider value=<span class="hljs-string">"1"</span>&gt;
  &lt;MyContext.Provider value="2"&gt;
    &lt;MyContext.Consumer&gt;
      {(value) =&gt; &lt;p&gt;Der Wert ist {value}&lt;/p&gt;}
    &lt;/MyContext.Consumer&gt;
  &lt;/MyContext.Provider&gt;
&lt;/MyContext.Provider&gt;</code></pre>
<p>Das obige Beispiel wäre also problemlos möglich. Die Ausgabe wäre hier:</p>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Der Wert ist 2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>
<p>Die <strong>Consumer-Komponente</strong> bezieht ihre daten hier nach aus dem nächsthöheren <strong>Context-Provider</strong>, dieser hat im obigen Beispiel den Wert "2".</p>
<p>Ergibt das Verschachteln von gleichen <strong>Context-Providern</strong> meist relativ wenig Sinn so ist es dennoch keine unübliche oder gar schlechte Praktik verschiedene <strong>Context-Provider</strong> ineinander zu verschachteln. So kann eine Anwendung sehr einfach aus einem Theme-Provider, einem Language-Provider und einem Account-Provider bestehen. Letzterer würde sich dann bspw. um das Daten-Handling des eingeloggten Benutzers kümmern, ggf. Access Tokens oder benutzerspezifische Einstellungen verwalten.</p>
<h3 id="abkürzung-contexttype">Abkürzung: contextType</h3>
<p>Bei der Verwendung von Klassen-Komponenten können wir uns eines Tricks bedienen und auf die Verwendung einer Consumer-Komponente verzichten die unseren Komponenten-Baum weiter aufbläht.</p>
<p>Der <code>contextType</code> ist hier das Stichwort. Dieser kann einer Klassen-Komponente in Form einer gleichnamigen statischen Eigenschaft zugewiesen werden, anschließend kann dann innerhalb der Komponente mittels <code>this.context</code> auf den Wert des jeweiligen Contexts zugegriffen werden. Als Wert bekommt die <code>contextType</code>-Eigenschaft einen Context zugewiesen, der zuvor mittels <code>React.createContext()</code> erzeugt wurde.</p>
<p>Allerdings ist es nur möglich jeder Klasse lediglich <strong>einen einzigen Context-Typen</strong> zuzuweisen. Möchten wir auf den Wert zweier oder mehrerer Contexts müssen wir unser JSX wieder in Consumer-Komponenten wrappen. Bei der Verwendung der <em>Public Class Fields Syntax</em> aus ES2015+ reicht es dazu eine statische Klassen-Eigenschaft <code>contextType</code> zu definieren und dieser einen Context zuzuweisen.</p>
<p>Als Beispiel, angewendet auf die Translated-Komponente von weiter oben, sähe das dann etwa so aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Translated</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">static</span> contextType = LanguageContext;
  render() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.context.translations[<span class="hljs-keyword">this</span>.props.translationKey];
  }
}</code></pre>
<p>Wir weisen der statischen <code>contextType</code>-Eigenschaft der Komponente (die nun eine Klassen-Komponente und keine Function-Component mehr ist) als Wert unseren <code>LanguageContext</code> zu und schon haben wir in <code>this.context</code> den Wert des Contexts zur Verfügung.</p>
<p>Ohne die Verwendung der Public Class Fields Syntax (die ich einige Kapitel vorher allerdings dringend empfohlen habe, da sie uns das Leben an einigen Stellen einfacher macht) sähe der gleiche Code dann folgendermaßen aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Translated</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.context.translations[<span class="hljs-keyword">this</span>.props.translationKey];
  }
}

Translated.contextType = LanguageContext;</code></pre>
<p>Wir würden den <code>contextType</code> also außerhalb der Komponente definieren und nicht mehr innerhalb. Im Grunde genommen ist das aber letztendlich Geschmackssache und hat sonst keine Implikationen oder Nachteile. Es ist allein eine andere Syntax-Variante, die erst in späteren ECMAScript-Versionen oder eben durch Transpiling mittels Babel möglich ist. Möglich gemacht wird sie durch das Babel-Plugin <code>@babel/plugin-proposal-class-properties</code>.</p>
<h3 id="performance-fallstrick">Performance Fallstrick</h3>
<p>React optimiert <strong>Context</strong> unter der Haube massiv um unnötiges Re-Rendering von Komponenten oder gar ganzen Komponenten-Hierarchien bestmöglich zu vermeiden. Zu diesem Zweck wird bei jedem Rendering der alte Context-Wert des Providers mit dem neuen Wert verglichen und <strong>Consumer-Komponenten</strong> anschließend nur dann neu gerendert wenn sich der Wert ihres <strong>Context-Providers</strong> geändert hat.</p>
<p>Was in der Theorie ausnahmsweise mal relativ einfach klingt, bringt aber einen kleinen Stolperstein mit sich. Und zwar betrifft das Consumer-Provider, deren Value innerhalb der <code>render()</code>-Methode einer Komponente stets neu on-the-fly erzeugt werden. Daher empfiehlt es sich normalerweise den Context-Wert außerhalb der render()-Methode zu erzeugen und eine <em>Referenz zum Wert</em> statt eines <em>stets neu erzeugten Werts</em> zu übergeben.</p>
<p>Um dies zu verdeutlichen hier vorab ein Negativ-Beispiel:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>,
  };

  render() {
    &lt;Provider value={{ <span class="hljs-attr">color</span>: <span class="hljs-keyword">this</span>.state.color }}&gt;
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MoreComponents</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>;
  }
}</code></pre>
<p>In diesem Fall erzeugen wir bei jedem neuen Aufruf der render()-Methode ein neues Objekt <code>{color: this.state.color}</code> welches wird als Wert für den Context-Provider benutzen. Da React lediglich überprüft ob die Referenz zum entsprechenden <code>value</code> im aktuellen <code>render()</code>-Aufruf der aus dem vorherigen <code>render()</code>-Aufruf entspricht, dies hier jedoch niemals der Fall ist, da ja ein neues Objekt an Ort und Stelle erzeugt wird, werden hier sämtliche Consumer-Komponenten neu gerendert.</p>
<p>Das obige Beispiel lässt sich jedoch sehr einfach so umschreiben, dass die Performance-Optimierungen von React hier greifen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>,
  };

  render() {
    &lt;Provider value={<span class="hljs-keyword">this</span>.state}&gt;
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MoreComponents</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>;
  }
}</code></pre>
<p>Im zweiten Beispiel übergeben wir lediglich eine <em>Referenz</em> zum <code>state</code>-Objekt der Komponente. Da diese auch beim Re-Rendering der Komponente erhalten bleibt, löst dieses Vorgehen kein Re-Rendering aus, solange sich der Inhalt des States der Komponente nicht ändert!</p>
</div>
<div class="chapter">
  <h1 id="refs">Refs</h1>
<p><strong>Refs</strong> (also <strong>References/Referenzen</strong>) erlauben es in React direkt auf DOM-Elemente zuzugreifen, die während des Render-Prozesses erzeugt wurden. Auch wenn das in React in den meisten Fällen gar nicht notwendig ist, gibt es einige Situationen in denen man nicht drumherum kommt, direkt auf die DOM-Elemente zuzugreifen. Etwa wenn die Position oder die Größe eines Elements benötigt wird, um basierend darauf bspw. ein Tooltip einzublenden oder um ein Eingabefeld mittels <code>.focus()</code> nach dem Laden einer Komponente zu fokussieren.</p>
<p>Hier hat sich React im Laufe der Zeit weiterentwickelt und hat uns so historisch bedingt verschiedene Möglichkeiten geschaffen um solche <strong>Refs</strong> zu erstellen. Die <strong>Refs</strong>, egal in welcher Form, werden dabei stets über die <code>ref</code>-Prop eines DOM-Elements im <strong>JSX</strong> bzw. <code>createElement()</code>-Aufruf definiert.</p>
<p>Doch eine Warnung jedoch gleich noch vorweg: auch wenn React es erlaubt, durch die Verwendung von <strong>Refs</strong> direkt auf DOM-Elemente zuzugreifen, sollte dies nur getan werden, wenn der deklarative Weg, also das Neurendern von Komponenten mit geänderten Props und State, nicht weiterhilft. Sämtliche Manipulation von Attributen oder Attribut-Werten, das Hinzufügen oder Entfernen bspw. von Klassen oder Event-Listenern oder das Ändern von anderen Eigenschaften wie <code>aria-hidden</code> sollte <strong>immer deklarativ</strong> über die Props, den State, JSX und entsprechende Re-Renderings realisiert werden!</p>
<p>Dennoch gibt es einige wenige Fälle in denen die Verwendung einer Ref sinnvoll oder sogar notwendig ist. Dazu gehören:</p>
<ul>
<li>Das Setzen eines Focus auf input-Elemente (<code>input.focus()</code>) oder der Aufruf anderer Methoden wie <code>.play()</code> oder <code>.pause()</code> auf <code>video</code> und <code>audio</code> Elementen</li>
<li>Das Auslösen imperativer Animationen</li>
<li>Das Lesen von Eigenschaften eines Elements im DOM (bspw. via <code>.getBoundingClientRect()</code>)</li>
</ul>
<h3 id="string-refs">String Refs</h3>
<p>Die simpelste und älteste Variante sind die sogenannten <strong>String Refs</strong>. Mittlerweile wird von der Nutzung eher abgeraten, da sie die Performance beeinträchtigen können und in Zukunft ggf. entfernt werden. Der Vollständigkeit halber möchte ich sie dennoch erwähnen, da sie noch Teil der offiziellen API sind und euch gelegentlich auch noch bei der Arbeit mit React begegnen werden, insbesondere wenn ihr mit Legacy-Code zu tun habt.</p>
<p>Um eine <strong>String Ref</strong> zu definieren, gebt ihr einem DOM-Element eine Prop mit dem Namen <code>ref</code> und weist dieser Prop einen <strong>String</strong> als Wert zu. Das enstprechende DOM-Element ist dann <strong>innerhalb der Komponente</strong> in der Instanz-Eigenschaft <code>this.ref</code> zugänglich.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponentWithStringRef</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  componentDidMount() {
    <span class="hljs-keyword">this</span>.refs.username.focus();
  }

  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> /&gt;</span>;
  }
}

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">ComponentWithStringRef</span> /&gt;</span>, document.getElementById('app'));</span></code></pre>
<p>Im obigen Beispiel können wir im <code>componentDidMount()</code> Lifecycle-Hook über <code>this.refs.wrapper</code> auf das umgebende div und über <code>this.refs.username</code> auf das Eingabefeld zugreifen. Über <code>this.refs.username.focus()</code> lässt sich letzteres dann bspw. fokussieren.</p>
<h3 id="callback-refs">Callback Refs</h3>
<p>Eine Alternative zu <strong>String Refs</strong> sind die sogenannten <strong>Callback Refs</strong>. Diese erlauben mehr Flexibilität, sind aber dafür natürlich auch etwas umständlicher zu implementieren, da ihr euch um deren Handling selbst kümmern müsst. Dafür ist es mit <strong>Callback Refs</strong> möglich diese an <strong>Kind-Komponenten</strong> weiterzugeben um auch auf DOM-Elemente innerhalb von diesen zugreifen zu können.</p>
<p><strong>Callback Refs</strong> werden, wie der Name es vermuten lässt, in <strong>Callback-Form</strong> definiert und bekommen beim <strong>Mounting</strong> als einzigen Parameter das DOM-Element oder bei Anwendung auf eine React-Komponente deren Instanz übergeben, beim <strong>Unmounting</strong> wird der Callback erneut aufgerufen, dann allerdings mit <code>null</code> als Parameter.</p>
<p>Was ihr dann damit macht, ist euch selbst überlassen. Ein gängiger Ansatz ist es jedoch, die Referenz zu diesem DOM-Element als Instanz-Eigenschaft zu speichern, um von innerhalb der Komponente überall darauf zugreifen zu können.</p>
<p>Angewendet auf das obige Beispiel sähe das dann so aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponentWithCallbackRef</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  usernameEl = <span class="hljs-literal">null</span>;

  componentDidMount() {
    <span class="hljs-keyword">this</span>.usernameEl.focus();
  }

  setUsernameEl = <span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> {
    <span class="hljs-keyword">this</span>.usernameEl = el;
  };

  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.setUsernameEl}</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> /&gt;</span>;
  }
}

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">ComponentWithCallbackRef</span> /&gt;</span>, document.getElementById('app'));</span></code></pre>
<p><strong>Callback Refs</strong> können auch in Kind-Komponenten benutzt und auf diese <strong>Refs</strong> dann von innerhalb der Eltern-Komponente zugegriffen werden. Dazu übergebt ihr die Callback-Funktion der Kind-Komponente in einer eigenen Prop, die nicht <code>ref</code> heißen darf, da dies ja ein reservierter Name ist:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsernameInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> &lt;input type="text" name="username" ref={this.props.inputRef} /&gt;;
  }
}

class ComponentWithRefChild extends React.Component {
  componentDidMount() {
    this.usernameEl.focus();
  }

  usernameEl = null;

  setUsernameRef = (el) =&gt; {
    this.usernameEl = el;
  };

  render() {
    return (
      &lt;div&gt;
        Username:
        &lt;UsernameInput inputRef={this.setUsernameRef} /&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(&lt;ComponentWithRefChild /&gt;, document.getElementById('app'));</code></pre>
<p>Würdet ihr die Prop hier <code>ref</code> nennen, also <code>&lt;UsernameInput ref={this.setUsernameRef} /&gt;</code> würdet ihr stattdessen eine Referenz zur <code>UsernameInput</code>-<strong>Instanz</strong> erhalten, statt zu deren Input-Element. Bei <strong>Function Components</strong> wäre <code>UsernameInput</code> sogar <code>null</code>, da SFCs nicht instanziiert werden!</p>
<p>Für die weiterleitung von Refs in Kind-Komponenten sollte nach Möglichkeit jedoch die <code>forwardRef()</code>-Methode verwendet werden. Diese wird am Ende dieses Kapitels beschrieben.</p>
<h3 id="refs-über-createref">Refs über createRef()</h3>
<p>Neu in React 16.3. eingeführt wurde die Top Level Methode <code>React.createRef()</code>. Sie ähnelt von der Art der Verwendung her ein wenig den <strong>Callback Refs</strong>, jedoch mit kleinen Unterschieden. So müsst ihr euch auch hier um das Handling selbst kümmern. Durch ihre Ähnlichkeit zu <strong>Callback Refs</strong>, ist es auch hier gängige Praxis die <strong>Refs</strong> einer <strong>Instanz-Eigenschaft</strong> zuzuweisen.</p>
<p>Statt jedoch jedesmal eine nahezu identische Methode in der Form <code>(el) =&gt; { this.property = el }</code> zu übergeben, erstellt ihr bei der Instanziierung der Komponente bereits die Referenz und übergebt diese dann an die <code>ref</code>-Prop des jeweiligen Elements.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponentWithCreatedRef</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  usernameEl = React.createRef();

  componentDidMount() {
    <span class="hljs-keyword">this</span>.usernameEl.current.focus();
  }

  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.usernameEl}</span> /&gt;</span>;
  }
}

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">ComponentWithCreatedRef</span> /&gt;</span>, document.getElementById('app'));</span></code></pre>
<p>Vom Prinzip her also sehr ähnlich zu den <strong>Callback Refs</strong>, allerdings mit einem weiteren entscheidenden Unterschied: auf die entsprechende Referenz greift ihr hier via <code>this.usernameEl.current</code> zu.</p>
<p>Die Referenz zum Element wird hier also nicht in der Instanz-Eigenschaft gespeichert, der ihr die Ref zuordnet, sondern in deren <code>.current</code> Eigenschaft. Ansonsten ist ihr Verhalten soweit vergleichbar mit den Callback Refs. Ihr könnt diese ebenfalls an Kind-Komponenten über deren Props weitergeben und dann aus der Eltern-Komponente auf das jeweilige DOM-Element zugreifen.</p>
<p>Im direkten Vergleich hier noch einmal die <strong>Callback Ref</strong>:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  usernameEl = <span class="hljs-literal">null</span>;

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>
        <span class="hljs-attr">ref</span>=<span class="hljs-string">{(el)</span> =&gt;</span> {
          this.usernameEl = el;
        }}
      /&gt;
    );
  }
}</span></code></pre>
<p>Zugriff auf das Element via: <code>this.usernameEl</code></p>
<p>Und alternativ dazu die mittels <strong><code>React.createRef()</code></strong> erstellte Referenz:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  usernameEl = React.createRef();

  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.usernameEl}</span> /&gt;</span>;
  }
}</span></code></pre>
<p>Zugriff auf das Element via: <code>this.usernameEl.current</code>.</p>
<h3 id="weiterleitung-von-refs">Weiterleitung von Refs</h3>
<p>Das sog. <strong>Ref forwarding</strong>, also die <em>Weiterleitung von Refs</em> (Referenzen zu einer Komponente oder einem DOM Element) ermöglicht es eine Referenz durch eine Komponente hindurch zu einer Kind-Komponente zu übergeben. Dies ist in den aller meisten Fällen nicht notwendig, kann manchmal aber wichtig werden, insbesondere wenn man eine wiederverwendbare Komponenten-Bibliothek erstellt.</p>
<p>Weitergeleitet wird eine Ref über die Methode <code>React.forwardRef()</code>. Sie bekommt dabei als Parameter eine Funktion übergeben an die sie wiederum Props, so wie die Ref übergibt.</p>
<p>Klingt wieder fürchterlich umständlich, werfen wir also einen Blick auf ein Code-Beispiel. Im folgenden implementieren wir zunächst eine eigene Input-Komponente ohne ForwardRef:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> UsernameField = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> (
  &lt;div className="myInput"&gt;
    &lt;input ref={props.ref} {...props} /&gt;
  &lt;/div&gt;
);

class App extends React.Component {
  usernameEl = React.createRef();

  componentDidMount() {
    console.log(this.usernameEl);
  }

  render() {
    return (
      &lt;div className="App"&gt;
        &lt;UsernameField ref={this.usernameEl} /&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</code></pre>
<p>Hier hätten wir in der <code>componentDidMount()</code> Lifecycle Methode keinen Zugriff auf unser Eingabefeld aus der <code>UsernameField</code>-Komponente. Stattdessen wäre die Instanz der Komponente selbst die <strong>Ref</strong>. Da <code>UsernameField</code> jedoch eine <strong>Function Component</strong> ist, existiert nicht mal eine Instanz der Komponente. Somit wäre die <code>console.log</code> Ausgabe an der Stelle: <code>{ current: null }</code> - unschön, wollen wir doch Zugriff auf das <code>input</code>-Element bekommen um es bspw. fokussieren zu können.</p>
<p>Dazu reicht es aus die <code>UsernameField</code>-Komponente von einem <code>React.forwardRef()</code>-Aufruf umschließen zu lassen. Im obigen Beispiel ändern wir die Komponente also wie folgt:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> UsernameField = React.forwardRef(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"myInput"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> {<span class="hljs-attr">...props</span>} /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
));</span></code></pre>
<p>Hier teilen wir React mit, dass es die <code>ref</code>-Prop auf dem <code>UsernameField</code> in unserer <code>App</code>-Komponente bitte an die Komponente weiterleiten soll. Diese bekommt die <strong>Ref</strong> dann als zweiten Parameter der Funktion übergeben und kann diese an ein beliebiges Element im DOM oder auch an eine weitere Komponente weiterreichen.</p>
<p>Wird die <strong>Ref</strong> an eine weitere Komponente tiefer im Baum weitergereicht sollte beachtet werden dass hier die selben Restriktionen gelten: die entsprechende Komponente muss entweder eine Klassen-Komponente sein - dann würde die Referenz auf die Instanz der Klasse zeigen - oder die Komponente muss ihrerseits wiederum eine Ref-Weiterleitung via <code>forwardRef()</code> machen.</p>
<h4 id="vorsicht-bei-higher-order-components">Vorsicht bei Higher Order Components!</h4>
<p>Bei der Implementierung von <strong>Higher Order Components</strong> ist Vorsicht geboten. Ist unklar ob in ihnen auf weitergeleitete Refs zugegriffen werden soll, müssen sie selbst von einem <code>forwardRef()</code>-Aufruf umschlossen werden.</p>
<p>Erweitern wir unser Beispiel von oben und nehmen an, wir wollen eine <strong>HOC</strong> erstellen um Formular-Elemente in einem bestimmten einheitlichen Stil anzuzeigen. Dazu erstellen wir die <strong>HOC</strong> <code>withInputStyles</code>. Diese kann und wird <code>input</code>-Elemente umschließen und in diesen soll es nicht ausgeschlossen sein, dass wir ihnen eine Ref zuweisen.</p>
<p>Das ganze Verfahren ist etwas kompliziert und es fiel mir enorm schwer es in Worte zu fassen die leicht verständlich gewesen wären, weshalb ich hier stattdessen einmal mehr den mit Kommentaren versehenen Code sprechen lassen möchte. Sobald das Prinzip von <strong>Higher Order Components</strong> und <strong>forwardRefs</strong> klar ist, sollte das Beispiel ausreichend sein um die Implementierung zu verstehen. Und selbst wenn nicht ein kleiner Trost vorab: das ist ein Anwendungsfall der in der Praxis so selten sein sollte, dass man ihm in den seltensten Fällen in einer echten Anwendung benötigen wird.</p>
<p>Der Vollständigkeit halber möchte ich ihn hier dennoch erwähnt haben. Hier also das Beispiel:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> withInputStyles = <span class="hljs-function">(<span class="hljs-params">InputComponent</span>) =&gt;</span> {
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WithInputStyles</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    render() {
      <span class="hljs-comment">// Wir holen uns die weitergeleitete Ref aus den Props der Komponente</span>
      <span class="hljs-keyword">const</span> { forwardedRef, ...props } = <span class="hljs-keyword">this</span>.props;

      <span class="hljs-comment">// ... und setzen sie als Ref für die von der HOC umschlossenen</span>
      <span class="hljs-comment">// Komponente ein:</span>
      <span class="hljs-keyword">return</span> (
        &lt;InputComponent
          {...props}
          ref={forwardedRef}
          style={{ border: '2px solid black', padding: 8 }}
        /&gt;
      );
    }
  }

  // Wir geben einen ForwardRef aus der HOC zurück
  return React.forwardRef((props, ref) =&gt; (
    // Wir geben die Ref als temporäre Prop `forwardedRef` weiter
    &lt;WithInputStyles {...props} forwardedRef={ref} /&gt;
  ));
};

// Hier leiten wir die Ref unserer Komponente an das input weiter mittels
// eines gewöhnlichen React.forwardRef()-Aufrufs
const UsernameField = React.forwardRef((props, ref) =&gt; (
  &lt;input ref={ref} {...props} /&gt;
));

// Hier verbinden wir die HOC mit unserer UsernameField-Komponente
const StyledUsername = withInputStyles(UsernameField);

class App extends React.Component {
  // Hier wird ganz gewöhnlich die Ref erstellt auf die wir später zugreifen
  usernameEl = React.createRef();

  componentDidMount() {
    this.usernameEl.current.focus();
  }

  render() {
    return (
      &lt;div&gt;
        &lt;StyledUsername ref={this.usernameEl} /&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
</div>
<div class="chapter">
  <h1 id="error-boundaries">Error Boundaries</h1>
<p>Tritt innerhalb einer React-Anwendung ein Fehler auf und wird eine Exception geworfen führt dies unter Umständen dazu, dass die Anwendung nicht mehr angezeigt wird und der Benutzer nur noch einen weißen Bildschirm sieht. Um dieses unschöne Verhalten zu unterbinden wurden in React 16.0 die sog. <strong>Error Boundaries</strong> eingeführt.</p>
<p>Dabei handelt es sich um eine bestimmte Art von Komponente die diverse Fehler <strong>innerhalb ihrer Kind-Hierarchie</strong> abfangen und verarbeiten kann und im Falle eines Fehlers einen alternativen Seitenbaum rendern kann, um den Benutzer vor dem völligen Absturz und dem Anblick eines <em>weißen Screens</em> zu bewahren. <strong>Error Boundaries</strong> agieren also stets als Eltern-Komponente eines Seitenbaums. Kommt es in einer Komponente innerhalb dieses Seitenbaums zu einem Fehler springt die Error Boundary ein und kümmert sich um das Handling des entsprechenden Fehlers. Man kann dieses Verhalten durchaus als eine besondere Art eines <code>try</code>/<code>catch</code> Blocks für Komponenten-Hierarchien verstehen.</p>
<p>Sie kümmern sich dabei um die Behandlung von Fehlern die aus einer der folgenden Situationen resultieren:</p>
<ul>
<li>Fehler in <strong>Lifecycle-Methods</strong></li>
<li>Fehler in der <code>render()</code>-Methode irgendwo <strong>unterhalb</strong> der Error Boundary</li>
<li>Fehler im <code>constructor()</code> einer Komponente</li>
</ul>
<p>Tritt in einer Lifecycle-Methode, einer <code>render()</code>-Methode oder im Constructor einer Komponente nun ein Fehler auf, wird dieser von der <strong>Error Boundary</strong> abgefangen. Diese kann dann mit einer Fallback-Darstellung reagieren, dem Benutzer zum Neustarten der Anwendung auffordern oder darüber informieren was falsch gelaufen ist. Ähnlich wie Context-Komponenten können auch Error Boundaries ineinander verschachtelt werden. Tritt dann ein Fehler auf, greift die Implementierung der nächst höheren Error Boundary Komponente.</p>
<div class="hint hint--info">
<p><strong>Achtung:</strong> bei <strong>Error Boundary</strong>-Komponenten geht es primär um das Abfangen und die Behandlung von <strong>User Interface spezifischen Fehlern</strong> die das Rendering eines bestimmten Applikations-Status unmöglich machen. Zwar wäre es auch denkbar etwa Formular-Validierung mittels Error Boundaries zu implementieren, das würde aber dem angedachten Zweck widersprechen und ist daher nicht zu empfehlen!</p>
</div>
<p>Es gibt auch Situationen in denen Error Boundaries nicht greifen. Dies ist der Fall:</p>
<ul>
<li>in Event-Handlern</li>
<li>in asynchronem Code, wie bspw. <code>setTimeout()</code> oder <code>requestAnimationFrame()</code></li>
<li>bei serverseitig gerenderten Komponenten (Server Side Rendering)</li>
<li>bei Fehlern, die in der <strong>Error Boundary</strong> selbst auftreten</li>
</ul>
<p>In diesen Situationen greift eine <strong>Error Boundary</strong> <em>nicht</em>, da es entweder nicht möglich oder nicht nötig ist. Wirft bspw. ein Event-Handler einen Fehler betrifft das nicht direkt das Rendering und React kann weiterhin ein User Interface anzeigen. Es wird dann eben nur keine entsprechende Interaktion basierend auf dem stattgefundenen Event mehr ausgeführt.</p>
<h3 id="eine-error-boundary-implementieren">Eine Error Boundary implementieren</h3>
<p>Für die Implementierung einer <strong>Error Boundary</strong> gibt es zwei einfache Regeln:</p>
<ol>
<li>nur Klassen-Komponenten können zu einer <strong>Error Boundary</strong> werden</li>
<li>eine Klasse muss entweder die statische Methode <code>getDerivedStateFromError()</code> oder die Klassen-Methode <code>componentDidCatch()</code> implementieren oder auch gleich beide Methoden</li>
</ol>
<p>Eine <strong>Error Boundary</strong> ist also aus technischer Sicht lediglich eine Komponente die eine der beiden o.g. Methoden oder gleich beide implementiert. Ansonsten gelten für sie genau die gleichen Regeln wie für andere Klassen-Komponenten auch.</p>
<p>Sehen wir uns also eine einfache Implementierung einer <strong>Error Boundary</strong> einmal an:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span>,
  };

  <span class="hljs-keyword">static</span> getDerivedStateFromError(error) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span>,
      error,
    };
  }

  componentDidCatch(error, info) {
    <span class="hljs-built_in">console</span>.log(error, info);
  }

  render() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.hasError) {
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Ein Fehler ist aufgetreten.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.props.children;
  }
}</code></pre>
<p>Wir definieren also zuerst einmal eine neue Komponente. Diese heißt hier <code>ErrorBoundary</code>, das ist jedoch kein vorgeschriebener Name der zwingend notwendig ist. Der Name einer <strong>Error Boundary</strong> Komponente kann hier grundsätzlich genauso frei gewählt werden wie bei jeder anderen Komponente auch, er muss lediglich den Regeln für Komponentennamen entsprechen. Also im Wesentlichen mit einem Großbuchstaben anfangen und ein gültiger JavaScript-Funktionsname sein.</p>
<p>Ich empfehle dennoch der besseren Übersicht halber bereits im Namen der Komponente erkennbar zu machen, dass es sich um eine Komponente handelt, die insbesondere zur Fehlerbehandlung dient. Also bspw. Namen wie <code>AppErrorBoundary</code> oder <code>DataTableErrorFallback</code>. So wird auch dem neuen Kollegen im Projekt schnell klar welchen Zweck die entsprechende Komponente erfüllt.</p>
<p>Im obigen Beispiel initialisieren wir einen State in der Komponente mit der Eigenschaft <code>hasError</code> und dessen Standardwert <code>false</code>. Schließlich ist beim Initialisieren der Komponente normalerweise noch kein Fehler aufgetreten.</p>
<p>Als nächstes sehen wir die statische <code>getDerivedStateFromError()</code>-Methode. An dieser Stelle signalisieren wir React, dass wir es mit einer Komponente zu tun haben die als <strong>Error Boundary</strong> fungiert und die zum Einsatz kommt wenn unterhalb der Komponente (also in den Kind-Elementen) ein Fehler auftritt. Die Methode bekommt ein <code>error</code>-Objekt hereingereicht, das auch dem Objekt entspricht, den der <code>catch</code>-Block bei einem <code>try</code>/<code>catch</code> übergeben bekommt.</p>
<p>Die Methode funktioniert sehr ähnlich wie auch die <code>getDerivedStateFromProps()</code>-Methode in den Lifecycles. Sie kann ein Objekt oder <code>null</code> zurückgeben und damit einen neuen State erzeugen oder eben alles beim Alten belassen, dazu muss sie lediglich <code>null</code> zurückgeben. Im Beispiel setzen wir die <code>hasError</code>-Eigenschaft auf <code>true</code> und speichern zusätzlich das <code>error</code>-Objekt im State. Da die Methode statisch ist kann sie jedoch nicht auf andere Methoden der Komponente zugreifen.</p>
<p>Die <code>getDerivedStateFromError()</code>-Methode wird während der <em>Render</em>-Phase ausgeführt. Also während React den letzten Stand des Komponenten-Baums mit dem aktuellen vergleicht und bevor die neuen Änderungen letztlich in den DOM geschrieben (<em>„commited“</em>) werden.</p>
<p>Ebenfalls implementiert haben wir hier die <code>componentDidCatch()</code>-Methode. Diese bekommt als ersten Parameter das Error-Objekt übergeben, als zweiten Parameter eine React eigene Info. Diese enthält den <em>„Component Stack“</em>, also die Information darüber in welcher Komponente der Fehler aufgetreten ist und welche Kind-Komponenten und Kindes-Kind-Komponenten involviert waren, bildet also den Komponenten-Baum bis zur fehlerhaften Komponente ab. Soll ein externer Service zum loggen der Errors benutzt werden ist hier der richtige Ort dafür, denn das ist der beabsichtigte Zweck dieser Methode. Hier sollen Side Effects stattfinden. Die Methode wird erst in der <em>Commit</em>-Phase ausgefüht, also nachdem React die Änderungen am State im DOM abgebildet hat.</p>
<p>Da <code>componentDidCatch()</code> keine statische Methode ist, wäre es hier zwar auch möglich den State der Komponente mittels <code>this.setState()</code> zu modifizieren, allerdings ist geplant dies in Zukunft zu unterbinden weshalb hier mit Bedacht vorgegangen werden sollte. Der bessere Weg ist in jedem Fall die statische <code>getDerivedStateFromError()</code>-Methode zu verwenden um einen neuen State nach Auftreten eines Fehlers zu erzeugen und auf den Fehler zu reagieren.</p>
<p>Zuletzt reagieren wir auf einen möglicherweise aufgetretenen Fehler in unserer render()-Methode. Ist die <code>hasError</code>-Eigenschaft im State der Komponente <code>true</code> wissen wir, dass ein Fehler aufgetreten ist und geben eine Meldung <code>&lt;h1&gt;Ein Fehler ist aufgetreten&lt;/h1&gt;</code> auf. Ist alles in Ordnung geben wir lediglich die Kind-Elemente der Komponente (<code>this.props.children</code>) zurück. Wie genau auf den Fehler reagiert wird bleibt dabei dem Entwickler überlassen. Denkbar wäre es bei schweren Fehlern den Benutzer zum Neuladen der Anwendung aufzufordern oder bei kleineren Fehlern nur einen Hinweis an Ort und Stelle anzuzeigen, dass eine Komponente momentan nicht angezeigt werden kann.</p>
<h3 id="eine-error-boundary-verwenden">Eine Error Boundary verwenden</h3>
<p>Wir wissen nun wie wir eine <strong>Error Boundary</strong> implementieren: durch das Hinzufügen von <code>static getDerivedStateFromError()</code> oder <code>componentDidCatch()</code> in einer Komponente. <strong>Error Boundaries</strong> sollten dabei so unabhängig wie möglich sein und wenig bis gar keine eigene Logik implementieren oder gar zu eng an bestimmte Komponenten gekoppelt werden. Wie granular eine solche <strong>Error Boundary</strong> aber letztendlich ist liegt in der Entscheidung des Entwicklers.</p>
<p>So ist es in komplexen Anwendungen durchaus sinnvoll verschiedene, auch ineinander verschachtelte, <strong>Error Boundaries</strong> zu haben die jeweils unterschiedliche Fehlerfälle abdecken. Eine, die sich um die komplette Anwendung legt und Fehler sämtliche Fehler abfängt, eine weitere für bestimmte Bereiche im Seitenbaum die vielleicht nur optional sind. Schauen wir uns auch das einmal anhand eines Beispiels an:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ApplicationLogic</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ServiceUnavailableBoundary</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">WeatherWidget</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">ServiceUnavailableBoundary</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span></span>
  );
};

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.querySelector('#root'));</span></code></pre>
<p>Hier haben wir es mit zwei Error Boundary Komponenten zu tun: <code>ErrorBoundary</code> und <code>ServiceUnavailableBoundary</code>. Während die äußere <code>ErrorBoundary</code>-Komponente durchaus 1:1 das obige Beispiel repräsentieren könnte, also lediglich ein <code>&lt;h1&gt;Ein Fehler ist aufgetreten.&lt;/h1&gt;</code> ausgibt sollte in der <code>ApplicationLogic</code>-Komponente ein fehler auftreten könnte die <code>ServiceUnavailableBoundary</code>-Komponente eine alternative Meldung ausgeben wie bspw <em>„Der angeforderte Dienst ist momentan nicht erreichbar. Bitte versuchen Sie es später wieder“</em>, wenn der Fehler in der (fiktiven) <code>WeatherWidget</code>-Komponente auftritt.</p>
<p>Tritt in der <code>WeatherWidget</code>-Komponente ein Fehler auf wird dieser dann von der <code>ServiceUnavailableBoundary</code> abgefangen und alles was in der <code>ApplicationLogic</code>-Komponente gerendert wird bleibt intakt! Würden wir das <code>WeatherWidget</code> nicht in seiner eigene <strong>Error Boundary</strong> einschließen, würde die äußere <strong>Error Boundary</strong> greifen und auch die <code>ApplicationLogic</code>-Komponente nicht mehr anzeigen!</p>
<p>Generell lässt sich sagen dass es empfehlenswert ist immer mindestens eine <strong>Error Boundary</strong> in seiner Anwendung zu haben die sich möglichst weit oben in der Komponenten-Hierarchie befindet und sämtliche unerwartete Fehler abfängt (und möglichst logged!) und ähnlich wie eine <code>500 Internal Server Error</code> Seite agiert. Nach Bedarf kann und sollte man dann weitere <strong>Error Boundaries</strong> hinzufügen und bestimmte Seitenbäume damit umschließen. Je nachdem wie groß die Gefahr eines Rendering-Fehlers in einem bestimmten Bereich eines Baums ist (bspw. weil man mit unbekannten oder mit sich-ändernden Daten zu tun hat) oder wie stark vernachlässigbar ein bestimmter Komponentenbaum ist.</p>
<div class="hint hint--info">
<p>Seit Version 16 werden Komponenten in denen ein schwerer Fehler auftritt, kurz gesagt in denen ein Error/Exception geworfen wird durch React komplett „unmounted“ und verschwinden aus dem Seitenbaum. Dies ist wichtig, damit bei einem unbehandelten Fehler das User Interface nicht plötzlich in einem unerwarteten und fehlerhaften Zustand bleibt. Dies ist bspw. in einer Online-Banking Anwendung kritisch, wenn Überweisungen dann an einen falschen Empfänger gehen oder ein falscher Betrag überwiesen wird.</p>
<p>Um derartige Fehler im Rendering von Komponenten vernünftig behandeln zu können wurden die <strong>Error Boundaries</strong> eingeführt. Durch sie können Benutzer auf den Fehlerhaften Zustand der Anwendung hingewiesen werden. Da Fehler in einer Anwendung nie ganz ausgeschlossen werden können (Benutzer können hier sehr einfallsreich sein!) ist die Verwendung von <strong>Error Boundaries</strong> sehr zu empfehlen!</p>
</div>
</div>
<div class="chapter">
  <h1 id="portals">Portals</h1>
<p>Mit <strong>Portals</strong> (dt. <em>Portale</em>) bietet React die Möglichkeit Komponenten in DOM Nodes zu rendern, die sich <em>außerhalb</em> der Parent-Node der jeweiligen Komponenten-Hierarchie befinden, die aber dennoch Zugriff auf die aktuelle Komponenten-Umgebung haben. Ein möglicher (aber bei weitem nicht ihr einziger) Anwendungsfall hierfür sind u.a. Overlays, die in einem eigenen <code>&lt;div&gt;</code> außerhalb der tatsächlichen Anwendung gerendert werden.</p>
<p>Ein Portal befindet sich dabei weiter im Kontext der Komponente die das Portal erstellt, hat also Zugriff auf alle Daten die in der Eltern-Komponente zur Verfügung stehen, wie etwa die Props oder den State, befindet sich im HTML jedoch an einer ggf. völlig anderen Stelle als die restliche Anwendung. Dies ist wichtig wenn innerhalb des Portals bspw. auf Daten aus dem State der Eltern-Komponente oder wenn auf einen gemeinsamen Context wie bspw. Übersetzungen zugegriffen werden soll.</p>
<h3 id="ein-portal-erstellen">Ein Portal erstellen</h3>
<p>Die Erstellung eines solchen Portals ist dabei denkbar einfach. So muss eine Komponente dazu lediglich die <code>createPortal()</code>-Methode aus ReactDOM aufrufen, ihr eine gültige Komponente als <em>ersten</em> und eine (existierende) Ziel-Node als <em>zweiten</em> Parameter übergeben.</p>
<p>Nehmen wir einmal folgendes HTML-Dokument an:</p>
<pre><code class="hljs markup language-markup"><span class="hljs-meta">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Portale in React<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-comment">&lt;!-- hier befindet sich unsere React App --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"portal"</span>&gt;</span><span class="hljs-comment">&lt;!-- und hier landet gleich der Inhalt unseres Portals --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Und dazu die folgende einfache React App:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Portale in React<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.querySelector('#root'));</span></code></pre>
<p>Da wir unsere <code>&lt;App /&gt;</code> in das <code>div</code> mit der id <code>root</code> rendern, sähe der <code>&lt;body&gt;</code> unserer obigen App nun entsprechend wie folgt aus:</p>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Portale in React<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"portal"</span>&gt;</span><span class="hljs-comment">&lt;!-- und hier landet gleich der Inhalt unseres Portals --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>Jede weitere Komponente bzw. jedes weitere HTML Element, das wir im JSX unserer App-Komponente verwenden würde entsprechend im root-div landen. Außer eben, es handelt sich um ein <strong>Portal</strong>. Eine solche Komponente würde dann so aussehen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> PortalExample = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> ReactDOM.createPortal(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hallo aus dem Portal<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,
    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#portal'</span>)
  );
};</code></pre>
<p>Neben dem JSX das wir an der Stelle ausgeben möchten geben wir also noch den Ziel-Container an und verpacken beides zusammen hübsch in einem <code>ReactDOM.createPortal()</code>-Aufruf, den wir dann statt des reinen JSX aus der Komponente (bzw. aus der <code>render()</code>-Methode bei Class Components) zurückgeben. Ergänzen wir unsere Beispiel-App von oben, sähe die Benutzung wie folgt aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Portale in React<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">PortalExample</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.querySelector('#root'));</span></code></pre>
<p>Der <code>&lt;body&gt;</code> unseres HTML-Dokuments ist dann folgender:</p>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Portale in React<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"portal"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hallo aus dem Portal<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>Das Portal wird also in die <code>#portal</code> Node gerendert statt in die <code>#root</code> Node, in der sich die Komponente befindet. Dabei wird ein Portal immer dann gerendert wenn die Komponente <em>gemounted</em> wird und folglich auch wieder aus dem DOM <em>entfernt</em> wenn die Komponente, die das Portal enthält aus dem Komponenten-Baum entfernt wird.</p>
<h3 id="ein-portal-im-zusammenspiel-mit-seiner-eltern-komponente">Ein Portal im Zusammenspiel mit seiner Eltern-Komponente</h3>
<p>Um die Funktionsweise eines Portals noch einmal deutlicher zu demonstrieren entwickeln wir im nächsten Schritt – Überraschung – ein Modal-Portal. Als Ausgangsbasis nutzen wir hierbei das identische HTML wie auch schon in der Einleitung zuvor. Wir haben also zwei divs, in die wir einmal unsere Anwendung und einmal unser Portal rendern.</p>
<p>Das Portal öffnen wir diesmal jedoch erst, nachdem der Benutzer einen Button geklickt hat. Im Portal selbst befindet sich dann ein Button der das Fenster wieder schließt. Dabei setzen wir die State-Eigenschaft <code>modalIsOpen</code> in der Eltern-Komponente entsprechend auf <code>true</code> oder <code>false</code>. Die <code>ModalPortal</code>-Komponente rendern wir über ein <code>&amp;&amp;</code> Conditional in JSX, also nur dann, wenn der Wert von <code>this.state.modalIsOpen</code> auch tatsächlich <code>true</code> ist.</p>
<p>In dem Moment, in dem der Wert von <code>false</code> auf <code>true</code> wechselt, wird die <code>ModalPortal</code>-Komponente gemounted und das Modal-Popup wird mit einem leicht transparenten schwarzen Hintergrund in das <code>&lt;div id="portal"&gt;</code> gerendert. Wechselt der Wert von <code>true</code> zurück auf <code>false</code> nehmen wir es in der App-Komponente aus der Komponenten-Hierarchie heraus und React sorgt dann automatisch dafür, dass sich die <code>ModalPortal</code>-Komponente mitsamt ihres Inhalts nicht mehr in der Seite befindet.</p>
<p>Und im Code ergibt das dann das folgende Bild:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> ModalPortal = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> ReactDOM.createPortal(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>
      <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span>
        <span class="hljs-attr">background:</span> '<span class="hljs-attr">rgba</span>(<span class="hljs-attr">0</span>,<span class="hljs-attr">0</span>,<span class="hljs-attr">0</span>,<span class="hljs-attr">0.7</span>)',
        <span class="hljs-attr">height:</span> '<span class="hljs-attr">100vh</span>',
        <span class="hljs-attr">left:</span> <span class="hljs-attr">0</span>,
        <span class="hljs-attr">position:</span> '<span class="hljs-attr">fixed</span>',
        <span class="hljs-attr">top:</span> <span class="hljs-attr">0</span>,
        <span class="hljs-attr">width:</span> '<span class="hljs-attr">100vw</span>',
      }}
    &gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">background:</span> '<span class="hljs-attr">white</span>', <span class="hljs-attr">margin:</span> <span class="hljs-attr">16</span>, <span class="hljs-attr">padding:</span> <span class="hljs-attr">16</span> }}&gt;</span>
        {props.children}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'portal'</span>)
  );
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">modalIsOpen</span>: <span class="hljs-literal">false</span>,
  };

  openModal = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">modalIsOpen</span>: <span class="hljs-literal">true</span> });
  };

  closeModal = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">modalIsOpen</span>: <span class="hljs-literal">false</span> });
  };

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Portale in React<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.openModal}</span>&gt;</span>Modal öffnen<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        {this.state.modalIsOpen &amp;&amp; (
          <span class="hljs-tag">&lt;<span class="hljs-name">ModalPortal</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Dieser Teil wird in einem Modal-Fenster geöffnet.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.closeModal}</span>&gt;</span>Modal schließen<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">ModalPortal</span>&gt;</span>
        )}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Ein besonderer Augenmerk gilt hier der <code>this.closeModal</code> Methode. Diese wird als Methode der App-Komponente definiert, wird aber innerhalb der <code>ModalPortal</code>-Komponente beim Klick auf den „Modal schließen“-Button im Kontext der <code>App</code>-Komponente aufgerufen.</p>
<p>Sie kann also problemlos den <code>modalIsOpen</code> State der Komponente verändern. Und das, obwohl die Komponente sich gar nicht innerhalb <code>&lt;div id="root&gt;</code> befindet, wie der Rest unserer kleinen App. Dies ist möglich, da es sich eben um ein Portal handelt, deren Inhalt sich <strong>aus React-Sicht</strong> im selben Komponenten-Baum wie die App selbst befindet, nicht jedoch <strong>aus HTML-Sicht</strong>.</p>
</div>
<div class="chapter">
  <h1 id="code-splitting">Code Splitting</h1>
<p>Wer ein Projekt mit React entwickelt nutzt in den allermeisten Fällen auch einen <strong>Bundler</strong> wie <strong>Webpack,</strong> <strong>Browserify</strong> oder <strong>Rollup</strong>. Diese sorgen dafür, dass alle einzelnen Dateien, alle Imports, später zu einer einzigen großen Dateien gebündelt wird die dann relativ einfach deployed werden kann ohne dass sich ein Entwickler noch all zu viele Gedanken um relative Verlinkungen machen muss. Dieser Vorgang wird dementsprechend <strong>Bundling</strong> genannt. In sehr großen und komplexen Projekten kann so ein <strong>Bundle</strong> schnell mal ein Megabyte groß oder gar größer werden, insbesondere wenn viele Third Party Bibliotheken im Einsatz sind. Das ist in vielerlei Hinsicht ein Problem, denn große Bundles benötigen länger um vom Browser heruntergeladen zu werden und auch das Ausführen unnötig großer Bundles führt unweigerlich zu Performance-Einbußen.</p>
<p>Um dem Problem der großen Bundles zu begegnen gibt es das sog. <strong>Code Splitting</strong>. Beim Code Splitting wird die Anwendung in mehrere kleinere Bundles aufgesplittet die allesamt für sich allein gesehen lauffähig sind und weitere Bundles nachladen, sollten diese später benötigt werden. So ist die Aufteilung in ein Bundle mit den meist benutzten Abhängigkeiten (bspw. React, React DOM, …) und jeweils ein Bundle pro Route eine recht gängige Methode beim <strong>Code Splitting</strong>.</p>
<p>Die einfachste Methode dazu ist die Verwendung der <strong>Dynamic Import Syntax</strong>. Diese ist momentan ein Proposal beim <strong>TC39</strong>, befindet sich also momentan im Standardisierungsprozess. Dank Webpack und Babel ist es aber auch heute schon möglich die Verwendung zu benutzen. Notwendig ist hierfür das Babel Plugin <code>@babel/plugin-syntax-dynamic-import</code>. <strong>Create React App</strong> und andere Tools wie <strong>next.js</strong> oder <strong>Gatsby</strong> bringen von Haus aus Unterstützung für dynamische Imports mit und müssen nicht speziell für die Verwendung von <strong>Code Splitting</strong> konfiguriert werden.</p>
<h3 id="verwendung-dynamischer-imports">Verwendung dynamischer Imports</h3>
<p>Im Kapitel zu ES2015+ wurde die Import-Syntax bereits angesprochen. Die <strong>Dynamic Import Syntax</strong> ist eine Erweiterung dieser und erlaubt es innerhalb einer Anwendung Imports dynamisch nachzuladen, daher der Name. Dabei funktioniert ein dynamischer Import nicht anders als ein Promise:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// greeter.js</span>
<span class="hljs-keyword">export</span> sayHi = <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> <span class="hljs-string">`Hi <span class="hljs-subst">${name}</span>!`</span>;</code></pre>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// app.js</span>
<span class="hljs-keyword">import</span>(<span class="hljs-string">'./greeter'</span>).then(<span class="hljs-function">(<span class="hljs-params">greeter</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(greeter.sayHi(<span class="hljs-string">'Manuel'</span>); <span class="hljs-comment">// "Hi Manuel!"</span>
});</code></pre>
<p>Findet Webpack einen dynamischen Import nutzt es an dieser Stelle automatisch seine Code-Splitting Funktion und lagert die entsprechende Datei beim Erstellen des Bundles in einen eigenen sog. <em>Chunk</em> aus, also sozusagen ein Teilstück, den es dann selbstständig lädt sobald dieser in der Anwendung benötigt wird. Dieses Verhalten wird allgemein als <strong>Lazy Loading</strong> bezeichnet, also etwa „Verzögertes Laden“.</p>
<h3 id="verzögertes-laden-von-komponenten-mit-reactlazy">Verzögertes Laden von Komponenten mit React.lazy()</h3>
<p>Und damit wären wir auch schon beim nächsten Thema: <strong>Lazy Loading mit React</strong>. Um die Entwickler-Erfahrung beim <strong>Lazy Loading</strong> möglichst angenehm zu gestalten, bietet React seit Version <strong>16.6.</strong> eine hauseigene Methode um Komponenten dynamisch nachzuladen. Diese wird kombiniert mit der <strong>Dynamic Import Syntax</strong> und erlaubt es dem Entwickler bestimmte React-Komponenten erst zur Laufzeit der Anwendung zu laden und so die Größe der Bundles weiter zu verkleinern.</p>
<p>Ein via <code>React.lazy()</code> geladener Import kann in React als gewöhnliche Komponente verwendet werden. Ihr können Props übergeben werden wie auch Refs. Sie kann eigene Kind-Elemente beinhalten oder in sich geschlossen sein. Die Methode erwartet eine Funktion als Parameter, die einen dynamischen Import zurückgibt. Dieser Import muss eine Komponente importieren, die einen Default Export hat, die wiederum eine React-Komponente sein muss:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// LazyLoaded.js</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> LazyLoaded = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Diese Komponente wird erst bei ihrer Verwendung vom Server geladen<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
);</code></pre>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// app.js</span>
<span class="hljs-keyword">import</span> React, { Suspense } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> LazyLoaded = React.lazy(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./LazyLoaded.js'</span>));

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">div</span>&gt;</span>Anwendung wird geladen<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">LazyLoaded</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>
);

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>In komplexen Komponenten und insbesondere bei wachsenden Anwendungen kann man so sehr schön die Größe des JavaScript-Bundles optimieren und relevante Dateien erst dann vom Server laden wenn diese wirklich benötigt werden. Während die Datei vom Server geladen bis sie schließlich ausgeführt wurde wird an der Stelle der Komponente der Hinweis <code>&lt;div&gt;Anwendung wird geladen&lt;/div&gt;</code> angezeigt. Dafür sorgt eine weitere Neuerung, die in Version <strong>16.6.</strong> den Weg in React fand:</p>
<h3 id="darstellung-von-platzhaltern-mit-reactsuspense">Darstellung von Platzhaltern mit React.Suspense</h3>
<p>Die <code>Suspense</code>-Komponente auf dem React-Objekt hieß in ihrer ursprünglichen Version einmal <strong>Placeholder</strong> (dt. <em>Platzhalter</em>) und das beschreibt ziemlich genau was sie macht: sie agiert als Platzhalter für Komponenten die noch nicht geladen wurden und rendert eine Alternative. Dies kann wie im obigen Beispiel bspw. eine Nachricht sein, dass Teile der Anwendung geladen werden oder auch eine ganz klassische Lade-Animation. Der Platzhalter wird dabei als <code>fallback</code>-Prop angegeben und muss zwingend definiert werden. Als gültiger Wert der Prop kann jedes beliebige valide React-Element verwendet werden. Dazu gehören auch Strings. <code>&lt;Suspense fallback="Wird geladen"&gt;[…]&lt;/Suspense&gt;</code> wäre demnach also ebenfalls ein valider Platzhalter.</p>
<p>Solange die zu ladende Komponente noch nicht vollständig geladen wurde, werden dann sämtliche Kind-Elemente des <code>Suspense</code>-Elements durch den festgelegten Platzhalter ersetzt und erst wenn die Komponente vollständig geladen wurde durch den eigentlichen Inhalt ersetzt. Dabei können beliebig viele via <code>React.lazy()</code> geladene Komponenten innerhalb eines <code>Suspense</code>-Elements verwendet werden. Der <code>fallback</code>-Platzhalter wird dann so lange angezeigt bis <strong>sämtliche</strong> Komponenten vollständig geladen sind und angezeigt werden können!</p>
<p>Auch eine Verschachtelung ist möglich und teilweise sogar sinnvoll. Gibt es z.B. Teile in der Seite die eher unwichtig sind und das Rendering des User Interfaces nicht verzögern sollten wenn andere, wichtigere Teile bereits geladen sind, so kann der entsprechende Seitenbaum von einem eigenen <code>Suspense</code>-Element umschlossen werden. Dies führt dazu, dass die anderen, möglicherweise wichtigeren Teile des Interfaces angezeigt werden sobald diese geladen sind, während für die anderen, unwichtigeren Teile erneut ein Platzhalter angezeigt wird.</p>
<p>Ein denkbares Szenario könnte eine Anwendung zur Bildbearbeitung sein. Hier kann es sinnvoll sein das zu bearbeitende Bild bereits anzuzeigen sobald die Komponente, die für die Anzeige des Bildes verantwortlich ist, geladen wurde. Das User Interface mit den eigentlichen Funktionen zur Bearbeitung wird dann erst im nächsten Schritt angezeigt, sollte das Laden der entsprechenden Komponente länger dauern. Und nur dann.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React, { Suspense } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> ImageCanvas = React.lazy(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./ImageCanvas'</span>));
<span class="hljs-keyword">const</span> ImageToolbar = React.lazy(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./ImageToobar'</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">div</span>&gt;</span>Anwendung wird geladen<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">ImageCanvas</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"https://via.placeholder.com/350x240"</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">div</span>&gt;</span>Bearbeitungsfunktionen werden geladen<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">ImageToolbar</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>
  );
}

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Was hier passiert ist folgendes: die <code>ImageCanvas</code> (zum Anzeigen des Bildes) und die <code>ImageToolbar</code> (für die Bearbeitungsfunktionen) befinden sich in einem <code>Suspense</code>-Element. Dieses zeigt die Platzhalter-Nachricht: <em>„Die Anwendung wird geladen“</em> solange, bis die <code>ImageCanvas</code>-Komponente vom Server geladen wurde.</p>
<p>Sollte dies passieren <strong>bevor</strong> die <code>ImageToolbar</code> geladen wurde, wird sie bereits angezeigt und das zweite, innere <code>Suspense</code>-Element kommt zum Einsatz. Dieses sorgt dafür, dass die Nachricht <em>„Bearbeitungsfunktionen werden geladen“</em> angezeigt werden und zwar bis diese tatsächlich geladen wurden.</p>
<p>Ist die <code>ImageCanvas</code>-Komponente erst geladen <strong>nachdem</strong> die <code>ImageToolbar</code>-Komponente geladen wurde wird das innere <code>Suspense</code>-Element aufgelöst, jedoch verhindert das äußere Suspense-Element die anzeige der Toolbar und zeigt diese erst an sobald auch die <code>ImageCanvas</code> geladen ist. Dann jedoch ohne weitere Verzögerung.</p>
<p>Unser User Interface kennt also drei mögliche Darstellungen:</p>
<ul>
<li><code>ImageCanvas</code> und <code>ImageToolbar</code> wurden erfolgreich geladen und werden beide dargestellt</li>
<li><code>ImageCanvas</code> wurde noch nicht geladen und es erscheint nur die „Anwendung wird geladen“ Nachricht, unabhängig vom Lade-Status der <code>ImageToolbar</code></li>
<li><code>ImageCanvas</code> wude geladen, <code>ImageToolbar</code> jedoch noch nicht. Dann würde die <code>ImageCanvas</code> bereits angezeigt werden, anstelle der Toolbar stünde jedoch der Hinweis „Bearbeitungsfunktionen werden geladen“ bis diese auch tatsächlich geladen wurden.</li>
</ul>
<p>Wir schließen somit also bewusst aus, dass ein Benutzer zwar bereits die Bearbeitungsfunktionen für ein Bild sieht, nicht jedoch die Zeichenfläche auf der das zu bearbeitende Bild angezeigt wird. Eine kluge Verschachtelung von <code>Suspense</code> gibt uns so alle Flexibilität die nötig ist um sehr fein granular festzulegen wann welche Teile der Anwendung bereits angezeigt werden sollen und wo wir vorübergehend einen Platzhalter anzeigen wollen.</p>
<p>Momentan wird <strong>Suspense</strong> als Platzhalter offiziell nur für das Laden von Komponenten mittels <code>React.lazy()</code> unterstützt. In Zukunft soll auch das asynchrone Laden von Daten verschiedenster Art (wie z.B. API Abfragen) durch <strong>Suspense</strong> unterstützt werden.</p>
<div class="hint hint--warning">
<p><strong>Vorsicht:</strong> momentan werden <strong>Lazy</strong> und <strong>Suspense</strong> nur bei der Verwendung in <strong>clientseitigen</strong> Anwendungen unterstützt. Unterstützung für <strong>serverseitiges</strong> Rendering gibt es für dieses Feature aktuell noch nicht und befindet sich derzeit in Arbeit.</p>
</div>
</div>
<div class="chapter">
  <h1 id="typechecking-mit-proptypes-flow-und-typescript">Typechecking mit PropTypes, Flow und TypeScript</h1>
<p><strong>Typechecking</strong> ist eine einfache Möglichkeit um potentielle Fehler in einer Anwendung zu vermeiden. Das Prinzip dabei ist ganz einfach: Komponenten sollten „Pure“ sein, wir wir schon in der Einführung gelernt haben. Sie sollten also keine Seiten-Effekte auslösen und vor allem sollten sie bei den <strong>gleichen Eingabeparametern</strong> (was im Fall von Komponenten die <strong>Props</strong> und deren daraus abgeleiteter <strong>State</strong> ist) auch die <strong>identische Ausgabe</strong> erzeugen.</p>
<p>Das bedeutet, dass es möglichst vorhersehbar und sehr strikt sein sollte welche <strong>Props</strong> in eine Komponente hereingereicht werden können und welche von ihr verarbeitet werden. Um dies sicherzustellen können wir uns das sog. <strong>Typechecking</strong> zu nutze machen. JavaScript ist prinzipiell eine untypisierte Sprache. Eine Variable die mal ein <strong>String</strong> war, kann problemlos in eine <strong>Number</strong> oder gar ein <strong>Object</strong> umgewandelt werden, ohne dass der JavaScript-Interpreter ein Problem damit hat.</p>
<p>Auch wenn dies bei der Entwicklung mitunter sehr praktisch ist weil wir uns nicht festlegen müssen, öffnet das die Tür für einige ärgerliche Fehler und macht es daher nötig, regelmäßig manuell auf den korrekten Typen zu prüfen. Wollen wir bspw. auf eine tief verschachtelte Eigenschaft <code>user.settings.notifications.newMessages</code>zugreifen, sollten wir zuvor prüfen ob <code>user</code> überhaupt ein Objekt und nicht <code>null</code> ist, anschließend sollten wir prüfen ob das gleiche für <code>settings</code> zutrifft, usw. Andernfalls könnten wir es mit einem Type Error zu tun haben:</p>
<div class="hint hint--danger">
<p>TypeError: Cannot read property 'settings' of undefined</p>
</div>
<p><strong>Typechecking</strong> kann uns hier also helfen derartige potentielle Fehler schon vorher zu entdecken. Dazu gibt es neben <strong>Flow</strong> und <strong>TypeScript</strong>, die statische Typisierung ermöglichen, mit den sogenannten <strong>PropTypes</strong> auch eine recht simple React-eigene Lösung. Während <strong>Flow</strong> und <strong>TypeScript</strong> generell statische Typisierung in JavaScript ermöglichen, beschränken sich die React <strong>PropTypes</strong> allein auf React-Komponenten und finden außerhalb von Komponenten keine Anwendung. Wer also Gefallen findet an statischer Typisierung, sollte durchaus mal einen Blick auf <strong>Flow</strong> oder <strong>TypeScript</strong> wagen.</p>
<h2 id="proptypes">PropTypes</h2>
<p><strong>PropTypes</strong> reichen zurück bis in ganz frühe Versionen von React, lange bevor React seine heutige Popularität erreicht hat und wurden in React 15.5. aus dem Core heraus und in ein eigenes <code>prop-types</code> Package ausgelagert. Während man seine <strong>PropTypes</strong> vorher mittels bspw. <code>React.PropTypes.string</code> direkt in der Core-Library definieren konnte, erfolgt der Zugriff nun über das zuvor importierte <code>PropTypes</code> Modul: <code>PropTypes.string</code>.</p>
<p>Das bedeutet auch, dass das Modul zuerst als <code>devDependency</code> installiert werden muss. Auf der Kommandozeile reicht dafür ein simples:</p>
<pre><code class="hljs text language-text">yarn <span class="hljs-keyword">add</span><span class="bash"> --dev prop-types</span></code></pre>
<p>oder:</p>
<pre><code class="hljs text language-text">npm install --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> prop-types</code></pre>
<p><strong>PropTypes</strong> dienen dabei als eine Art Interface und legen fest, welche Form bzw. welchen Typen eine Prop annehmen darf und ob diese optional ist oder erforderlich ist. Gibt es Abweichungen, weist uns React <strong>im Development-Modus</strong> darauf hin. Bei einer korrekt veröffentlichten Anwendung, die die Production-Version von React nutzt und/oder mit der Umgebungsvariable <code>process.env.NODE_ENV=production</code> gebaut wurde bekommen wir diese Warnungen <strong>nicht</strong> mehr zu sehen!</p>
<p>Doch wie sieht die Verwendung von <strong>PropTypes</strong> nun aus? Hier müssen wir unterscheiden zwischen der <strong>Class Component</strong> und der <strong>Stateless Functional Component</strong>.</p>
<p>Bei der <strong>Class Component</strong> sind die <strong>PropTypes</strong> eine statische Eigenschaft <code>propTypes</code> der Komponente:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;
​
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventOverview</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">static</span> propTypes = {
    <span class="hljs-attr">date</span>: PropTypes.instanceOf(<span class="hljs-built_in">Date</span>).isRequired,
    <span class="hljs-attr">description</span>: PropTypes.string,
    <span class="hljs-attr">ticketsUrl</span>: PropTypes.string,
    <span class="hljs-attr">title</span>: PropTypes.string.isRequired
  };
​
  render() {
    <span class="hljs-keyword">const</span> { date, description, ticketUrl, title } = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{title}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{date.toLocaleString()}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        {description &amp;&amp; (
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"description"</span>&gt;</span>{description}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        )}
        {ticketsUrl &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">{ticketsUrl}</span>&gt;</span>Tickets!<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}
​
ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">EventOverview</span> <span class="hljs-attr">date</span>=<span class="hljs-string">{new</span> <span class="hljs-attr">Date</span>()} <span class="hljs-attr">title</span>=<span class="hljs-string">"React lernen und verstehen"</span> /&gt;</span>,
  document.getElementById('root')
);</span></code></pre>
<p>In diesem Beispiel möchten wir eine Übersicht zu einem Event ausgeben. Wir definieren, dass die <code>EventOverview</code>-Komponente die beiden Props <code>date</code> und <code>title</code> haben <strong>muss</strong>, darüber hinaus die beiden Props <code>description</code> und <code>ticketsUrl</code> haben <strong>kann</strong>. Ob eine Prop <strong>vorausgesetzt</strong> wird, kann mittels des angehängten <code>.isRequired</code> gekennzeichnet werden. Die <code>date</code>-Prop muss dabei in unserem Beispiel eine Instanz des nativen JavaScript <code>Date</code>-Objekts sein, <code>title</code> muss ein <code>string</code> sein. Die beiden optionalen Props <code>description</code> und <code>ticketsUrl</code> müssen nicht übergeben werden, werden sie allerdings übergeben, müssen auch sie vom Typ <code>string</code> sein.</p>
<p>Trifft eine dieser Bedingungen nicht zu, weist uns React darauf ziemlich deutlich mit einer Warnung in der Konsole hin:</p>
<div class="hint hint--danger">
<p>Warning: Failed prop type: Invalid prop `title` of type `number` supplied to `EventOverview`, expected `string`.</p>
</div>
<p>Bei <strong>Stateless Functional Components</strong> werden die <strong>PropTypes</strong> in gleicher Art und Weise definiert, allerdings haben wir hier natürlich keine Klasse, in der wir eine <code>static propTypes</code> Eigenschaft definieren können. Hier können wir einfach der Funktion selbst eine <code>propTypes</code>-Eigenschaft hinzufügen. Das sieht dann so aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> EventOverview = <span class="hljs-function">(<span class="hljs-params">{ date, description, ticketUrl, title }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{title}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{date.toLocaleString()}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    {description &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"description"</span>&gt;</span>{description}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}
    {ticketsUrl &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">{ticketsUrl}</span>&gt;</span>Tickets!<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>}
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
);

EventOverview.propTypes = {
  <span class="hljs-attr">date</span>: PropTypes.instanceOf(<span class="hljs-built_in">Date</span>).isRequired,
  <span class="hljs-attr">description</span>: PropTypes.string,
  <span class="hljs-attr">ticketsUrl</span>: PropTypes.string,
  <span class="hljs-attr">title</span>: PropTypes.string.isRequired,
};</code></pre>
<p>Und damit wäre auch unsere <strong>Stateless Functional Component</strong> mit <strong>PropType</strong>-Checking ausgestattet!</p>
<p>In einigen Fällen ist es wünschenswert sinnvolle Standardwerte zu vergeben. Auch hierfür bietet uns React eine Möglichkeit, die sogenannten <code>defaultProps</code>. Diese werden ähnlich verwendet wie die <code>propTypes</code>, nämlich als statische Eigenschaft. Aber schauen wir uns ein schnelles Beispiel an:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> Greeting = <span class="hljs-function">(<span class="hljs-params">{ name }</span>) =&gt;</span> &lt;h1&gt;Hallo {name}!<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;

Greeting.propTypes = {
  <span class="hljs-attr">name</span>: PropTypes.string.isRequired,
};

Greeting.defaultProps = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Gast'</span>,
};</code></pre>
<p>Wir markieren die <code>name</code>-Prop der Komponente als <code>string.isRequired</code>, wir erwarten also, dass die Prop immer übergeben wird und dass sie auch immer ein String ist. Anschließend definieren wir einen Standardwert für die <code>name</code>-Prop. Dieser wird immer dann verwendet, wenn kein Wert für die entsprechende Prop übergeben wird.</p>
<pre><code class="hljs jsx language-jsx">&lt;Greeting name=<span class="hljs-string">"Manuel"</span> /&gt;</code></pre>
<p>Verursacht also die Ausgabe: <strong>Hallo Manuel!</strong></p>
<pre><code class="hljs jsx language-jsx">&lt;Greeting /&gt;;
<span class="hljs-comment">// oder:</span>
<span class="hljs-keyword">const</span> user = {};
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">{user.name}</span> /&gt;</span>;</span></code></pre>
<p>Nutzt wegen der fehlenden bzw. undefinierten <code>name</code>-Prop hingegen den <code>defaultValue</code>, in diesem Fall <strong>Gast</strong> und zeigt in beiden Fällen an: <strong>Hallo Gast!</strong> React ist dabei klug genug und erkennt bei fehlender aber als <code>isRequired</code> markierter Prop ob ein <code>defaultValue</code> existiert und zeigt eine Warnung nur dann an, wenn eine Prop fehlt und auch nicht gleichzeitig ein <code>defaultValue</code> definiert wurde.</p>
<div class="hint hint--info">
<p>Beim <strong>Deployment in Production</strong> lohnt es sich das <strong>Babel-Plugin-Transform-React-Remove-Prop-Types</strong> zu verwenden. Dies spart noch einmal ein paar Bytes Bandbreite, da die <code>propType</code>-Definitionen aus dem Build entfernt werden, da diese ohnehin <strong>nur im Development-Modus</strong> berücksichtigt werden.</p>
<p>Das Plugin findet ihr unter:<br />
https://github.com/oliviertassinari/babel-plugin-transform-react-remove-prop-types</p>
<p>Installieren könnt ihr es auf der Kommandzeile mittels:<br />
<code>npm install --save-dev babel-plugin-transform-react-remove-prop-types</code> bzw.<br />
<code>yarn add --dev babel-plugin-transform-react-remove-prop-types</code></p>
</div>
<h2 id="flow">Flow</h2>
<p>Anders als die <strong>React PropTypes</strong> ist <strong>Flow</strong> ein <strong>statischer Typechecker</strong> für <strong>sämtliches</strong> JavaScript, nicht allein nur für React-Komponenten. Wie React selbst wird auch <strong>Flow</strong> von Facebook entwickelt und fügt sich dadurch schön nahtlos in die meisten React Setups ein. Bis <strong>Babel 6</strong> war es sogar Teil des <code>babel-preset-react</code> Pakets wurde also sozusagen zur Verwendung mit React „mit-installiert“ und konnte ohne jeglichen zusätzlichen Aufwand einfach verwendet werden.</p>
<p>Seit <strong>Babel 7</strong> ist <strong>Flow</strong> in ein eigenes <strong>Babel Preset</strong> ausgelagert worden, dass sich aber ebenso einfach über <code>npm install @babel/preset-flow</code> (bzw. analog dazu <code>yarn add @babel/preset-flow</code>) installieren lässt. Anschließend muss dann lediglich noch das entsprechende <code>@babel/preset-flow</code> als Preset in die Babel-Config eingetragen werden. Das <strong>Preset</strong> wird benötigt um die <strong>Flow-Syntax</strong>, die kein valides JavaScript wäre, im <strong>Build-Prozess</strong> aus dem entsprechenden Files zu entfernen, so dass es beim Aufruf im Browser nicht zu Syntax-Fehlern kommt.</p>
<p>Neben dem Babel Preset wird außerdem noch die <strong>Flow Executable</strong> benötigt, die sich in ihrer jeweils aktuellsten Version mittels <code>npm install flow-bin</code> (bzw. <code>yarn add flow-bin</code>) installieren lässt. Die <strong>Flow Executable</strong> führt dann das eigentliche <strong>Typechecking</strong> durch.</p>
<p>Nachdem <strong>Flow</strong> installiert und das <strong>Babel Preset</strong> eingerichtet wurde, wird noch eine <strong>Flow-Config</strong> benötigt. Diese erstellt ihr ganz einfach über den Aufruf von <code>./node_modules/flow init</code> im Terminal in eurem Projektverzeichnis.</p>
<p><strong>Tipp:</strong> um zu vermeiden jedes Mal <code>./node_modules</code> voranzustellen wenn Flow aufgerufen werden soll, könnt ihr euch einen Eintrag in den <code>script</code>-Teil eurer <code>package.json</code> machen:</p>
<pre><code class="hljs javascript language-javascript">{
  <span class="hljs-string">"scripts"</span>: {
    [...]
    <span class="hljs-string">"flow"</span>: <span class="hljs-string">"flow"</span>
  }
}</code></pre>
<p>Dies sorgt dafür, dass ihr Flow anschließend über npm oder Yarn aufrufen könnt:</p>
<pre><code class="hljs bash language-bash">npm run flow init</code></pre>
<p>oder mit Yarn:</p>
<pre><code class="hljs bash language-bash">yarn flow init</code></pre>
<p>Nachdem ihr <code>flow init</code> aufgerufen habt, solltet ihr in eurem Projektverzeichnis eine neue Datei <code>.flowconfig</code> sehen, die erst einmal ziemlich leer aussieht, die von Flow aber benötigt wird. In diese Datei könnt ihr später Optionen setzen oder angeben welche Dateien mit Flow geprüft werden sollen oder welche eben nicht.</p>
<p>Ihr habt eure Babel-Config aktualisiert, das <code>flow-bin</code> Package in euer Projekt installiert und die <code>.flowconfig</code> angelegt? Super. Dann kann es richtig losgehen. Um zu verifizieren dass alles korrekt eingerichtet wurde, könnt ihr einmal flow aufrufen. Wenn ihr den flow-Eintrag von oben in eurer <code>package.json</code> hinzugefügt habt könnt ihr das mit dem Befehl <code>yarn flow</code> in eurem Terminal. Ist alles korrekt eingerichtet, seht ihr eine Meldung wie die folgende:</p>
<pre><code class="hljs bash language-bash">No errors!
Done <span class="hljs-keyword">in</span> 0.57s.</code></pre>
<p>Dies bedeutet Flow hat eure Files geprüft und keine Fehler gefunden. Wie auch, haben wir doch noch gar keine Files mit Typechecking erstellt.</p>
<p>Die Standard-Einstellungen von Flow sehen vor, dass nur Files gecheckt werden, die Flow mit einem entsprechenden Kommentar im Code signalisieren, dass diese Typechecks beinhalten. Dazu fügt ihr einfach oben in jedem beliebigen JavaScript-File folgende Zeile ein:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// @flow</span></code></pre>
<p>Schauen wir uns das obige Beispiel noch einmal an. Diesmal mit <strong>Flow</strong> als Typechecker anstelle von <strong>PropTypes</strong>:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// @flow</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
​
type PropsT = {
  <span class="hljs-attr">date</span>: <span class="hljs-built_in">Date</span>,
  description?: string,
  ticketsUrl?: string,
  <span class="hljs-attr">title</span>: string,
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventOverview</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">PropsT</span>&gt; </span>{
  render() {
    <span class="hljs-keyword">const</span> { date, description, ticketUrl, title } = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{title}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{date.toLocaleString()}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        {description &amp;&amp; (
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"description"</span>&gt;</span>{description}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        )}
        {ticketsUrl &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">{ticketsUrl}</span>&gt;</span>Tickets!<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}
​
ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">EventOverview</span> <span class="hljs-attr">date</span>=<span class="hljs-string">{new</span> <span class="hljs-attr">Date</span>()} <span class="hljs-attr">title</span>=<span class="hljs-string">"React lernen und verstehen"</span> /&gt;</span>,
  document.getElementById('root')
);</span></code></pre>
<p>Anders als bei den <strong>PropTypes</strong> definieren wir hier zuerst eine <strong>Type Definition</strong> mit dem Namen <code>PropsT</code>. Der Name kann hier grundsätzlich frei gewählt werden. Oft werden <code>T</code> oder <code>Type</code> an den Namen der Type-Definitions angehängt, um es für Entwickler gleich ersichtlich zu machen, dass es sich dabei um eben solche handelt. Aber rein aus technischer Sicht ist das nicht notwendig. Den eben definierten Type übergeben wir dann in Form eines sogenannten „Generic Type“ an die Komponente:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventOverview</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">PropsT</span>&gt;</span></code></pre>
<p>Type Definitions können auch inline definiert werden. Allerdings wirkt sich das ab einer gewissen Anzahl auch auf die Lesbarkeit aus. In unserem Beispiel sähe die dann so aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventOverview</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;</span>{
  date: <span class="hljs-built_in">Date</span>,
  description?: string,
  ticketsUrl?: string,
  <span class="hljs-attr">title</span>: string,
}&gt; {
  […]
}</code></pre>
<p>Doch schauen wir uns die <strong>Type-Definition</strong> einmal genauer an. Wie schon bei den <strong>PropTypes</strong> legen wir hier fest welche <strong>Props</strong> eine Komponente übergeben bekommen kann und von welchem Typen diese sein müssen. Da wäre eine <code>date</code> Prop, die aus einer <code>Date</code>-Instanz bestehen muss und erforderlich ist. Als nächstes dann <code>description</code> und <code>ticketsUrl</code>, die durch ein <code>?</code> nach ihrem Namen als <strong>optional</strong> gekennzeichnet wurden und jeweils, sollten sie übergeben werden, vom Typ <code>string</code> sein müssen. Zuletzt wird eine <code>title</code> Prop erwartet, die ebenfalls ein <code>string</code> sein muss, aber nicht optional ist. Anders als bei <strong>PropTypes</strong> müssen hier nicht die erforderlichen Props mittels <code>isRequired</code> gekennzeichnet werden, sondern im Gegenteil die optionalen Props mittels Fragezeichen als optional markiert werden.</p>
<p><strong>Stateless Functional Components</strong> können in gleicher Form gleich der Übergabe der Props als Funktionsargument typisiert werden:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> EventOverview = <span class="hljs-function">(<span class="hljs-params">props: PropsT</span>) =&gt;</span> ([…]);</code></pre>
<p>bzw. in destrukturierter Form:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> EventOverview = <span class="hljs-function">(<span class="hljs-params">{ date, description, ticketUrl, title }: PropsT</span>) =&gt;</span> (<span class="hljs-comment">/*…*/</span>);</code></pre>
<p>oder als Inline-Definition:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> EventOverview = ({
    date,
    description,
    ticketUrl,
    title
}: {
    <span class="hljs-attr">date</span>: <span class="hljs-built_in">Date</span>,
    description?: string,
    ticketsUrl?: string,
    <span class="hljs-attr">title</span>: string
}) =&gt; {
  […]
};</code></pre>
<p>Doch das ist noch nicht alles. Flow kann eben, anders als <strong>PropTypes</strong>, sämtliches JavaScript checken, nicht bloß Props von React-Komponenten. Dies bedeutet, dass auch der State einer Komponente typisiert werden kann. Dazu ist ein zweiter Parameter in den sog. <strong>Generics</strong> vorgesehen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// @flow</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
​
type PropsT = {
  <span class="hljs-attr">date</span>: <span class="hljs-built_in">Date</span>,
  description?: string,
  ticketsUrl?: string,
  <span class="hljs-attr">title</span>: string,
};

type StateT = {
  <span class="hljs-attr">isBookmarked</span>: boolean,
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventOverview</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">PropsT</span>, <span class="hljs-title">StateT</span>&gt; </span>{
  state = {
    <span class="hljs-attr">isBookmarked</span>: <span class="hljs-literal">false</span>,
  };
  […]
}</code></pre>
<p>Anders als in bisherigen Beispielen im Buch haben die Imports hier eine etwas andere Form. Statt:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;</code></pre>
<p>… wurde React in diesem Kapitel folgendermaßen importiert:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;</code></pre>
<p>Dies führt dazu, dass gleichzeitig auch die von React mitgelieferten <strong>Type Definitions</strong> mit importiert wurden. Dies ist notwendig, wenn wir bspw. ein React-Element aus einer Funktion zurückgeben und dieses typisieren wollen.</p>
<h2 id="typescript">TypeScript</h2>
<p><strong>TypeScript</strong> wird von Microsoft entwickelt und ist ein sogenanntes typisiertes <strong>Superset</strong> von JavaScript, was bedeutet, dass es nicht direkt im Browser ausgeführt werden kann sondern zuvor in einem Zwischenschritt von einem Compiler in „echtes“ JavaScript kompiliert wird. <strong>TypeScript</strong> sieht auf den ersten Blick erst einmal ähnlich aus wie <strong>Flow</strong> und funktioniert auch ähnlich. Während Flow allerdings lediglich ein reiner <strong>Typechecker</strong> ist bringt <strong>TypeScript</strong> als Superset noch etwas mehr mit. So war es lange vor <strong>ES2015</strong> schon möglich Klassen und Imports in <strong>TypeScript</strong> zu verwenden.</p>
<p>In der JavaScript-Community erfreut sich <strong>TypeScript</strong> immer wachsender Beliebtheit und auch in Verbindung mit React ist es immer häufiger zu finden. Aus diesem Grund möchte ich das hier nicht ganz unerwähnt lassen, wobei ich hier gleichzeitig nicht all zu sehr in die Tiefe gehen möchte, da <strong>TypeScript</strong> allein genug Material für ein eigenes Buch hergeben würde.</p>
<p>Im Bezug auf React wichtig zu wissen ist, dass TypeScript-Files üblicherweise eine <code>.ts</code> Datei-Endung haben, enthält eine Datei auch JSX, muss die Datei zwingend mit <code>.tsx</code> enden.</p>
<p>Mit dem Release von Babel 7 wurde auch die Integration vereinfacht und es benötigt nun nicht mehr zwangsweise den <strong>TypeScript</strong> Compiler (<code>tsc</code>) sondern kann in Form eines Babel Plugins verwendet werden. Das Plugin wird mit dem Babel Preset <code>@babel/preset-typescript</code> installiert.</p>
</div>
<div class="chapter">
  <h1 id="iv-–-hooks">IV – Hooks</h1>
</div>
<div class="chapter">
  <h1 id="einführung-in-hooks">Einführung in Hooks</h1>
<p><strong>Hooks</strong> sind ein komplett neues Konzept das in React <strong>16.8.0</strong> eingeführt wurde. So komplett neu, dass ich <strong>Hooks</strong> in diesem Buch ein eigenes Kapitel widmen möchte. Einige der React Core-Entwickler haben es bereits als die aufregendste und grundlegendste Änderung an React in den letzten Jahren bezeichnet und in der Tat haben <strong>Hooks</strong> viel Aufsehen erregt als sie auf der React Conf 2018 angekündigt und gleich im Anschluss in der ersten Alpha-Version von React 16.7. eingeführt wurden. Inzwischen haben auch andere Frameworks eigene <strong>Hooks</strong> implementiert. Doch worum geht es eigentlich?</p>
<p>Mit <strong>Hooks</strong> ist es erstmals möglich Mechanismen in <strong>Function Components</strong> zu benutzen die bisher nur in Klassen-Komponenten möglich waren. Features wie <code>setState</code> oder Lifecycle Methoden ähnlich wie <code>componentDidMount()</code> oder <code>componentDidUpdate()</code> werden dank <strong>Hooks</strong> auch in <strong>Function Components</strong> möglich. <strong>Hooks</strong> sind dabei im wesentlichen Sinn nichts anderes als spezielle Funktionen, die einem festen Schema folgen. So gibt es die Konvention dass <strong>Hooks</strong> zwangsweise mit <code>use</code> anfangen müssen.</p>
<p>Dabei stellt React selbst eine Reihe interner <strong>Hooks</strong> zur Verfügung wie etwa <code>useState</code>, <code>useEffect</code> oder <code>useContext</code>, erlaubt aber auch die Erstellung eigener Hook-Funktionen, den sogenannten <strong>Custom Hooks</strong>, in denen dann eigene Logik gebündelt werden kann. Auch diese müssen per Konvention mit <code>use</code> beginnen, darüber hinaus ist es die weitere Benennung dem Entwickler selbst überlassen, der Name muss lediglich ein valider JavaScript-Funktionsname sein. Also etwa <code>useAccountInfo</code> oder <code>useDocumentInfo</code></p>
<div class="hint hint--info">
<p>Kleine persönliche Anekdote am Rande: die Einführung von <strong>Hooks</strong> haben dazu geführt dass ich große Teile dieses Buches umformulieren musste und auch noch weiterhin umformulieren muss. So war bspw. vorher auch in der offiziellen Dokumentation die Rede von <strong>Stateless Functional Components</strong> (oder kurz <strong>SFCs</strong>), das <strong>Stateless</strong> wurde mit der Einführung von <strong>Hooks</strong> quasi über Nacht aus der offiziellen Dokumentation gestrichen was ich zum Anlass nahm, dies auch in diesem Buch zu tun.</p>
</div>
<p><strong>Hooks</strong> wurden vor dem Hintergrund eingeführt, dass es mit ihnen erstmals möglich sein soll Komponenten-Logik in einer einheitlichen und von React vorgegebenen Form zwischen verschiedenen Komponenten geteilt werden können. Vor <strong>Hooks</strong> kam es häufig vor, dass verschiedene Komponenten fast identische <code>componentDidMount()</code> oder <code>componentDidUpdate()</code>-Methoden implementiert haben oder dass vor allem innerhalb einer Klassen-Komponente speziell diese beiden Methoden eine nahezu identische Implementierung hatten, mit dem einzigen Unterschied, dass in <code>componentDidUpdate()</code> zusätzlich geschaut wurde ob sich gewisse Parameter geändert haben. Bspw. ob sich eine via Props übergebene Benutzer-ID geändert hat, woraufhin ein API-Request initiiert wurde um die Daten für den jeweiligen Benutzer abzufragen.</p>
<p>Aus diesem Grund wurde mit den <strong>Hooks</strong> ein neues Konzept eingeführt mit dem komplexe Logik deutlich einfacher und ohne viel duplizierten Code geschrieben werden kann. Sie erfordern tatsächlich erst einmal etwas Umdenken wenn man mit der Funktionsweise von <strong>Klassen-Komponenten</strong> erst einmal vertraut ist, da sich einige Abläufe und der Aufbau der Komponenten selbst etwas ändert, hat man es schließlich nur noch mit relativ simplen Funktionen zu tun statt wie vorher mit komplexen Klassen mit Klassen-Methoden, Klassen-Eigenschaften, Vererbung und einem gemeinsamen <code>this</code> Kontext. Doch zu den genauen Details kommen wir noch im weiteren Verlauf dieses Kapitels.</p>
<h3 id="sind-klassen-komponenten-jetzt-schlecht">Sind Klassen-Komponenten jetzt schlecht?</h3>
<p>Bleibt noch die Frage zu klären: <em>sind Klassen-Komponenten jetzt schlecht?</em></p>
<p>Diese Frage kam unmittelbar nach der Ankündigung und Einführung von <strong>Hooks</strong> in der React-Community immer wieder auf. Das React-Team beantwortete es so, dass sie nicht empfehlen würden eine bestehende Anwendung die mit <strong>Klassen-Komponenten</strong> arbeitet nicht abrupt in <strong>Function Components</strong> mit <strong>Hooks</strong> umzuschreiben, da auch <strong>Klassen-Komponenten</strong> weiterhin Teil von React bleiben werden.</p>
<p>Die Community hat das aber zu großen Teilen nicht wirklich interessiert und so gab es nach dem Release von <strong>React 16.7.0-alpha.0</strong>, also der ersten Version mit <strong>Hooks</strong>, zahlreiche Meldungen von Entwicklern auf Twitter, die sich trotz aller Warnungen nicht davon abhalten ließen ihre Anwendungen mit <strong>Hooks</strong> umzuschreiben und zum deutlich überwiegenden Teil begeistert waren von der neuen Einfachheit der Entwicklung von Komponenten ohne den Overhead, den Klassen-Komponenten ein Stück weit mit sich gebracht haben.</p>
<p>Grundsätzlich ist also auch nach wie vor nichts gegen die Verwendung von Klassen-Komponenten einzuwenden und wer mag, kann diese auch weiterhin verwenden, da es momentan keine Pläne gibt diese wieder aus React zu entfernen. Wer sich allerdings erst einmal an die Verwendung von <strong>Hooks</strong> gewöhnt hat, dem dürfte es in den meisten Fällen schwer fallen freiwillig auf die Einfachheit und Verständlichkeit dieser neuen Form einer Komponenten zu verzichten.</p>
<h3 id="klassen-komponenten-und-hooks-–-ein-vergleich">Klassen-Komponenten und Hooks – ein Vergleich</h3>
<p>Um zu veranschaulichen wie viel simpler Komponenten durch die Verwendung von <strong>Hooks</strong> werden können hat Sunil Pai, ebenfalls ein Core-Entwickler von React, einen Vergleich erstellt bei dem zusammenhängende Logik gleich eingefärbt wurde und die Teile, die in der Function Component mit Hooks nicht mehr benötigt werden, in der Klassen-Komponente geschwärzt wurden. Das Ergebnis ist ein sehr harmonisches Bild in dem Logik jeweils an einer Stelle gebündelt ist und nicht an verschiedenen Stellen innerhalb der Komponente verwendet wird:</p>
<table>
  <thead>
    <tr>
      <th style="text-align:left">Klassen-Komponente</th>
      <th style="text-align:left">Komponente mit Hooks</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left">
        <p></p>
        <p>
          <img src="./assets/.gitbook/react-class.jpg" alt/>
        </p>
      </td>
      <td style="text-align:left">
        <p></p>
        <p>
          <img src="./assets/.gitbook/react-hooks.jpg" alt/>
        </p>
      </td>
    </tr>
  </tbody>
</table>
<p>Quelle: <a href="https://twitter.com/threepointone/status/1056594421079261185">Sunil Pai auf Twitter</a></p>
</div>
<div class="chapter">
  <h1 id="verwendung-von-hooks">Verwendung von Hooks</h1>
<p>Insgesamt bringt React aktuell <strong>10</strong> eigene Hooks mit von denen die offizielle Dokumentation <strong>3</strong> als <strong>Basic</strong>, also als <em>grundlegende</em>, die restlichen <strong>7</strong> als <strong>Additional</strong>, also als <em>zusätzliche</em> Hooks betitelt. Und in der Tat ist diese Unterteilung sinnvoll, denn in den meisten Fällen in denen mit Hooks gearbeitet wird, wird man die 3 Basic Hooks <code>useState()</code>, <code>useEffect()</code> und <code>useContext()</code> verwenden.</p>
<p>Die als <strong>Additional Hooks</strong> bezeichneten Ausprägungen sind insbesondere für spätere Optimierungen oder zum Abdecken von Edge-Cases vorgesehen. In diesem Kapitel soll es daher erst einmal um die „simplen“ Hooks gehen und ich möchte demonstrieren wie man Funktionalität mit <strong>Function Components</strong> realisieren kann, für die bisher <strong>Klassen-Komponenten</strong> notwendig waren.</p>
<h3 id="state-mit-usestate">State mit useState()</h3>
<p>Werfen wir zunächst einen Blick darauf, wie wir bisher auf State in Komponenten zugegriffen haben und wie wir ihn modifiziert haben.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">value</span>: <span class="hljs-number">0</span>,
  };
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Zählerwert: {this.state.value}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>
          <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> this.setState((state) =&gt; ({ value: state.value + 1 }))}
        &gt;
          +1
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Hier implementieren wir beispielhaft einen Zähler, der mitzählt, wie oft wir den <strong>+1</strong>-Button gedrückt haben. Zugegeben, nicht gerade kreativ, demonstriert aber sehr gut, wie uns Hooks das Leben an dieser Stelle einfacher machen. Wir zeigen den aktuellen Wert an indem wir <code>this.state.value</code> auslesen und haben darunter einen Button, mit dem wir den Wert erhöhen können. Dazu rufen wir <code>this.setState()</code> auf und setzen den neuen <code>value</code> auf den vorherigen Wert den wir um 1 erhöhen.</p>
<p>Schauen wir uns die identische Funktionalität noch einmal an, diesmal in einer <strong>Function Component</strong> mit dem neuen <code>useState()</code>-Hook:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> Counter = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> [value, setValue] = React.useState(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Zählerwert: {value}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setValue(value + 1)}&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Hier haben wir kein <code>state</code>-Objekt mehr und auch kein <code>this</code> über das wir auf den State zugreifen. Stattdessen sehen wir hier den Aufruf des internen <code>useState()</code>-Hooks. Dieser funktioniert so, dass er einen <strong>Initialwert</strong> übergeben bekommt (hier: <code>0</code>) und einen Tupel zurückgibt, also ein Array mit der gleichen Anzahl von Werten. Im Falle des <code>useState()</code>-Hooks sind das zum einen der aktuelle State sowie eine Setter-Funktion, mit der wir den Wert modifizieren können.</p>
<p>Um direkt auf den Wert und die Setter-Funktion zuzugreifen machen wir uns die <strong>ES2015 Array Destructuring</strong>-Methode zu nutze. Diese sorgt dafür, dass der erste Wert des Arrays in die Variable <code>value</code>, der zweite Wert in die Variable <code>setValue</code> geschrieben wird. Beide Namen sind dabei frei wählbar, jedoch hat es sich schnell eingebürgert dem State einen kurzen, prägnanten Namen zu geben und der Setter-Funktion den gleichen Namen zu geben mit einem set davor. Die Syntax ist also eine Abkürzung für das folgende ES5 Äquivalent:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">var</span> state = React.useState(<span class="hljs-number">0</span>);
<span class="hljs-keyword">var</span> value = state[<span class="hljs-number">0</span>];
<span class="hljs-keyword">var</span> setValue = state[<span class="hljs-number">1</span>];</code></pre>
<p>Im JSX, das wir aus der <code>Counter</code>-Komponente zurückgeben, greifen wir nun direkt auf <code>value</code> zu statt auf <code>this.state.value</code> und setzen den neuen Wert mittels eines sehr kurzen <code>setValue(value + 1)</code> statt wie zuvor in der Klassen-Komponente mittels <code>this.setState((state) =&gt; ({ value: state + 1 }))</code>.</p>
<p>Wir haben so eben unsere erste <strong>Function Component</strong> erstellt die <strong>stateful</strong> ist!</p>
<div class="hint hint--info">
<p>Wir haben an dieser Stelle unseren ersten <strong>Hook</strong> verwendet: <code>useState()</code>. Dazu haben wir die Methode <code>React.useState()</code> aufgerufen. <strong>Hooks</strong> können auch direkt aus dem <code>react</code>-Package importiert werden.</p>
<p>Dies ist insbesondere sinnvoll wenn ein Hook mehrmals verwendet wird. So schreibt man sich dann in der Komponente einiges an Schreibarbeit:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React, { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
</code></pre>
<p>So können wir in der Komponente bequem direkt <code>useState()</code> nutzen statt jedesmal <code>React.useState()</code> schreiben zu müssen.</p>
</div>
<p>Komponenten sind dabei nicht auf nur einen Hook je Typ beschränkt und so kann es jede Art von Hook auch mehrmals in einer Komponente geben. Möchten wir bspw. zwei Counter hochzählen müssen wir die Zählerwerte nicht in einem Zähler-Objekt verwalten sondern können auch mehrere States erzeugen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> Counter = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> [firstValue, setFirstValue] = React.useState(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> [secondValue, setSecondValue] = React.useState(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Zählerwert 1: {firstValue}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Zählerwert 2: {secondValue}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setFirstValue(firstValue + 1)}&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setSecondValue(secondValue + 1)}&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Für die Arbeit mit komplexen States erfahren wir im weiteren Verlauf dieses Buchs noch mehr über die Verwendung des <code>useReducer()</code>-Hooks. Dieser wurde eingeführt um die Verwaltung komplexer States zu vereinfachen.</p>
<h3 id="seiteneffekte-mit-useeffect">Seiteneffekte mit useEffect()</h3>
<p>Der <code>useEffect()</code>-<strong>Hook</strong> erhält seinen Namen daher, da dieser dazu vorgesehen ist ihn für <strong>Side Effects</strong> zu benutzen. Also Seiteneffekte wie dem Laden von Daten via API, dem Registrieren von globalen Events oder der Manipulation von DOM-Elementen. Der Hook bildet die Funktionalität der <code>componentDidMount()</code>, <code>componentDidUpdate()</code> und <code>componentWillUnmount()</code>-Lifecycle Methoden ab.</p>
<p>Ja, richtig gelesen: statt der genannten <em>drei</em> Methoden gibt es nun nur noch <em>einen einzigen</em> <strong>Hook</strong>, der an die vergleichbare Stelle der Methoden aus Klassen-Komponenten tritt. Der Trick dabei ist die genaue Verwendung ganz bestimmter Funktionsparameter und Rückgabewerte, wie sie für den <code>useEffect()</code>-Hook vorgesehen sind.</p>
<p>Zur Benutzung des Hooks wird der <code>useEffect()</code>-Funktion selbst eine Funktion als ersten Parameter übergeben. Diese Funktion, nennen wir sie der Einfachheit halber <strong>„Effekt-Funktion“</strong>, wird von React grundsätzlich erst einmal <strong>nach</strong> jedem Rendering der Komponente ausgeführt und tritt damit an die Stelle von <code>componentDidUpdate()</code> in Klassen-Komponenten.</p>
<p>Da diese <strong>Effekt-Funktion</strong> nach <strong>jedem</strong> Rendering der Komponente aufgerufen wird, wird sie eben auch nach dem <strong>ersten</strong> Rendering aufgerufen, was an dieser Stelle gleichgesetzt werden kann mit der <code>componentDidMount()</code> Lifecycle-Methode aus den Klassen-Komponenten.</p>
<p>Darüber hinaus kann die <em>Effekt</em>-Funktion optional selbst wiederum eine Funktion zurückgeben. Nennen wir sie <strong>„Aufräum-Funktion“</strong>. Diese <em>Aufräum</em>-Funktion wird beim <strong>Unmounting</strong> der Komponente aufgerufen, womit wir bei der nächsten Lifecycle-Methode wären, nämlich <code>componentWillUnmount()</code>.</p>
<p>Doch Vorsicht: hier haben wir gleichzeitig auch die erste Abweichung in der Funktionsweise verglichen mit Klassen-Komponenten. Und so wird unsere <em>Aufräum</em>-Funktion nicht nur beim <strong>Unmounting</strong> der Komponente aufgerufen sondern auch <strong>vor jeder erneuten Ausführung</strong> der <em>Effekt</em>-Funktion.</p>
<p>Dieses Verhalten kann aktiv gesteuert werden, indem dem <code>useEffect()</code>-Hook als zweiten Parameter ein Array mit sog. <strong>Dependencies</strong> übergeben wird. Dabei handelt es sich um Werte von denen die Ausführung der <strong>Effekt-Funktion</strong> abhängt. Wird ein <strong>Dependency-Array</strong> übergeben wird der Hook nur einmal initial ausgeführt und dann erst wieder, wenn sich mind. einer der Werte im <strong>Dependency-Array</strong> geändert hat.</p>
<p>Möchte man hingegen gezielt ein <code>componentDidMount()</code> simulieren kann ein leeres Array als zweiter Parameter übergeben werden. React führt die Effekt-Funktion dann nur beim ersten Rendern aus und ruft dann erst beim <strong>Unmounting</strong> wieder eine eventuell definierte Aufräum-Funktion auf.</p>
<p>Das klingt jetzt alles sicher wieder fürchterlich kompliziert wenn man mit der Funktionsweise des Hooks nicht vertraut ist, lässt sich aber mit einem kurzen Code-Beispiel relativ einfach demonstrieren:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React, { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> defaultTitle = <span class="hljs-string">'React mit Hooks'</span>;

<span class="hljs-keyword">const</span> Counter = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> [value, setValue] = useState(<span class="hljs-number">0</span>);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-comment">// `document.title` wird bei jeder Änderung (didMount/didUpdate) gesetzt.</span>
    <span class="hljs-comment">// Vorausgesetzt der `value` hat sich gendert</span>
    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`Der Button wurde <span class="hljs-subst">${value}</span> mal geklickt`</span>;

    <span class="hljs-comment">// Hier geben wir unsere „Aufräum-Funktion“ zurück die vor jedem Update</span>
    <span class="hljs-comment">// den Titel auf den Standardwert zurücksetzt</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-built_in">document</span>.title = defaultTitle;
    };

    <span class="hljs-comment">// Zuletzt unsere Dependency. Durch sie wird die Effekt-Funktion nur aufgerufen</span>
    <span class="hljs-comment">// wenn sich auch der `value` geändert hat.</span>
  }, [value]);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Zählerwert: {value}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setValue(value + 1)}&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Da der <strong>Hook</strong> sich stets <em>innerhalb</em> der Funktion befindet hat er, ähnlich wie die Lifecycle-Methoden in Klassen-Komponenten, den vollen Zugriff auf die <strong>Props</strong> und den <strong>State</strong> der Komponente. Wobei der State in der <strong>Function Component</strong> selbst natürlich wiederum nur ein Hook ist, nämlich der <code>useState()</code>-Hook.</p>
<p>Durch die Verwendung des <code>useEffect()</code>-<strong>Hooks</strong> können wir hier die Komplexität verringern, da die Komponente nicht viele, zum Teil sehr ähnliche Dinge an mehreren Stellen innerhalb der Komponente ausführen muss, sondern sich alle für die Komponente relevanten Lifecycle-Events in nur einer einzigen Funktion, eben dem <strong>Hook</strong>, abspielen.</p>
<p>Zum Vergleich dazu möchte ich einmal ein Äquivalent zeigen wie der oben gezeigte <code>useEffect()</code>-<strong>Hook</strong> mit einer Klassen-Komponente implementiert werden würde.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> defaultTitle = <span class="hljs-string">'React mit Hooks'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">value</span>: <span class="hljs-number">0</span>,
  };

  componentDidMount() {
    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`Der Button wurde <span class="hljs-subst">${<span class="hljs-keyword">this</span>.state.value}</span> mal geklickt`</span>;
  }

  componentDidUpdate(prevProps, prevState) {
    <span class="hljs-keyword">if</span> (prevState.value !== <span class="hljs-keyword">this</span>.state.value) {
      <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`Der Button wurde <span class="hljs-subst">${<span class="hljs-keyword">this</span>.state.value}</span> mal geklickt`</span>;
    }
  }

  componentWillUnmount() {
    <span class="hljs-built_in">document</span>.title = defaultTitle;
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Zählerwert: {this.state.value}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>
          <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {
            this.setState((state) =&gt; ({ value: state.value + 1 }));
          }}
        &gt;
          +1
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Hier kann natürlich darüber diskutiert werden, dass man den Aufruf um den <code>document.title</code> zu ändern in eine eigene Klassen-Methode wie etwa <code>setDocumentTitle()</code> auslagert, das sind allerdings Details die an der höheren Komplexität der Klassen-Komponente im direkten Vergleich mit <strong>Hooks</strong> nicht wirklich etwas ändern.</p>
<p>Auch dann müsste noch immer zweimal die gleiche (nun abstrahierte) Funktion an zwei verschiedenen Stellen (nämlich <code>componentDidMount()</code> und <code>componentDidUpdate()</code>) aufgerufen werden. Zusätzlich hätten wir eine weitere Klassen-Methode, die die Klasse nur noch weiter aufbläht und so die Duplikation nur zu Lasten einer Abstraktion auflöst.</p>
<h3 id="zugriff-auf-context-mit-usecontext">Zugriff auf Context mit useContext()</h3>
<p>Der dritte Basic Hook im Bunde ist <code>useContext()</code>. Mit ihm wird es ein Kinderspiel Daten aus einem Context-Provider zu konsumieren, ohne dass dazu umständlich eine Provider-Komponente mit einer Function as a Child verwendet werden muss.</p>
<p>Dazu erhält der <code>useContext()</code>-Hook einen mittels <code>React.createContext()</code> erzeugten Context übergeben und gibt dann den Wert des in der Komponenten-Hierarchie nächsthöheren Providers zurück. Wird Wert des Contexts im Provider geändert, löst der <code>useContext()</code>-Hook ein Rerendering aus mit den aktualisierten Daten aus dem Provider. Damit ist über die Funktionsweise auch schon alles gesagt.</p>
<p>Der Hook ist tatsächlich eher simpler Natur:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React, { useContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> AccountContext = React.createContext({});

<span class="hljs-keyword">const</span> ContextExample = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> accountData = useContext(AccountContext);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Name: {accountData.name}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Rolle: {accountData.role}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AccountContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">name:</span> '<span class="hljs-attr">Manuel</span>', <span class="hljs-attr">role:</span> '<span class="hljs-attr">admin</span>' }}&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ContextExample</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">AccountContext.Provider</span>&gt;</span>
);

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Hier sehen wir, wie die <code>ContextExample</code>-Komponente Daten (in diesem Beispiel pseudo Account-Daten) aus dem <code>AccountContext</code>-Provider verwendet, ohne dass dafür alles von einer <code>AccountContext.Consumer</code>-Komponente umschlossen sein muss. Dies spart nicht nur einige Zeilen Code in der Komponente selbst sondern führt auch in der Debug-Ansicht zu einem deutlich übersichtlicheren Baum, da die Verschachtelungstiefe flacher ist.</p>
<p>Diese Vereinfachung ist aber völlig optional und wer mag kann auch weiterhin die bekannte Consumer-Komponente für den Zugriff auf Daten aus einem Context-Provider verwenden.</p>
</div>
<div class="chapter">
  <h1 id="grundsätze-und-regeln-von-hooks">Grundsätze und Regeln von Hooks</h1>
<p>Die Verwendung von <strong>Hooks</strong> ist an einige Grundsätze und Regeln geknüpft die es zu beachten gilt damit es nicht zu unangenehmen Überraschungen und unerwartete Bugs führt, von denen es mit <strong>Hooks</strong> ja gerade weniger geben soll. Bei der Einhaltung dieser Regeln hilft uns <strong>ESLint</strong> und das vom React-Team höchstpersönlich entwickelte ESLint-Plugin <code>eslint-plugin-react-hooks</code>. Die Verwendung von ESLint hatte ich im Kapitel über <strong>Tools und Setup</strong> bereits empfohlen und an dieser Empfehlung hat sich seitdem auch nichts geändert.</p>
<p>Um das Plugin im Projekt zu installieren hilft folgender Aufruf auf der Kommandozeile:</p>
<pre><code class="hljs bash language-bash">npm install --save-dev eslint-plugin-react-hooks</code></pre>
<p>bzw. mit Yarn:</p>
<pre><code class="hljs bash language-bash">yarn add --dev eslint-plugin-react-hooks</code></pre>
<p>Anschließend muss die <code>.eslintrc</code> Konfiguration wie folgt angepasst werden:</p>
<pre><code class="hljs javascript language-javascript">{
  <span class="hljs-string">"plugins"</span>: [
    <span class="hljs-comment">// ...</span>
    <span class="hljs-string">"react-hooks"</span>
  ],
  <span class="hljs-string">"rules"</span>: {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-string">"react-hooks/rules-of-hooks"</span>: <span class="hljs-string">"error"</span>,
    <span class="hljs-string">"react-hooks/exhaustive-deps"</span>: <span class="hljs-string">"warn"</span>
  }
}</code></pre>
<p>Für diejenigen unter euch die <strong>Create React App</strong> nutzen habe eine gute Nachricht: ihr braucht nichts weiter tun, die beiden Regeln kommen standardmäßig in den aktuellen Versionen von <strong>Create React App</strong> automatisch mit in euer Setup!</p>
<h3 id="die-regeln-von-hooks">Die Regeln von Hooks</h3>
<p>Die Formalitäten hätten wir nun geklärt, doch nun erst mal der Reihe nach. Was sind also diese sagenumwobenen Regeln die ich eingangs erwähnt habe und für die die es sogar eigens entwickelte ESLint-Regeln gibt?</p>
<h4 id="hooks-können-nur-in-react-function-components-verwendet-werden">Hooks können nur in React Function Components verwendet werden!</h4>
<p>Nicht in <strong>Klassen-Komponenten</strong> und auch nirgendwo sonst: <strong>Hooks</strong> können ausschließlich innerhalb von React <strong>Function Components</strong> verwendet werden! Dies bedeutet das eine Funktion die Hooks verwendet eine React-Komponente sein muss, also unweigerlich auch einen Rückgabewert haben muss, der ein valides React-Element ist. Also JSX, Arrays, Strings oder <code>null</code>.</p>
<div class="hint hint--danger">
<p><strong>Nicht erlaubt, da eine Klassen-Komponente verwendet wird.</strong></p>
</div>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">const</span> [value, setValue] = useState();
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setValue(e.target.value)} /&gt;;
  }
}</span></code></pre>
<div class="hint hint--success">
<p><strong>Erlaubt, da eine Function Component verwendet wird:</strong></p>
</div>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> MyComponent = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> [value, setValue] = useState();
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setValue(e.target.value)} /&gt;;
};</span></code></pre>
<h4 id="hooks-dürfen-nur-auf-oberster-ebene-innerhalb-ihrer-function-component-verwendet-werden">Hooks dürfen nur auf oberster Ebene innerhalb ihrer Function Component verwendet werden!</h4>
<p>Konkret bedeutet das, dass es <strong>nicht möglich</strong> ist Hooks innerhalb von <strong>Schleifen, Bedingungen oder verschachtelten Funktionen</strong> zu benutzen. Dies hängt damit zusammen, wie React <strong>Hooks</strong> intern verarbeitet werden. Hier ist es wichtig dass die Reihenfolge, in der <strong>Hooks</strong> ausgeführt werden, bei jedem Re-Rendering einer Komponente identisch sein muss. Aus diesem Grund ist es bspw. nicht möglich einen <strong>Hook</strong> nur dann aufzurufen wenn eine bestimmte Bedingung erfüllt ist. Dies würde je nachdem ob die Bedingung erfüllt ist eben zu einer anderen Reihenfolge beim Abarbeiten der <strong>Hooks</strong> führen. Möglich ist es jedoch Bedingungen <em>innerhalb</em> von <strong>Hooks</strong> zu verwenden.</p>
<div class="hint hint--danger">
<p><strong>Nicht erlaubt, da der Hook sich innerhalb einer Bedingung befindet:</strong></p>
</div>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">if</span> (title) {
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">document</span>.title = title;
  }, [title]);
}</code></pre>
<div class="hint hint--success">
<p><strong>Erlaubt, da sich die Bedingung innerhalb des Hooks befindet:</strong></p>
</div>
<pre><code class="hljs javascript language-javascript">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (title) {
    <span class="hljs-built_in">document</span>.title = title;
  }
}, [title]);</code></pre>
<p>Wer das ESLint Plugin installiert und die Regeln aktiviert hat hier nichts zu befürchten. ESLint zeigt im Fall einer Missachtung dieser Regeln dann eine Warnung an und weist den Entwickler auf seinen Fehler hin.</p>
</div>
<div class="chapter">
  <h1 id="eigene-hooks-implementieren">Eigene Hooks implementieren</h1>
<p>Neben den <strong>internen Hooks</strong> wie <code>useState</code> oder <code>useEffect</code> ist es auch möglich <strong>eigene Hooks</strong> zu erstellen, die selbst wiederum Gebrauch von den <strong>internen Hooks</strong> oder auch von anderen <strong>eigenen Hooks</strong> machen und eigene Logik jeglicher Art in wiederverwendbarer Form kapseln. Sogenannte <strong>Custom Hooks</strong>. Die Entwicklung von solchen <strong>Custom Hooks</strong> ist immer dann besonders sinnvoll wenn die immer gleiche Logik in mehreren Komponenten verwendet werden soll. Auch wenn die Logik in einer Komponente zunehmend komplexer wird kann es sinnvoll sein diese aufzuteilen und in <strong>eigene Hooks</strong> mit leicht verständlichen Namen zu verlagern, um die eigentliche <strong>Function Component</strong> übersichtlicher zu halten.</p>
<h3 id="der-erste-eigene-custom-hook">Der erste eigene Custom Hook</h3>
<p>Fangen wir zum Einstieg mit einem sehr simplen Beispiel an und gehen davon aus, dass wir einen <strong>Custom Hook</strong> implementieren wollen mit dem wir einen Side Effect auslösen und die Hintergrundfarbe ändern wann immer eine Komponente gemounted wird. Ein typischer Name für einen solchen <strong>Custom Hook</strong> – wir erinnern uns daran, dass Hooks immer mit <code>use</code> beginnen müssen – wäre bspw. <code>useBackgroundColor()</code>. Der Hook erwartet eine gültige CSS-Farbe und setzt diese als Hintergrundfarbe sobald eine Komponente, die Gebrauch von diesem Hook macht, gemounted wird oder einen neuen Wert übergibt an den <strong>Custom Hook</strong> übergibt.</p>
<p>Da wir diese Logik möglicherweise in mehreren Komponenten verwenden möchten und dort nicht jedes mal die selbe Funktionalität der immer gleichen <code>useEffect</code>-Funktion implementieren wollen, erstellen wir also den folgenden <strong>Custom Hook</strong> als erste Fingerübung:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// useBackgroundColor.js</span>
<span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> useBackgroundColor = <span class="hljs-function">(<span class="hljs-params">color</span>) =&gt;</span> {
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">document</span>.body.style.backgroundColor = color;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-built_in">document</span>.body.style.backgroundColor = <span class="hljs-string">''</span>;
    };
  }, [color]);
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useBackgroundColor;</code></pre>
<p>Als Beispiel für die Verwendung erstellen wir eine kleine <code>Tabs</code>-Komponente die drei Buttons anzeigt, die beim Klick jeweils einen anderen Content anzeigen. Je nachdem welche Komponente angezeigt wird, wollen wir den Hintergrund unserer Anwendung ändern. Dazu nutzen wir unseren eben erstellten <code>useBackgroundColor()</code> Hook.</p>
<p>Das Ganze gestaltet sich dann wie folgt:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// Tabs.js</span>
<span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> useBackgroundColor <span class="hljs-keyword">from</span> <span class="hljs-string">'./useBackgroundColor'</span>;

<span class="hljs-keyword">const</span> DefaultContent = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Default Content<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
};

<span class="hljs-keyword">const</span> SpecialContent = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  useBackgroundColor(<span class="hljs-string">'red'</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Special Content<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
};

<span class="hljs-keyword">const</span> OtherSpecialContent = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  useBackgroundColor(<span class="hljs-string">'orange'</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Other Special Content<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
};

<span class="hljs-keyword">const</span> Tabs = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> [tab, setTab] = useState(<span class="hljs-string">'home'</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"tabs"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"tabBar"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setTab('home')}&gt;Home<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setTab('special')}&gt;Special<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setTab('other')}&gt;Other Special<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"tabContent"</span>&gt;</span>
        {tab === 'home' &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">DefaultContent</span> /&gt;</span>}
        {tab === 'special' &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">SpecialContent</span> /&gt;</span>}
        {tab === 'other' &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">OtherSpecialContent</span> /&gt;</span>}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Tabs</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Wir haben in diesem Beispiel drei simple Kompontenten implementiert, die unseren Content darstellen: <code>DefaultContent</code>, <code>SpecialContent</code>, <code>OtherSpecialContent</code>. Zwei dieser Komponenten nutzen dabei unseren im ersten Schritt erstellten <strong>Custom Hook</strong> <code>useBackgroundColor()</code> um die globale Hintergrundfarbe in einem <code>useEffect()</code>-Hook zu ändern sobald die Komponente gemounted wird.</p>
<p>Alternativ könnten wir an dieser Stelle auch den <code>useEffect()</code>-Hook den wir im <code>useBackgroundColor()</code>-Hook benutzen auch händisch überall dort implementieren wo wir die Hintergrundfarbe ändern müssen. Dies würde aber eben zu sehr viel Duplikation im Code führen. Stattdessen lagern wir die entsprechende Logik in eine eigene Hook-Funktion aus, machen diese bedingt konfigurierbar indem wir die gewünschte Farbe übergeben und können sie dann in beliebig vielen Function Components verwenden.</p>
<p>Während die einfache Erstellung wiederverwendbarer Komponenten auf Darstellungsebene (also im User Interface Layer) also die große Stärke von React und JSX ist, so bieten uns Hooks auf Logik-Ebene erstmals eine Möglichkeit um mit React-Bordmitteln Wiederverwendbarkeit gewährleisten zu können ohne Kompromisse eingehen zu müssen.</p>
<h3 id="mit-daten-aus-hooks-arbeiten">Mit Daten aus Hooks arbeiten</h3>
<p>Datenübergabe in <strong>Custom Hooks</strong> ist keine Einbahnstraße. In unserem ersten eigenen Hook haben wir gesehen wie wir Daten (in diesem Fall eine Farbe) an den <strong>Custom Hook</strong> übergeben. Nämlich als einfachen Funktionsparameter. Der Hook kann aber ebenso Daten zurückgeben mit denen dann in der Komponente gearbeitet werden kann. In welcher Form Daten aus dem <strong>Hook</strong> zurückgegeben werden ist dabei völlig dem Entwickler überlassen. Vom einfachen String über einen Tupel wie beim internen <code>useState()</code>-<strong>Hook</strong> bis hin zu ganzen React-Komponenten oder Elementen oder auch einem Mix aus allem sind der eigenen Fantasie hier keine Grenzen gesetzt.</p>
<p>Nehmen wir an wir wollen auf die Daten einer API zugreifen. Auf welche genauen Daten zugegriffen wird wollen wir parametrisierbar machen. Der Hook soll dafür sorgen uns die Daten zu besorgen – egal in welcher Komponente wir ihn verwenden – und dann an die Komponente die die Daten benötigt zurückgeben. In einem realen Beispiel könnten das z.B. Benutzerdaten von GitHub sein. Dies soll unser nächster eigener Hook werden: <code>useGitHubUserData</code>.</p>
<p>Wir übergeben dem Hook einen GitHub-Benutzernamen und bekommen ein Objekt mit allen relevanten Informationen zu dem Benutzer zurück. Der Hook kümmert sich darum die Daten über die GitHub API zu besorgen und anschließend an die Komponente zurück zu übergeben:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// useGitHubAccountData.js</span>
<span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;

<span class="hljs-keyword">const</span> useGitHubAccountData = <span class="hljs-function">(<span class="hljs-params">account</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> [accountData, setAccountData] = useState({});

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (!account) {
      <span class="hljs-keyword">return</span>;
    }

    axios.get(<span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">${account}</span>`</span>).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
      setAccountData(response.data);
    });
  }, [account]);

  <span class="hljs-keyword">return</span> accountData;
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useGitHubAccountData;</code></pre>
<p>Auch hier nutzen wir wieder die bereits bekannten Hooks <code>useEffect()</code> und <code>useState()</code>. Den State (konkret <code>accountData</code>) nutzen wir um darin die GitHub-Benutzerdaten zu verwalten. Den Effekt führen wir immer dann aus (und nur dann) wenn sich der übergebene Benutzername ändert. Zum übergebenen Benutzernamen holen wir uns dann über die GitHub API die Benutzerdaten ab, warten den Response ab und schreiben die Daten aus dem Response per <code>setAccountData()</code> in den State. Am Ende des Hooks wird dann der <code>accountData</code> State zurückgegeben an die Komponente die den Hook aufgerufen hat.</p>
<p>Die Daten stehen nun in der Komponente zur Verfügung und können in dieser beliebig verwendet werden:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// RepoInfo.js</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> useGitHubAccountData <span class="hljs-keyword">from</span> <span class="hljs-string">'./useGitHubAccountData'</span>;

<span class="hljs-keyword">const</span> RepoInfo = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> accountData = useGitHubAccountData(<span class="hljs-string">'manuelbieh'</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
      Der GitHub-Benutzer {accountData.name} besitzt {accountData.public_repos}{' '}
      öffentliche Repositories.
    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
  );
};

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">RepoInfo</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>An dieser Stelle können wir nun basierend auf der <code>RepoInfo</code>-Komponente hergehen und weitere Funktionalität implementieren. Statt eines festen GitHub-Accounts wollen wir den Benutzer vielleicht einen Account suchen lassen. Dazu legen wir uns mit dem <code>useState()</code>-Hook einen neuen <strong>State</strong> an, in den wir den vom Benutzer eingegebenen Account schreiben und geben diesen State an unseren <strong>Custom Hook</strong> weiter.</p>
<p>Da der <code>useEffect()</code>-Hook als <strong>Dependency</strong> den Account-Namen hat wird dieser immer dann ausgeführt wenn ein neuer Account-Name übergeben wird. Das bedeutet, dass mit jeder Änderung im Suchfeld ein neuer API Request initiiert wird, der uns die Daten zum eingegebenen Account besorgt:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// RepoLookup.js</span>
<span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> useGitHubAccountData <span class="hljs-keyword">from</span> <span class="hljs-string">'./useGitHubAccountData'</span>;

<span class="hljs-keyword">const</span> RepoLookup = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> [account, setAccount] = useState(<span class="hljs-string">''</span>);
  <span class="hljs-keyword">const</span> accountData = useGitHubAccountData(account);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{account}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =&gt;</span> setAccount(e.target.value)} /&gt;
      {!account ? (
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Bitte einen GitHub-Benutzernamen eingeben<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      ) : (
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
          Der GitHub-Benutzer {accountData.name} ({accountData.login}) besitzt{' '}
          {accountData.public_repos} öffentliche Repositories.
        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      )}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  );
};

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">RepoLookup</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Kurze Info am Rande: die Public API von GitHub erlaubt nur max. 60 API Requests pro Stunde. Wer hier also ernsthaft rumprobieren will kann sich einen API Token erstellen und diesen per <code>access_token=xyz</code> an die URL dranhängen. Der Token kann hier erstellt werden: <a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a>.</p>
</div>
<div class="chapter">
  <h1 id="hooks-api">Hooks API</h1>
<p>In diesem Kapitel möchte ich auf alle verfügbaren internen Hooks einmal eingehen, ihre genaue Verwendung und ihre Einsatzbereiche beschreiben. In der React Dokumentation werden diese unterteilt in drei generelle (<em>basic</em>) und sieben zusätzliche (<em>additional</em>) Hooks. Die zusätzlichen Hooks sind insbesondere für spezielle Anwendungsfälle (bspw. Performance-Optimierung) gedacht oder sie sind Abwandlungen der generellen Hooks.</p>
<p>Zu den drei <strong>generellen Hooks</strong> gehören die bereits in den vorherigen Kapiteln vorgestellten Hooks:</p>
<ul>
<li><code>useState</code></li>
<li><code>useEffect</code></li>
<li><code>useContext</code></li>
</ul>
<p>Die sieben <strong>weiteren Hooks</strong> sind:</p>
<ul>
<li><code>useReducer</code></li>
<li><code>useCallback</code></li>
<li><code>useMemo</code></li>
<li><code>useRef</code></li>
<li><code>useImperativeHandle</code></li>
<li><code>useLayoutEffect</code></li>
<li><code>useDebugValue</code></li>
</ul>
<h2 id="usestate">useState</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> [state, setState] = useState(initialState);</code></pre>
<p>Dieser Hook gibt uns einen <strong>Wert</strong> zurück und eine <strong>Funktion</strong> um selbigen zu aktualisieren. Während des ersten Renderings einer Komponente, die den <code>useState()</code>-Hook nutzt, entspricht dieser Wert dem als <code>initialState</code> übergebenen Parameter. Ist der übergebene Parameter eine Funktion nutzt React den Rückgabewert der Funktion als initialen Wert.</p>
<p>Bei der Update-Funktion stellt React sicher, dass diese stets die selbe <strong>Identität</strong> hat, erstellt die Funktion als nicht bei jedem Aufruf des Hooks neu. Dies ist wichtig, um unnötige Re-Renderings zu verhindern und führt außerdem dazu, dass sie nicht als <strong>Dependency</strong> an andere <strong>Hooks</strong> wie <code>useEffect()</code> oder <code>useCallback()</code> übergeben werden muss.</p>
<p>Ganz konkret gibt <code>useState()</code> ein <strong>Array</strong> zurück in dem das erste Element immer der <strong>Wert</strong> des States ist und das zweite Element immer eine <strong>Funktion</strong>, um diesen Wert zu aktualisieren. Für die Benennung von Wert und Funktion gibt es durch die Array Destructuring Syntax keine formellen Einschränkungen. Jedoch hat es sich schnell herauskristallisiert, dass in den deutlich überwiegenden Fällen die Form <code>value</code>/<code>setValue</code> eingehalten werden. Also etwa <code>user</code> und <code>setUser</code>. Aber auch andere Namen wie <code>changeUser</code> oder <code>updateUserState</code> wären natürlich denkbar.</p>
<p>Der Mechanismus zum Aktualisieren des States funktioniert hier ansatzweise ähnlich wie <code>this.setState()</code> in Klassen-Komponenten. So kann der Funktion entweder ein <strong>neuer Wert</strong> übergeben werden, der dann an die Stelle des alten Werts tritt oder eine <strong>Updater-Funktion</strong>. Diese bekommt den letzten Wert übergeben und nutzt den <strong>Rückgabewert</strong> aus der Funktion als neuen State.</p>
<p>Doch Achtung, es gibt einen entscheidenden Unterschied: anders als bei <code>this.setState()</code> werden Objekte <strong>nicht zusammengeführt</strong> mit dem bestehenden State, ****sondern der State wird *<em>komplett</em>* durch den neuen State **ersetzt!**</p>
<p>Um diesen Unterschied zu illustrieren schauen wir uns einmal den direkten Vergleich an:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };

  componentDidMount() {
    <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> });
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">d</span>: <span class="hljs-number">4</span> };
    });
  }

  render() {
    <span class="hljs-comment">// { a: 1, b: 2, c: 3, d: 4 }</span>
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>{JSON.stringify(this.state, null, 2)}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span></span>;
  }
}

<span class="hljs-keyword">const</span> StateHook = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> [example, setExample] = useState({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> });

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setExample({ <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> });
    setExample(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">d</span>: <span class="hljs-number">4</span> };
    });
  }, []);

  <span class="hljs-comment">// { d: 4 }</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>{JSON.stringify(example, null, 2)}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span></span>;
};

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">StateClass</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">StateHook</span> /&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span>
  );
};

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Während die <code>StateClass</code> die Daten aller Aufrufe von <code>this.setState()</code> sammelt und mit dem bestehenden State zusammenführt, überschreibt die <code>setState()</code>-Funktion im <code>StateHook</code> jeweils den kompletten State und ersetzt den kompletten alten Wert mit dem neuen Wert. Die Ausgabe ist also in der <strong>Klassen-Komponente</strong>: <code>{a: 1, b: 2, c: 3, d: 4}</code> und in der <strong>Function Component</strong> mit dem Hook ein einfaches <code>{d: 4}</code>, da dieses zuletzt in den State geschrieben wurde.</p>
<p>Gibt die Update-Funktion als neuen State exakt gleichen Wert zurück wie den vorherigen kommt das dem Abbruch eines State-Updates gleich und es wird kein Rerendering ausgelöst und auch keine Seiten-Effekte ausgelöst.</p>
<h2 id="useeffect">useEffect</h2>
<pre><code class="hljs javascript language-javascript">useEffect(effectFunction, dependenciesArray);</code></pre>
<p>Dieser <strong>Hook</strong> ist für <strong>imperative Seiteneffekte</strong> vorgesehen, wie etwa API Requests, Timer oder globale Event-Listener. Diese sind innerhalb von <strong>Function Components</strong> grundsätzlich nicht erlaubt oder zumindest zu vermeiden, da sie zu nicht nachvollziehbarem Verhalten und möglicherweise zu schwer zu behebenden Bugs führen können und werden.</p>
<p>Der <code>useEffect()</code>-<strong>Hook</strong> schafft hier Abhilfe und erlaubt die <em>sichere</em> Verwendung von Seiten-Effekten auch innerhalb einer <strong>Function Component</strong>.</p>
<p>Der <strong>Hook</strong> erwartet eine <strong>Funktion</strong> als ersten Parameter und optional ein <strong>Dependency Array</strong> als zweiten Parameter. Die Funktion wird aufgerufen <strong>nachdem</strong> eine Komponente gerendert wurde. Wird ein optionales <strong>Dependency Array</strong> übergeben, wird die Funktion nur dann ausgeführt wenn sich mindestens einer der Werte aus dem <strong>Dependency Array</strong> seit der letzten Ausführung der Funktion geändert hat. Wird ein leeres <strong>Dependency Array</strong> übergeben, also <code>[]</code>, wird die Funktion nur beim <strong>ersten</strong> Rendering der Komponente aufgerufen, vergleichbar also mit der <code>componentDidMount()</code> <strong>Lifecycle Methode</strong>, die wir bereits aus Klassen-Komponenten kennen.</p>
<h3 id="seiteneffekte-aufräumen">Seiteneffekte aufräumen</h3>
<p>In einigen Fällen hinterlassen Seiteneffekte "Spuren", die wieder aufgeräumt werden müssen wenn eine Komponente nicht mehr verwendet wird. Werden beispielsweise Intervalle mittels <code>setInterval()</code> gestartet, sollten diese beim Entfernen der Komponente via <code>clearTimeout()</code> gestoppt werden, andernfalls kann es zu Problemen wie im schlimmsten Falle Memory Leaks führen.</p>
<p>Auch global registrierte Event Listener wie <code>resize</code> oder <code>orientationchange</code> die dem <code>window</code>-Objekt mittels <code>addEventListener()</code> hinzugefügt werden, sollten spätestens beim Unmounting einer Komponente wieder durch <code>removeEventListener()</code> entfernt werden, damit der Code nicht mehr ausgeführt wird, wenn die Komponente sich gar nicht mehr im Seitenbaum befindet.</p>
<p>Zu diesem Zweck ist es möglich eine <strong>Cleanup-Funktion</strong> aus der <strong>Effekt-Funktion</strong> zurück zu geben. Gibt eine <strong>Effekt-Funktion</strong> eine <strong>Cleanup-Funktion</strong> zurück, wird diese vor jedem Aufruf der <strong>Effekt-Funktion</strong> ausgeführt, außer vor dem ersten Aufruf:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> React, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;

<span class="hljs-keyword">const</span> Clock = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> [time, setTime] = useState(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      setTime(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());
    }, <span class="hljs-number">1000</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      clearInterval(intervalId);
    };
  }, []);

  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${time.getHours()}</span>:<span class="hljs-subst">${time.getMinutes()}</span>:<span class="hljs-subst">${time.getSeconds()}</span>`</span>;
);

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span>, document.getElementById("root"));</span></code></pre>
<p>Im obigen Beispiel installieren wir einen Intervall beim <strong>Mounting</strong> der Komponente. Beim <strong>Unmounting</strong> der Komponente halten wir den Timer an, da wir sonst den State einer Komponente ändern würden, die sich nicht mehr im Seitenbaum befindet. Dies würde uns React mit einer Fehlermeldung quittieren, vor Memory Leaks warnen und uns darauf hinweisen, dass Subscriptions und andere asnychrone Tasks in der <strong>Cleanup</strong>-Funktion aufgeräut werden müssen:</p>
<div class="hint hint--danger">
<p>Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.</p>
</div>
<p>Indem wir eine Aufräum-Funktion aus der Effekt-Funktion zurückgeben, können wir den Intervall durch den Aufruf von <code>clearInterval()</code> abbrechen. Dies passiert vor jedem erneuten Aufruf der Effekt-Funktion, spätestens jedoch beim Unmounting.</p>
<h3 id="bedingte-aufrufe-der-effekt-funktion">Bedingte Aufrufe der Effekt-Funktion</h3>
<p>Standardmäßig wird der <code>useEffect()</code>-Hook bzw. dessen Effekt-Funktion nach jedem Rendering der Komponente erneut ausgeführt. Damit ist sichergestellt das der Effekt jedesmal ausgeführt wird wenn sich einige der von ihn verwendeten Abhängigkeiten (<em>Dependencies</em>) ändern. Greifen wir also innerhalb der Effekt-Funktion bspw. auf den State oder die Props einer Komponente zu, soll auch der Seiteneffekt erneut ausgeführt werden wenn sich eine dieser Dependencies ändert. Möchten wir etwa Profildaten zu einem Benutzer anzeigen und beziehen diese über eine API, so soll der API Request natürlich auch initiiert werden wenn der Benutzer dessen Profil wir anschauen wollen sich ändert während die Komponente gemounted ist.</p>
<p>Dies führt aber mitunter zu sehr vielen unnötigen Aufrufen der Funktion und führt auch dazu, dass die Funktion unter gewissen Umständen auch ausgeführt wird, wenn sich gar keine Daten seit dem letzten Rendering geändert haben, die für den Seiteneffekt relevant sind. Zu diesem Zweck bietet uns React die Möglichkeit ein <strong>Dependency Array</strong> als zweiten Parameter zu definieren. Dort können und sollen wir alle Werte eintragen, die eine erneute Ausführung der Effekt-Funktion herbeiführen sollen. Nur wenn sich mind. ein Wert im <strong>Dependency Array</strong> geändert hat, wird die Funktion erneut ausgeführt. Um am Beispiel unseres Benutzerprofils zu bleiben, wäre das hier etwa der Benutzername oder die ID, über die wir die Benutzerdaten von der API abrufen.</p>
<pre><code class="hljs javascript language-javascript">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> user = api.getUser(props.username);
  setUser(user);
}, [props.username]);</code></pre>
<p>Beim Erstellen eines solchen <strong>Dependency Arrays</strong> sollte man genau darauf achten, dass sämtliche Werte die innerhalb der Funktion verwendet werden und die sich im Laufe der Lebenszeit der Komponente ändern können auch dort auflistet. Soll die Effekt-Funktion nur einmalig ausgeführt werden, also einen ähnlichen Zweck erfüllen wie <code>componentDidMount()</code> in Klassen-Komponenten wird ein leeres Array (d.h. <code>[]</code>) übergeben.</p>
<div class="hint hint--info">
<p>Um die Arbeit bei der Erstellung von <strong>Dependency Arrays</strong> zu erleichtern oder gar zu automatisieren gibt es im <code>eslint-plugin-react-hooks</code> die <code>exhaustive-deps</code> Regel, die bei entsprechender Editor-Konfiguration (z.B. <em>Format on Save</em>) die in der Effekt-Funktion benutzten Abhängigkeiten automatisch in das <strong>Dependency Array</strong> einträgt oder zumindest warnt, sollten Unstimmigkeiten gefunden werden.</p>
<p>Aktiviert werden kann sie durch den Eintrag <code>"exhaustive-deps": "warn"</code> im <code>rules</code> Block der ESLint-Konfiguration.</p>
</div>
<h3 id="zeitliche-abfolge">Zeitliche Abfolge</h3>
<p>Die <strong>Effekt-Funktion</strong> wird <strong>asynchron</strong> mit Verzögerung nach den <strong>Layout-</strong> und <strong>Paint-Phasen</strong> vom Browser ausgeführt. Das sollte für die meisten Seiteneffekte völlig ausreichend sein. Jedoch kann es Situationen geben in denen um <strong>synchron</strong> ausgeführte Seiteneffekte kein Weg dran vorbei führt. Dies kann der Fall sein wenn etwa DOM-Mutationen involviert sind und die verzögerte Ausführung dazu führen würde, dass der Benutzer ein kurzes Flackern oder ein inkonsistentes User Interface wahrnehmen könnte.</p>
<p>Zu diesem Zweck wurde der <code>useLayoutEffect()</code>-Hook eingeführt. Er funktioniert identisch zum <code>useEffect()</code>-Hook, erwartet ebenso eine <strong>Effekt-Funktion</strong>, diese kann in der gleichen Form eine <strong>Aufräum-Funktion</strong> zurückgeben und auch das <strong>Dependency Array</strong> funktioniert identisch zum <code>useEffect()</code>-Hook. Der Unterschied besteht hier darin, dass sie synchron ausgeführt wird (statt asynchron), und zwar nachdem alle DOM-Mutationen geschrieben wurden.</p>
<p>Der <code>useLayoutEffect()</code>-Hook kann also aus dem DOM lesen und diesen ebenfalls synchron modifizieren, <strong>bevor</strong> der Browser die Änderungen in seiner Paint-Phase darstellt.</p>
<h3 id="asynchrone-effekt-funktionen">Asynchrone Effekt-Funktionen</h3>
<p>Auch wenn <strong>Effekt-Funktionen</strong> verzögert ausgeführt werden, dürfen sie selbst nicht asynchron sein bzw. keine Promises zurückgeben. Andernfalls bekommen wir eine Fehlermeldung in der uns React auf diesen Umstand hinweist:</p>
<div class="hint hint--danger">
<p>Warning: An Effect function must not return anything besides a function, which is used for clean-up.</p>
<p>It looks like you wrote useEffect(async () =&gt; …) or returned a Promise. Instead, you may write an async function separately and then call it from inside the effect […]</p>
<p>In the future, React will provide a more idiomatic solution for data fetching that doesn't involve writing effects manually.</p>
</div>
<p>Im obigen Beispiel hätte der <strong>inkorrekte</strong> <code>useEffect()</code>-Hook etwa so ausgesehen:</p>
<pre><code class="hljs javascript language-javascript">useEffect(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/users/manuelbieh'</span>);
  <span class="hljs-keyword">const</span> accountData = <span class="hljs-keyword">await</span> response.json();
  setGitHubAccount(accountData);

  fetchGitHubAccount(<span class="hljs-string">'manuelbieh'</span>);
}, []);</code></pre>
<p>Dies ist <strong>nicht erlaubt</strong>, da die Effekt-Funktion mit dem <code>async</code> Schlüsselwort als <em>asynchron</em> deklariert wird. Wie also lösen wir das Problem? Nun, die Lösung ist in diesem Fall relativ simpel: wir verschieben den asynchrone Teil der Funktion in eine eigenen, asynchronen Funktion <strong>innerhalb der Effekt-Funktion</strong> und rufen diese Funktion dann lediglich auf:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React, { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> App = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> [gitHubAccount, setGitHubAccount] = useState();

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> fetchGitHubAccount = <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(
        <span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">${props.username}</span>`</span>
      );
      <span class="hljs-keyword">const</span> accountData = <span class="hljs-keyword">await</span> response.json();
      setGitHubAccount(accountData);
    };

    fetchGitHubAccount();
  }, [props.username]);

  <span class="hljs-keyword">if</span> (!gitHubAccount) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
      {gitHubAccount.name} has {gitHubAccount.public_repos} public repos
    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
  );
};

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> <span class="hljs-attr">username</span>=<span class="hljs-string">"manuelbieh"</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>In diesem Fall ist nicht mehr die Effekt-Funktion selbst asynchron, sondern die asynchrone Funktionalität wird an die asynchrone Funktion <code>fetchGitHubAccount()</code> ausgelagert, die wir <strong>innerhalb</strong> des <code>useEffect()</code>-Hooks definieren.</p>
<p>Die asynchrone Funktion muss dabei nicht zwingend <strong>in</strong> der Effekt-Funktion erzeugt werden. Die Effekt-Funktion selbst darf nur eben nicht selbst asynchron sein.</p>
<h2 id="usecontext">useContext</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> myContextValue = useContext(MyContext);</code></pre>
<p>Dieser Hook erwartet als einzigen Parameter einen Context-Typen der mittels <code>React.createContext()</code> erstellt wurde und gibt dann den Wert des in der Komponenten-Hierarchie nächsthöheren Context-Providers des entsprechenden Typs zurück.</p>
<p>Der <code>useContext()</code>-Hook verhält sich dabei wie eine Context Consumer-Komponente und verursacht ein Rerendering der <strong>Function Component</strong> sobald der Wert des Contexts im jeweiligen Provider-Element geändert wurde.</p>
<p>Die Verwendung des Hooks ist optional und so ist es auch weiterhin möglich Context-Consumer im <strong>JSX</strong> der <strong>Function Component</strong> zu verwenden. Allerdings ist der Hook die deutlich übersichtlichere Variante, da dieser keine neue Hierarchie-Ebene im Komponentenbaum erzeugt.</p>
<h2 id="usereducer">useReducer</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> [state, dispatch] = useReducer(reducerFunc, initialState, initFunc);</code></pre>
<p>Der <code>useReducer()</code>-Hook ist eine Alternative zu <code>useState()</code>, die es erlaubt auch komplexeren States zu managen. Der Hook ist angelehnt an die Flux-Architektur, bei der, kurz gesagt, eine <strong>Reducer-</strong>Funktion einen <strong>neuen State erzeugt</strong>, indem sie den <strong>letzten State</strong> und eine sog. <strong>Action</strong> übergeben bekommt.</p>
<p>Die <strong>Reducer</strong>-Funktion wird durch den Aufruf einer <strong>Dispatch</strong>-Funktion aufgerufen, die wiederum eine <strong>Action</strong> übergeben bekommt. Die <strong>Action</strong> selbst ist dabei ein Objekt, das zwingend eine <code>type</code> Eigenschaft und oftmals (optional) eine <code>payload</code>-Eigenschaft besitzt. Aus dieser <strong>Action</strong> und dem <strong>letzten State</strong> erzeugt die <strong>Reducer</strong>-Funktion dann den <strong>neuen State</strong>. Die <strong>Reducer</strong>-Funktion hat also die Form <code>(oldState, action) =&gt; newState</code>.</p>
<p>Schauen wir uns auch hierzu einmal ein simples Beispiel an und entwickeln zu diesem Zweck eine einfache <code>Counter</code>-Komponente, mit der wir über zwei Buttons (<code>+</code> und <code>-</code>) einen Wert rauf- und runterzählen können:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React, { useReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> initialState = {
  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
};

<span class="hljs-keyword">const</span> reducerFunction = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> {
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'INCREMENT'</span>:
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span> };
    <span class="hljs-keyword">case</span> <span class="hljs-string">'DECREMENT'</span>:
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: state.count - <span class="hljs-number">1</span> };
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unbekannte Action'</span>);
  }
};

<span class="hljs-keyword">const</span> Counter = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> [state, dispatch] = useReducer(reducerFunction, initialState);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{state.count}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: 'INCREMENT' })}&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: 'DECREMENT' })}&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Wir definieren zunächst den initialen State (<code>initialState</code>) und die Reducer-Funktion (<code>reducerFunction</code>). Der <strong>initiale State</strong> besteht lediglich aus einem Objekt mit einer <code>count</code>-Eigenschaft, die initial <code>0</code> ist. Die <strong>Reducer</strong>-Funktion erwartet einen <code>state</code> und eine <code>action</code>. die von React später über den Aufruf der <strong>Dispatch</strong>-Funktion an den Reducer übergeben werden. Aus diesen beiden Parametern erzeugen wir dann den neuen State. <strong>Wichtig:</strong> Hier müssen wir stets einen neuen State zu erzeugen statt den bestehenden zu mutieren, da eine Mutation des bestehenden States zu ungewünschten Seiteneffekten und fehlerhafter Darstellung führen kann. Eine <strong>Reducer</strong>-Funktion muss also eine <strong>Pure Function</strong> sein!</p>
<p>Die <strong>Reducer</strong>-Funktion und den initialen State geben wir dann in den <code>useReducer()</code>-Hook hinein, der uns daraufhin ähnlich wie der <code>useState()</code>-Hook einen Tupel zurückgibt in dem das erste Element immer der <strong>aktuelle State</strong> in der aktuellen Rendering-Phase ist, das zweite Element ist dann die besagte <strong>Dispatch</strong>-Funktion.</p>
<p>Möchten wir nun den State verändern, rufen wir in der Komponente die <code>dispatch</code>-Funktion auf und übergeben ihr eine <strong>Action</strong>. Dies passiert in unserer Beispiel-Komponente per Klick auf einen der beiden Buttons, die dann die Action <code>{type: "INCREMENT"}</code> (zum Raufzählen) oder <code>{type: "DECREMENT"}</code> (zum Runterzählen) „dispatchen“.</p>
<p>Wird eine Action <em>dispatched</em> und wird dabei ein neuer State erzeugt, löst React ein Rerendering aus und der neu erzeugte State steht in der von der Reducer-Funktion zurückgegebenen <code>state</code> Variablen zur Verfügung. Wird hingegen der gleiche State von der <strong>Reducer</strong>-Funktion zurückgegeben wird <strong>kein</strong> Rerendering ausgelöst!</p>
<h3 id="der-dritte-parameter">Der dritte Parameter</h3>
<p>Neben der <code>reducer</code>-Funktion und dem <code>initialState</code>, die jeweils zwingend angegeben werden müssen, kann der <code>useReducer()</code>-Hook aber noch einen dritten, optionalen Parameter erhalten, nämlich eine <code>init</code>-Funktion zum Errechnen des initialen States. Die Funktion kann verwendet werden um bspw. den initialen Wert des <strong>Reducers</strong> in einer externen Funktion außerhalb des Reducers zu berechnen.</p>
<p>Wird eine solche <code>init</code>-Funktion übergeben, wird diese vom Hook beim <strong>ersten</strong> Aufruf aufgerufen und der <code>initialState</code> wird ihr als <strong>initiales Argument</strong> übergeben. Dies kann insbesondere dann sinnvoll sein wenn der <strong>initiale State</strong> auf den <strong>Props</strong> einer Komponente basiert. Diese können dann im zweiten Parameter an die <code>init</code>-Funktion weitergereicht werden, die darauf basierend den initialen State des Reducers erzeugen kann:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React, { useReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> reducerFunction = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> {
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'INCREMENT'</span>:
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span> };
    <span class="hljs-keyword">case</span> <span class="hljs-string">'DECREMENT'</span>:
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: state.count - <span class="hljs-number">1</span> };
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unbekannte Action'</span>);
  }
};

<span class="hljs-keyword">const</span> initFunction = <span class="hljs-function">(<span class="hljs-params">initValue</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: initValue };
};

<span class="hljs-keyword">const</span> Counter = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> [state, dispatch] = useReducer(
    reducerFunction,
    props.startValue,
    initFunction
  );

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{state.count}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: 'INCREMENT' })}&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: 'DECREMENT' })}&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> <span class="hljs-attr">startValue</span>=<span class="hljs-string">{3}</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>In diesem Beispiel erweitern wir den <code>useReducer()</code>-Hook um den dritten, optionalen Parameter: der <strong>Init-</strong>Funktion. Aus dem <code>initialState</code> im ersten Beispiel wird ein Argument für die <strong>Init-</strong>Funktion. Der Wert für dieses Funktions-Argument wird der Komponente hier als <code>startValue</code> über die Props übergeben.</p>
<h3 id="reducer-in-der-praxis">Reducer in der Praxis</h3>
<p>Das Prinzip von <strong>Reducern</strong> dürfte einem großen Teil der React-Community wohl erstmals durch den Aufstieg von <strong>Redux</strong> nahe gebracht worden sein. <strong>Redux</strong> ist ein Paket um globalen State komfortabel managen zu können und wurde in der Vergangenheit häufig verwendet wenn das Handling von lokalen States in React zu unübersichtlich wurde oder über über zu viele Komponenten hinweg durch sog. „Props Drilling“ (also dem Weiterreichen von Props über mehrere Hierarchie-Ebenen hinweg) zu umständlich wurde.</p>
<p><strong>Redux</strong> (und daher der Name) besteht in seinem Kern darin, Reducer-Funktionen zu verwalten und deren State und Dispatch-Funktion in den Komponenten verfügbar zu machen, die den globalen State lesen oder verändern sollen. Mit dem <code>useReducer()</code>-Hook bekommt React nun eine eigene Funktion um komplexes State-Management mittels Reducer-Funktionen zu bewerkstelligen.</p>
<p>Ein typischer Anwendungsfall für Reducer ist dabei die Status-Verwaltung bei API Requests. Als Best Practice hat sich hier bspw. herauskristallisiert drei verschiedene Actions je API Request zu definieren:</p>
<ul>
<li>eine Action wenn der Request gestartet wird, die die Anwendung davon in Kenntnis setzt, dass Daten geladen werden,</li>
<li>eine Action wenn der Request fehlgeschlagen ist, der den Lade-Status zurück setzt und den State darüber in Kenntnis setzt, dass ein Fehler aufgetreten ist (und ggf. auch welcher),</li>
<li>eine Action wenn der Request erfolgreich war, der die von der API erhaltenen Daten in den State schreibt</li>
</ul>
<p>Werfen wir hierzu einen Blick auf ein solches Beispiel und laden wieder unsere Account-Daten via GitHub-API:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React, { useEffect, useReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> initialState = {
  <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">isError</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">lastUpdated</span>: <span class="hljs-literal">null</span>,
};

<span class="hljs-keyword">const</span> accountReducer = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> {
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'REQUEST_START'</span>:
      <span class="hljs-keyword">return</span> {
        ...state,
        <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">true</span>,
      };
    <span class="hljs-keyword">case</span> <span class="hljs-string">'REQUEST_SUCCESS'</span>:
      <span class="hljs-keyword">return</span> {
        ...state,
        <span class="hljs-attr">data</span>: action.payload,
        <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">isError</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">lastUpdated</span>: action.meta.lastUpdated,
      };
    <span class="hljs-keyword">case</span> <span class="hljs-string">'REQUEST_ERROR'</span>:
      <span class="hljs-keyword">return</span> {
        ...state,
        <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">isError</span>: <span class="hljs-literal">true</span>,
      };
  }
};

<span class="hljs-keyword">const</span> RepoInfo = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> [state, dispatch] = useReducer(accountReducer, initialState);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> fetchGitHubAccount = <span class="hljs-keyword">async</span> (username) =&gt; {
      <span class="hljs-keyword">try</span> {
        dispatch({
          <span class="hljs-attr">type</span>: <span class="hljs-string">'REQUEST_START'</span>,
        });
        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(
          <span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">${username}</span>`</span>
        );

        <span class="hljs-keyword">const</span> accountData = <span class="hljs-keyword">await</span> response.json();
        dispatch({
          <span class="hljs-attr">type</span>: <span class="hljs-string">'REQUEST_SUCCESS'</span>,
          <span class="hljs-attr">payload</span>: accountData,
          <span class="hljs-attr">meta</span>: {
            <span class="hljs-attr">lastUpdated</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
          },
        });
      } <span class="hljs-keyword">catch</span> (err) {
        dispatch({
          <span class="hljs-attr">type</span>: <span class="hljs-string">'REQUEST_ERROR'</span>,
          <span class="hljs-attr">error</span>: <span class="hljs-literal">true</span>,
        });
      }
    };

    fetchGitHubAccount(props.username);
  }, [props.username]);

  <span class="hljs-keyword">if</span> (state.isError) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Ein Fehler ist aufgetreten.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
  }

  <span class="hljs-keyword">if</span> (state.isLoading) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Daten werden geladen.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
  }

  <span class="hljs-keyword">if</span> (!state.data) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Es wurde kein GitHub-Account geladen<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
      {state.data.name} hat {state.data.public_repos} öffentliche Repos
    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
  );
};

ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">RepoInfo</span> <span class="hljs-attr">username</span>=<span class="hljs-string">"manuelbieh"</span> /&gt;</span>,
  document.getElementById('root')
);</span></code></pre>
<p>Wir benutzen wieder den <code>useReducer()</code>-Hook und übergeben ihm die <code>accountReducer</code>-Funktion. In dieser Funktion reagieren wir auf die drei <strong>Actions</strong> vom <strong>Typ</strong> <code>REQUEST_START</code>, <code>REQUEST_SUCCESS</code> und <code>REQUEST_ERROR</code>.</p>
<p>Der <code>initialState</code> besteht aus einem Objekt mit einer leeren <code>data</code>-Eigenschaft, den beiden Flags <code>isFetching</code> und <code>isError</code>, die unserer Komponente später mitteilen ob Daten geladen werden oder ob ein Fehler aufgetreten ist, sowie einer <code>lastUpdated</code>-Eigenschaft, in der wir den Zeitpunkt des letzten erfolgreichen Requests speichern. Diese können wir später nutzen um etwa Requests nur einmal pro Minute auszuführen oder dem Benutzer zu signalisieren, dass er Daten sieht, die schon für längere Zeit nicht aktualisiert wurden.</p>
<p>Wir nutzen außerdem einen <code>useEffect()</code>-Hook um das Laden der Daten zu veranlassen sobald sich der in den <strong>Props</strong> übergebene GitHub-Benutzername ändert. Ist dies der Fall, wird zu aller erst die <code>REQUEST_START</code> <strong>Action</strong> dispatched. Der <strong>Reducer</strong> erzeugt daraufhin den folgenden neuen State:</p>
<pre><code class="hljs diff language-diff">{
  data: null,
<span class="hljs-deletion">- isLoading: false,</span>
<span class="hljs-addition">+ isLoading: true,</span>
  isError: false,
  lastUpdated: null,
}</code></pre>
<p>Dadurch greift in unserer Komponente weiter unten nun folgende Bedingung:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">if</span> (state.isLoading) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Daten werden geladen.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
}</code></pre>
<p>Und signalisiert dem Benutzer, dass momentan Daten geladen werden.</p>
<p>Als nächstes können zwei Fälle eintreten: entweder der Request schlägt fehl oder wir beziehen erfolgreich Daten von der API.</p>
<p>Schlägt der Request fehl, dann würde die <code>REQUEST_ERROR</code> <strong>Action</strong> dispatched. Unser State würde sich daraufhin wie folgt verändern:</p>
<pre><code class="hljs diff language-diff">{
  data: null,
<span class="hljs-deletion">- isLoading: true,</span>
<span class="hljs-addition">+ isLoading: false,</span>
<span class="hljs-deletion">- isError: false,</span>
<span class="hljs-addition">+ isError: true,</span>
  lastUpdated: null,
};</code></pre>
<p>Da kein Request mehr durchgeführt wird, wird die <code>isLoading</code> Flag von <code>true</code> wieder auf <code>false</code> zurückgesetzt um dem Benutzer nicht fälschlicherweise zu signalisieren, dass wir noch Daten laden würden. Da ein Fehler aufgetreten ist, setzen wir gleichzeitig <code>isError</code> von <code>false</code> auf <code>true</code>. Statt der Lade-Nachricht greift nun folgende Bedingung und setzt den Benutzer vom aufgetretenen Fehler in Kenntnis:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">if</span> (state.isError) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Ein Fehler ist aufgetreten.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
}</code></pre>
<p>An dieser Stelle wäre es durchaus ratsam dem Benutzer mitzuteilen was falsch gelaufen ist und wie er den Fehler ggf. beheben kann. Vielleicht existiert der übergebene Benutzername nicht und man könnte ihm die Chance geben diesen zu korrigieren oder die API ist gerade nicht erreichbar, dann könnte man dem Benutzer die Möglichkeit geben den Request zu einem späteren Zeitpunkt noch einmal zu wiederholen.</p>
<p>Für den Fall dass alles geklappt hat und wir korrekt Daten von der API beziehen konnten wird die <code>REQUEST_SUCCESS</code> Action dispatched. Diese enthält neben der <code>payload</code>, die den geladenen Daten entspricht auch eine <code>meta</code>-Eigenschaft, mit der wir den Zeitpunkt des Requests mitgeben.</p>
<p>Der <strong>neue State</strong> der vom <strong>Reducer</strong> erzeugt wird unterscheidet sich dann folgendermaßen vom letzten State:</p>
<pre><code class="hljs diff language-diff">{
<span class="hljs-deletion">- data: null,</span>
<span class="hljs-addition">+ data: {</span>
<span class="hljs-addition">+   "login": "manuelbieh",</span>
<span class="hljs-addition">+   "name": "Manuel Bieh",</span>
<span class="hljs-addition">+   "public_repos": 59,</span>
<span class="hljs-addition">+   [...]</span>
<span class="hljs-addition">+ },</span>
<span class="hljs-deletion">- isLoading: true,</span>
<span class="hljs-addition">+ isLoading: false,</span>
  isError: false,
<span class="hljs-deletion">- lastUpdated: null,</span>
<span class="hljs-addition">+ lastUpdated: "2019-03-19T02:29:10.756Z",</span>
}</code></pre>
<p>Unsere <code>data</code>-Eigenschaft enthält nun die Daten, die wir von der API bekommen haben. Der <code>isLoading</code>-Status wird wiede auf <code>false</code> zurückgesetzt, die <code>lastUpdated</code>-Eigenschaft setzen wir auf den Zeitpunkt wann wir auch die Daten in den State geschrieben haben. In unserer Komponente sollte nun die gewünschte Ausgabe erzeugt werden:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
    {state.data.name} hat {state.data.public_repos} öffentliche Repos
  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
);</code></pre>
<p>Damit haben wir neben dem ersten komplexeren Reducer auch zugleich ein erstes Zusammenspiel der beiden <strong>Hooks</strong> <code>useEffect()</code> und <code>useReducer()</code> in einem praxisnahen Beispiel implementiert!</p>
<p>Übrigens: genau wie beim <code>useState()</code>-Hook löst auch der <code>useReducer()</code>-Hook kein erneutes Rerendering aus wenn die Reducer-Funktion den gleichen State wie vorher zurückgibt!</p>
<h2 id="usecallback">useCallback</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> memoizedFunction = useCallback(callbackFunction, dependencyArray);</code></pre>
<p>Der <code>useCallback()</code>-Hook dient zur Optimierung hinsichtlich der Performance einer Anwendung. Er erwartet eine Funktion und erzeugt eine <strong>eindeutige Identität</strong> dieser Funktion die so lange Bestand hat, bis sich die <strong>Dependencies</strong> des Hooks ändern.</p>
<p>Dies ist dazu gedacht um eine immer gleiche Referenz zu einer Funktion an Komponenten zu übergeben die entweder <code>PureComponents</code>, eine eigene <code>shouldComponentUpdate()</code>-Methode implementieren oder die mittels <code>React.memo()</code> umschlossen werden.</p>
<p>Der <code>useCallback()</code>-Hook erwartet eine Funktion als erstes Argument und einen Dependency Array (wie beim <code>useEffect()</code>-Hook) und gibt im Gegenzug dafür eine „stabile“ Referenz zur hereingereichten Funktion zurück. Stabil heißt in dem Fall dass sie sich nur dann ändert wenn sich die <strong>Dependencies</strong> des Hooks verändert haben. Bis zu diesem Zeitpunkt ist eine via <code>useCallback()</code> erzeugte Referenz für <code>PureComponents</code> oder Komponenten mit <code>React.memo()</code> die selbe.</p>
<p>Was erst einmal kompliziert klingen mag, lässt sich wie so häufig am Besten anhand eines Beispiels erklären:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React, { useState, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> FancyInput = React.memo(<span class="hljs-function">(<span class="hljs-params">{ name, onChange }</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Rendering FancyInput'</span>);
  <span class="hljs-keyword">return</span> &lt;input type="text" name={name} onChange={onChange} /&gt;;
});

const Form = () =&gt; {
  const [values, setValues] = useState({});

  const changeHandler = (e) =&gt; {
    const { name, value } = e.target;

    setValues((state) =&gt; {
      return {
        ...state,
        [name]: value,
      };
    });
  };

  return (
    &lt;&gt;
      &lt;pre&gt;{JSON.stringify(values, null, 2)}&lt;/pre&gt;
      &lt;FancyInput name="example" onChange={changeHandler} /&gt;
    &lt;/&gt;
  );
};

ReactDOM.render(&lt;Form /&gt;, document.getElementById('root'));</code></pre>
<p>Hier sehen wir die zwei Komponenten <code>Form</code> und <code>FancyInput</code>. Die <code>Form</code>-Komponente rendert eine <code>FancyInput</code>-Komponente und übergibt ihr neben dem <code>name</code>-Attribut auch eine <code>onChange</code>-Funktion. Diese ändert bei jeder Änderung im Eingabefeld den State der <code>Form</code>-Komponente und löst somit ein Rendering aus.</p>
<p>Die <code>changeHandler</code>-Funktion selbst wird <strong>in der Form-Komponente erstellt</strong>, und zwar mit jedem neuen Rendering erneut. D.h. <strong>die Referenz zur Funktion ändert sich</strong>, da wir mit jedem neuen Rendering eine neue Funktion erzeugen. In Deutschland kann man dazu wohl sagen: wir übergeben zwar die <strong>gleiche</strong>, nicht jedoch die <strong>selbe</strong> Funktion.</p>
<p>Dadurch greift die Optimierung von <code>React.memo()</code> die wir um die <code>FancyInput</code>-Komponente gelegt haben <strong>nicht</strong>. Kurz zur Auffrischung: <code>React.memo()</code> prüft <strong>vor</strong> dem Rendering einer Komponente ob sich deren <strong>Props</strong> ggü. des letzten Renderings geändert haben und löst ein Rerendering aus, falls diese Bedingung erfüllt ist. Da wir die <code>changeHandler</code>-Funktion bei jedem Rendering der <code>Form</code>-Komponente neu erstellen, ist diese Bedingung <strong>immer</strong> wahr und die <code>FancyInput</code>-Komponente wird entsprechend bei jedem Rendering der <code>Form</code>-Komponente ebenfalls neu gerendert.</p>
<p>Hier kommt nun <code>useCallback</code> ins Spiel. Wrappen wir unsere <code>changeHandler</code>-Funktion in diesem Hook, erzeugt React eine Funktion mit einer <strong>eindeutigen</strong> und <strong>stabilen</strong> Referenz und gibt uns diese zurück, damit wir diese sicher an die <code>FancyInput</code>-Komponente weitergeben können, ohne jedesmal ein Rerendering auszulösen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> changeHandler = useCallback(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { name, value } = e.target;

  setValues(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> {
      ...state,
      [name]: value,
    };
  });
}, []);</code></pre>
<p>Hier nutzen wir nun die Optimierungsmöglichkeiten von <code>React.memo()</code> (oder in Klassen-Komponenten <code>PureComponent</code>) und lösen nicht mehr ungewollt ein Rerendering der jeweiligen Kind-Komponenten aus.</p>
<p>Beruht die Funktion auf Werten die sich während der Lebensdauer der Komponente ändern können, können diese wie auch schon beim <code>useEffect()</code>-Hook in einem <strong>Dependency Array</strong> als zweiter Parameter von <code>useCallback()</code> angegeben werden. React erstellt dann eine neue Funktion mit neuer Referenz, sobald sich eine Dependency ändert.</p>
<div class="hint hint--info">
<p>Wie auch schon beim <code>useEffect()</code>-Hook hilft die <code>exhaustive-deps</code> Regel des <code>eslint-plugin-react-hooks</code> bei der korrekten Erstellung des <strong>Dependency Arrays</strong>.</p>
</div>
<h2 id="usememo">useMemo</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> memoizedValue = useMemo(valueGetterFunction, dependencyArray);</code></pre>
<p>Der <code>useMemo()</code>-Hook ist der zweite <strong>Hook</strong> zur hardcore <strong>Performance-Optimierung</strong>, neben <code>useCallback()</code>. Dabei funktioniert <code>useMemo()</code> auch recht ähnlich. Allerdings mit dem entscheidenden Unterschied, dass hier nicht die hinein gegebene Funktion mit einer eindeutigen Identität versehen wird, sondern der Rückgabewert der aus der Funktion, die in den <code>useMemo()</code>-Hook hereingegeben wird.</p>
<p>Zusammengefasst bedeutet das:</p>
<pre><code class="hljs javascript language-javascript">useCallback(fn, deps);</code></pre>
<p>entspricht:</p>
<pre><code class="hljs javascript language-javascript">useMemo(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> fn, deps);</code></pre>
<p>Während uns <code>useCallback()</code> also die <strong>hereingegebene Funktion</strong> in einer <em>memoized</em> Version zurückgibt, gibt uns <code>useMemo()</code> den <strong>Rückgabewert</strong> der hereingegebenen Funktion als <em>memoized</em> Version zurück. Benutzt werden kann <code>useMemo()</code> für Funktionen die sehr rechenintensive Aufgaben erfüllen und nicht bei jedem Rerendering erneut ausgeführt werden sollen.</p>
<p>Werfen wir einmal einen Blick auf eine nicht optimierte Komponente:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React, { useState, useMemo } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> fibonacci = <span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span>
  num &lt;= <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : fibonacci(num - <span class="hljs-number">1</span>) + fibonacci(num - <span class="hljs-number">2</span>);

<span class="hljs-keyword">const</span> FibonacciNumber = <span class="hljs-function">(<span class="hljs-params">{ value }</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> result = fibonacci(value);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
      {value}: {result}
    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> [values, setValues] = useState([]);

  <span class="hljs-keyword">const</span> handleKeyUp = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> { key, target } = e;
    <span class="hljs-keyword">const</span> { value } = target;
    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'Enter'</span>) {
      <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">40</span> || value &lt; <span class="hljs-number">1</span>) {
        alert(<span class="hljs-string">'Invalid value'</span>);
        <span class="hljs-keyword">return</span>;
      }
      setValues(<span class="hljs-function">(<span class="hljs-params">values</span>) =&gt;</span> values.concat(target.value));
    }
  };

  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;input type="number" min={1} max={40} onKeyUp={handleKeyUp} /&gt;
      {values.map((value, i) =&gt; (
        &lt;FibonacciNumber value={value} key={`${i}:${value}`} /&gt;
      ))}
    &lt;/&gt;
  );
};

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</code></pre>
<p>Unsere kleine App besteht zunächst aus einem Eingabefeld für Nummern. Wird eine Nummer eingegeben und die <strong>Enter</strong>-Taste betätigt, wird diese Nummer in den <code>values</code>-State geschrieben. Dieser ist in diesem Fall ein Array, das all unsere eingegebenen Nummern vorhält. Die Komponente iteriert dann durch alle eingegebenen Nummern und rendert eine <code>FibonacciNumber</code>-Komponente, die den Wert (also die jeweilige Nummer) übergeben bekommt.</p>
<p>Die <code>FibonacciNumber</code>-Komponente berechnet die entsprechende Fibonacci-Zahl zu dieser Nummer und stellt diese dar. Je nach Nummer und Rechenkraft kann das Berechnen der übergebenen Nummer schon mal eine gewisse Zeit in Anspruch nehmen. (Auf meinem Rechner sind das bei der 40. Fibonacci-Zahl bspw. 2-3 Sekunden).</p>
<p>Diese Berechnung wird nun bei <strong>jeder</strong> Eingabe einer Nummer für <strong>jede</strong> bereits vorhandene Fibonacci-Nummer erneut ausgeführt. Gebe ich also 40 ein, warte die ca. 3 Sekunden bis mein Computer fertig gerechnet hat und gebe erneut 40 ein, warte ich nun schon zweimal 3 Sekunden, da der Wert in beiden Komponenten erneut berechnet wird.</p>
<p>Nun kommt <code>useMemo()</code> ins Spiel. Durch eine vermeintlich simple Änderung der Zeile</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> result = fibonacci(value);</code></pre>
<p>in diese:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> result = useMemo(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> fibonacci(value), [value]);</code></pre>
<p>… erzeugen wir einen <em>memoisierten</em> Wert.</p>
<p>Dies bedeutet, dass React die Berechnung des Werts beim <strong>ersten Rendering</strong> ausführt, sich den Wert <strong>merkt</strong> und erst dann wieder neu berechnet, wenn sich der Wert der <code>value</code> Prop für genau diese Komponente geändert hat. Ändert sich der Wert bzw. genauer die <strong>Dependencies</strong> zwischen zwei Renderings nicht, nutzt React den Wert der letzten Berechnung, ohne jedoch die Berechnung erneut auszuführen.</p>
<p><strong>Doch Vorsicht:</strong> all dies passiert auf Basis jeweils <strong>eines</strong> Aufrufs des <code>useMemo()</code>-Hooks. Rufe ich die selbe Funktion zweimal in zwei verschiedenen <code>useMemo()</code>-Hooks auf wird die Berechnung für jeden der beiden Hooks separat ausgeführt, selbst wenn beide die gleiche Funktion mit den gleichen Parametern nutzen. Der zweite Hook nutzt <strong>nicht</strong> das Ergebnis der ersten Berechnung!</p>
<h2 id="useref">useRef</h2>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> ref = useRef(initialValue);</code></pre>
<p>Der <code>useRef()</code>-Hook ist, wie der Name dies erahnen lässt, die Hooks-Variante um <strong>Refs</strong> zu erzeugen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React, { useEffect, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> inputRef = useRef();
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    inputRef.current.focus();
  }, []);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{inputRef}</span> /&gt;</span>;
}

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Doch dies ist nur die halbe Wahrheit, denn in <strong>Function Components</strong> dienen <strong>Refs</strong> noch einem weiteren Zweck: mit ihnen ist es möglich eine <strong>veränderbare Referenz</strong> zu erzeugen, die während der gesamten Lebensdauer einer Komponente (d.h. bis sie unmounted wird) Bestand hat. Sie erfüllt sozusagen darüber hinaus auch die Aufgaben von Instanzvariablen bei Klassen-Komponenten.</p>
<p>Von der Funktionsweise her funktioniert <code>useRef()</code> so, dass es einen optionalen Initialwert bekommt, und ein Objekt mit einer <code>current</code>-Eigenschaft zurück gibt, auf die dann innerhalb der <strong>Function Component</strong> zugegriffen werden kann. Und mit Zugriff ist hier sowohl lesend als auch schreibend gemeint. Möchten wir bspw. Daten vorhalten deren Änderung kein Rerendering auslöst, deren Referenz aber dennoch erhalten bleiben zwischen zwei Renderings der Komponente, nutzen wir dafür den <code>useRef()</code>-Hook.</p>
<h2 id="uselayouteffect">useLayoutEffect</h2>
<pre><code class="hljs javascript language-javascript">useLayoutEffect(effectFunction, dependenciesArray);</code></pre>
<p>Den <code>useLayoutEffect()</code>-Hook hatte ich bei der Erklärung des <code>useEffect()</code>-Hooks schon einmal kurz angeteasert, er funktioniert grundsätzlich genau wie der <code>useEffect()</code>-Hook, unterscheidet sich jedoch durch den Zeitpunkt seiner Ausführung und seiner synchronen Natur vom <code>useEffect()</code>-Hook.</p>
<p>Während <code>useEffect()</code> verzögert <strong>nach</strong> der <strong>Layout-</strong> und <strong>Paint-</strong>Phase des Browsers ausgeführt wird, werden Layout Effekte synchron <strong>nach</strong> der <strong>Layout</strong>- und <strong>vor</strong> der <strong>Paint</strong>-Phase ausgeführt. Das wiederum bedeutet, dass sie die Chance haben das aktuelle Layout aus dem DOM auszulesen und zu verändern <strong>bevor</strong> der Browser die Änderungen darstellt.</p>
<p>Dieses Verhalten entspricht dem von <code>componentDidMount()</code> und <code>componentDidUpdate()</code> in <strong>Klassen-Komponenten</strong>, dennoch wird aus Gründen der Performance empfohlen den <code>useEffect()</code>-Hook zu nutzen und nur dann auf <code>useLayoutEffect()</code> zurück zu greifen wenn ihr entweder genau wisst was ihr da tut (und warum!) oder wenn ihr bei der Migration einer <strong>Klassen-Komponente</strong> in eine <strong>Function Component</strong> Probleme habt, die auf den unterschiedlichen Zeitpunkt der Ausführung der Effekte zurückzuführen sind.</p>
<p>Wird der <code>useLayoutEffect()</code>-Hook in Zusammenhang mit <strong>Server Side Rendering</strong> verwendet ist Vorsicht geboten: weder <code>useEffect()</code> noch <code>useLayoutEffect()</code> wird serverseitig ausgeführt. Während das beim <code>useEffect()</code>-Hook durch die verzögerte Ausführung nach den Layout- und Paint-Phasen kein Problem ist, kann es beim <code>useLayoutEffect()</code>-Hook jedoch zu einer Abweichung vom serverseitig gerenderten Markup zum initialen clientseitigen Rendering kommen. React weist dann in einer Konsolen-Warnung darauf hin. In diesem Fall sollte dann der <code>useEffect()</code>-Hook verwendet werden oder aber die Komponente mit dem <code>useLayoutEffect()</code>-Hook erst nach der ersten Paint-Phase gemounted werden:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> [mountLayoutComp, setMountLayoutComp] = useState(<span class="hljs-literal">false</span>);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setMountLayoutComp(<span class="hljs-literal">true</span>);
  }, []);

  <span class="hljs-keyword">return</span> mountLayoutComp ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComponentWithLayoutEffect</span> /&gt;</span> : null;
};

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>In diesem Fall wird die Komponente mit dem <code>useLayoutEffect()</code> erst dann registriert wenn die Komponente erstmals gemounted wurde. Dies passiert durch die Abfrage des entsprechenden <code>mountLayoutComp</code> States erst nach dem ersten Durchlauf der Paint-Phase.</p>
<h2 id="usedebugvalue">useDebugValue</h2>
<pre><code class="hljs javascript language-javascript">useDebugValue(value);</code></pre>
<p>Der <code>useDebugValue()</code>-Hook dient allein zur Verbesserung der Debugging-Erfahrung für Entwickler und hat keinen direkten Nutzen für den <strong>Benutzer</strong> einer Anwendung. Mit ihm ist es in <strong>eigenen Hooks</strong> möglich einen Wert innerhalb des <strong>Hooks</strong> mit einem Label zu versehen wenn dieser mit den <strong>React-Devtools</strong> inspiziert wird:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React, { useDebugValue, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> usePageTitle = <span class="hljs-function">(<span class="hljs-params">title</span>) =&gt;</span> {
  useDebugValue(title);
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">document</span>.title = title;
  }, [title]);
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> usePageTitle;</code></pre>
<p>Hier implementieren wir einen eigenen kleinen <strong>Hook</strong> um den Seitentitel im Browser zu ändern. In den <strong>Devtools</strong> erscheint dieser Wert nun wie folgt:</p>
<p class="has-image"><span><img src="./assets/.gitbook/usedebugvalue.png" alt="Unser DebugValue erscheint neben dem Namen des entsprechenden Hooks" /><span class="caption">Unser DebugValue erscheint neben dem Namen des entsprechenden Hooks</span></span></p>
<h3 id="verzögerte-formatierung-des-debug-values">Verzögerte Formatierung des Debug Values</h3>
<p>Eben erwähnte ich, dass der <code>useDebugValue()</code>-Hook keinen direkten <strong>Nutzen</strong> für den Benutzer hat. Dies bedeutet allerdings nicht, dass er auch keinen direkten <strong>Einfluss</strong> auf die User Experience haben. Denn eine langsame Berechnung bei der Anzeige des Debug Values hat durchaus Einfluss auf die Rendering-Performance einer Anwendung.</p>
<p>Aus disem Grund ist es möglich dem Hook als zweiten Parameter eine Formatierungsfunktion zu übergeben. Die Formatierung des Werts wird in diesem Fall dann erst ausgeführt wenn ein Wert auch tatsächlich in den Devtools inspiziert wird. Diese hat folgende Form:</p>
<pre><code class="hljs javascript language-javascript">useDebugValue(value, (value) =&gt; formattedValue);</code></pre>
<p>Der Hook bekommt also wie bisher als erstes Argument den <strong>Debug Wert</strong> übergeben. Als zweites Argument bekommt er eine Funktion, die anschließend die Formatierung ausführt. Diese wiederum bekommt vom <strong>Hook</strong> den <strong>Wert</strong> übergeben und es wird von ihr erwartet, dass sie den formatierten Wert zurückgibt.</p>
<p>Wer das einmal an einem zugegebenermaßen sehr abwegigen aber eindeutigen Beispiel selbst erleben möchte wie sich der Unterschied bemerkbar macht, der nimmt einmal die Fibonacci-Funktion aus dem <code>useMemo()</code>-Beispiel, lässt sich diese einmal mit und einmal ohne Formatierungsfunktion als Debug Wert anzeigen und beobachtet wie sich die Zeit bis die App angezeigt wird verändert:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React, { useDebugValue, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> fibonacci = <span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span>
  num &lt;= <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : fibonacci(num - <span class="hljs-number">1</span>) + fibonacci(num - <span class="hljs-number">2</span>);

<span class="hljs-keyword">const</span> useNumber = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> {
  useDebugValue(number, (number) =&gt; fibonacci(number));
  <span class="hljs-comment">// ohne Formatierungsfunktion:</span>
  <span class="hljs-comment">// useDebugValue(fibonacci(number));</span>
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {});
  <span class="hljs-keyword">return</span> number;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  useNumber(<span class="hljs-number">41</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Debug Value Formatter Beispiel<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
}

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Hier erhöht sich die initiale Ladezeit der App deutlich, was sich natürlich auch auf den Benutzer und die User Experience auswirkt.</p>
<h2 id="useimperativehandle">useImperativeHandle</h2>
<pre><code class="hljs javascript language-javascript">useImperativeHandle(ref, createHandle, [deps]);</code></pre>
<p>Um es Vorweg zu nehmen: dieser Hook hat mir einige graue Haare bereitet, denn es fiel mir wirklich schwer einen Anwendungsfall zu konstruieren, bei dem der Einsatz von <code>useImperativeHandle()</code> die Lösung darstellt. Als ich meinem Frust auf Twitter etwas Luft machen wollte, meldete sich dann auch noch Dan Abramov, Core-Entwickler im React-Team bei Facebook und bekräftigte mich darin, dass es ein Zeichen ist dass ich alles richtig machen würde, da der Hook bestenfalls gar nicht verwendet werden sollte und daher auch absichtlich einen langen Namen hat. Allerdings möchte ich in diesem Buch den Anspruch verfolgen, React eben auch zu verstehen und nicht nur zu wissen, dass es einen solchen Hook möglicherweise gibt.</p>
<p class="has-image"><span><img src="./assets/.gitbook/useimperativehandle.png" alt="Dan Abramov weist mich auf Twitter freundlich darauf hin, alles richtig zu machen" /><span class="caption">Dan Abramov weist mich auf Twitter freundlich darauf hin, alles richtig zu machen</span></span></p>
<p>Nun habe ich mich tatsächlich lange mit diesem Hook beschäftigt und muss sagen: ja, wer den <code>useImperativeHandle()</code>-Hook nutzt, der sollte schauen ob das wirklich alles so sinnvoll ist und ob es nicht einen anderen Weg gibt, der die Verwendung genau dieses Hook nicht beinhaltet. Auch die offizielle Doku spricht an dieser Stelle davon den Hook zu verwenden, da er, wie der Name bereits erahnen lässt, für imperativen Code ausgelegt ist und damit dem in React vorherrschenden deklarativen Stil entgegensteht. Manchmal ist dies aber eben notwendig, insbesondere wenn mit Klassen und Objekten gearbeitet wird, was häufig auch bei externen Libraries der Fall ist.</p>
<p>Hier daher ein mit Vorsicht zu genießendes Beispiel, die die Verwendung des <strong>Hooks</strong> illustriert. Im Beispiel erstellen wir eine eigene <code>FancyForm</code> Formular-Komponente. Diese gibt ihre <strong>Kind-Elemente</strong> aus und stellt einige Methoden bereit, die in der konsumierenden Eltern-Komponente aufgerufen werden können. So implementieren wir hier beispielhaft eine Methode <code>focusFirstInput</code> um das erste Eingabefeld innerhalb unseres <code>FancyForm</code>-Formulars fokussieren zu können. Außerdem erweitern wir das Formular um eine eigene Methode <code>getFormValues</code>, mit der wir die aktuell eingegebenen Daten als JSON zurückgegeben bekommen. Weiterhin ermöglichen wir das Formular programmatisch abzusenden und zurückzusetzen, indem wir der weitergeleiteten <strong>ForwardRef</strong> die Methoden <code>reset()</code> und <code>submit()</code> vom HTML <code>&lt;form&gt;</code>-Element als imperative Methode zuweisen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React, { useImperativeHandle, useEffect, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> FancyForm = React.forwardRef(<span class="hljs-function">(<span class="hljs-params">props, forwardedRef</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> formRef = useRef();

  useImperativeHandle(
    forwardedRef,
    () =&gt; ({
      <span class="hljs-attr">focusFirstInput</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        (formRef.current.querySelector(<span class="hljs-string">'input'</span>) || {}).focus();
      },
      <span class="hljs-attr">getFormValues</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> FormData(formRef.current)).reduce(
          <span class="hljs-function">(<span class="hljs-params">acc, [value, name]</span>) =&gt;</span> {
            acc[name] = value;
            <span class="hljs-keyword">return</span> acc;
          },
          {}
        );
      },
      <span class="hljs-attr">reset</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> formRef.current.reset(),
      <span class="hljs-attr">submit</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> formRef.current.submit(),
    }),
    []
  );

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{formRef}</span>&gt;</span>{props.children}<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>;
});

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> formRef = useRef();

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    formRef.current.focusFirstInput();
  }, []);

  <span class="hljs-keyword">const</span> submit = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    e.preventDefault();
    <span class="hljs-built_in">console</span>.log(formRef.current.getFormValues());
  };

  <span class="hljs-keyword">return</span> (
    &lt;FancyForm ref={formRef}&gt;
      &lt;p&gt;
        &lt;input type="text" name="name" placeholder="name" /&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;input type="email" name="email" placeholder="email" /&gt;
      &lt;/p&gt;
      &lt;input type="submit" onClick={submit} /&gt;
    &lt;/FancyForm&gt;
  );
};

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</code></pre>
</div>
<div class="chapter">
  <h1 id="v-–-das-ecosystem">V – Das Ecosystem</h1>
<p>Für die einen Fluch, für die anderen Segen: die <strong>Freiheit</strong> die <strong>React</strong> dem Entwickler bietet.</p>
<p>Während vollwertige Frameworks wie Angular sehr klare Vorgaben machen wie eine Anwendung strukturiert werden soll und auch gleich eigene Methoden für Datenhaltung, Services und Business-Logik mitbringt und klare Wege vorgibt, funktioniert das in React eher nach dem Motto „bring your own“ – also bringe dein eigenes Werkzeug mit.</p>
<p>Wie bereits zu Beginn dieses Buches erwähnt, ist React erst einmal nur eine <strong>Bibliothek zur Entwicklung von User Interfaces</strong> (Kleine Anekdote am Rande: dieser Satz ist einer der wenigen die ich in diesem Buch aus der Doku zitiert habe, die sich im Laufe der Arbeit an diesem Buch nicht geändert hat ;)). In der Welt der klassischen MVC (<em>Model View Controller</em>) Architektur also sozusagen nur der View-Layer. Wer darüber hinaus ein erweitertes State-Management möchte, wer seine Anwendung mehrsprachig entwickeln möchte oder clientseitiges Routing benötigt, wird hier mit React allein oftmals nicht glücklich.</p>
<p>Doch hier hat sich ein sehr wertvolles und aktives Ecosystem um React herum entwickelt mit Tools die sich hervorragend in ein React-Setup integrieren lassen und den Entwickler vor die Wahl stellen sich aus mehreren Tools das jeweilige herauszusuchen, dass seinem persönlichen Geschmack am besten passt. Passt gar keins ist meist auch das kein Problem und React bietet mit seiner Vielzahl an Funktionen und APIs die Möglichkeit sich eine robuste, eigene Lösung zu entwickeln.</p>
<p>Da es durch die Vielzahl an Libraries sehr schnell passieren kann, dass man den Überblick verliert, möchte ich in diesem Kapitel einmal auf die gängigsten Tools und Libraries eingehen, die sich in der täglichen Arbeit mit React bewährt haben und oftmals tausende von Stars auf Github haben und zehntausendfach oder (deutlich) mehr über <code>npm</code> installiert werden.</p>
</div>
<div class="chapter">
  <h1 id="routing">Routing</h1>
<p>Eine Funktionalität die in nahezu allen <strong>Single Page Applikationen</strong> (SPA) früher oder später (meist früher als später) benötigt wird ist das <strong>Routing</strong>. Also das Zuordnen einer URL in der Anwendung zu einer bestimmten Funktion. Rufe ich bspw. die URL <code>/users/manuel</code> auf, möchte ich dort sehr wahrscheinlich das Benutzerprofil des Users <code>manuel</code> anzeigen.</p>
<p>Hier hat sich der <strong>React Router</strong> in den vergangenen Jahren als de facto Standard etabliert. Entwickelt von Michael Jackson (ja, der Kerl heißt wirklich so!) und Ryan Florence (der laut eigener Aussage inzwischen über 10 verschiedene Router für diverse Zwecke entwickelt hat) bringt er es auf mittlerweile über 35.000 Stars bei GitHub. Er wird regelmäßig gepflegt, hat eine Community bestehend aus über 500 Contributors auf GitHub und passt sich durch seine deklarative Natur wunderbar die React-Prinzipien an. Darüber hinaus ist er kompatibel sowohl mit dem Web (client- und serverseitig!) wie auch React Native. Er ist also sehr universell einsetzbar, sehr gut getestet und durch seine weite Verbreitung auch bewährt.</p>
<p>Dabei ist sein Interface selbst ziemlich simpel. In ca. 95% der Zeit wird man mit lediglich fünf Komponenten in Berührung kommen: <code>BrowserRouter</code>, <code>Link</code>, <code>Route</code>, <code>Redirect</code> und <code>Switch</code>. Darüber hinaus gibt es noch die imperative History API die auf dem gleichnamigen <code>history</code> Package basiert und die HOC <code>withRouter</code> um für das Routing relevante Daten aus dem Router in eine Komponente herein zu reichen.</p>
<p>Installiert wird er via:</p>
<pre><code class="hljs bash language-bash">npm install --save react-router-dom</code></pre>
<p>bzw.</p>
<pre><code class="hljs bash language-bash">yarn add react-router-dom</code></pre>
<p>Die generelle Benutzung ist dabei wie bereits angesprochen <em>deklarativ</em>, also erfolgt in Form der oben erwähnten Komponenten. Router können dadurch innerhalb einer Anwendung an jeder beliebigen Stelle verwendet werden. Voraussetzung ist lediglich, dass der jeweilige Seitenbaum sich in einem <strong>Router Context</strong> befindet. Dieser existiert in einer typischen Anwendung nur ein einziges Mal und legt sich meist ganz außen um die Anwendung. Etwa in der folgenden Form:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> { BrowserRouter <span class="hljs-keyword">as</span> Router } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span>[...]<span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span>;
};

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<h3 id="routen-definieren">Routen definieren</h3>
<p>Jede Komponente innerhalb des <code>&lt;Router&gt;&lt;/Router&gt;</code>-Elements kann nun auf den <strong>Router Context</strong> zugreifen, darauf reagieren und ihn steuern. Verschiedene Routen legen wir durch die Verwendung der Route-Komponente an, die eine <code>path</code>-Prop enthalten sollte (Ausnahme: 404 Fehler-Routen) und wahlweise eine <code>render</code>-Prop oder eine <code>component</code>-Prop enthält. Der Unterschied liegt hier darin, dass der Wert der <code>render</code>-Prop eine <strong>Funktion</strong> sein muss die ein valides <strong>React-Element</strong> zurückgibt (hier sei auch nochmal an das entsprechende Kapitel zu <strong>Render-Props</strong> erinnert), während die <code>component</code>-Prop eine <strong>Komponente</strong> (kein <em>Element!</em>) erwartet.</p>
<p>Also sieht eine korrekte Verwendung beider Props z.B. so aus:</p>
<pre><code class="hljs jsx language-jsx">import React from 'react';
import ReactDOM from 'react-dom';
import { BrowserRouter as Router } from 'react-router-dom';

const Example = () =&gt; &lt;p&gt;Example Komponente&lt;/p&gt;;

const App = () =&gt; {
  return (
    &lt;Router&gt;
      &lt;Route path="/example" component={Example} /&gt;
      &lt;Route path="/example" render={() =&gt; &lt;Example /&gt;} /&gt;
    &lt;/Router&gt;
  );
};

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</code></pre>
<p>In diesem Beispiel würde die <code>Example</code>-Komponente beim Aufruf der <code>/example</code> URL zweimal gerendert werden, da die Route-Komponente lediglich überprüft ob der Pfad der aktuellen URL mit dem in der <code>path</code>-Prop angegebenen Wert übereinstimmt. Dies mag erst einmal verwunderlich klingen, lässt sich aber ganz logisch erklären.</p>
<p>Da React Router eben deklarativ ist, sagen wir React mit der Angabe zweier gleicher Routen eben erst einmal, dass wir auch zwei Komponenten rendern wollen wenn die URL übereinstimmt. Dies kann dann sinnvoll sein, wenn sich verschiedene Teile einer Seite unabhängig voneinander und basierend auf der URL ändern sollen. Angenommen wir haben eine App mit einer Sidebar und einem Content-Bereich. Beide sollen nun auf eine URL reagieren:</p>
<pre><code class="hljs jsx language-jsx">import React from "react";
import ReactDOM from "react-dom";
import { BrowserRouter as Router, Route } from 'react-router-dom';

const Home = () =&gt; &lt;p&gt;Home Content&lt;/p&gt;;
const Account = () =&gt; &lt;p&gt;AccountContent&lt;/p&gt;;
import HomeSidebar = () =&gt; &lt;p&gt;Home Sidebar&lt;/p&gt;
import AccountSidebar = () =&gt; &lt;p&gt;AccountSidebar&lt;/p&gt;

const App = () =&gt; {
  return (
    &lt;Router&gt;
      &lt;main&gt;
        &lt;Route path="/account" component={Account} /&gt;
        &lt;Route path="/" component={Home} /&gt;
      &lt;/main&gt;
      &lt;aside&gt;
        &lt;Route path="/account" component={AccountSidebar} /&gt;
        &lt;Route path="/" component={HomeSidebar} /&gt;
      &lt;/aside&gt;
    &lt;/Router&gt;
  );
}

ReactDOM.render(&lt;App /&gt;, document.getElementById("root"));</code></pre>
<p>In diesem Beispiel sehen wir wie an zwei verschiedenen Stellen in unserer Anwendung unterschiedliche Komponenten gerendert werden, je nachdem welche URL momentan aufgerufen wird.</p>
<p>Hier sind wir in der Struktur der Komponenten jedoch ziemlich frei. Und so ist nicht unüblich, dass eine solche Doppelung von Routen durch eine etwas andere Struktur vermieden wird. Das obige Beispiel würde bspw. dann so geschrieben werden:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> { BrowserRouter <span class="hljs-keyword">as</span> Router, Route } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;

<span class="hljs-keyword">const</span> Home = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  &lt;&gt;
    &lt;main&gt;Home Content&lt;/main&gt;
    &lt;aside&gt;Home Sidebar&lt;/aside&gt;
  &lt;/&gt;
);

const Account = () =&gt; (
  &lt;&gt;
    &lt;main&gt;Account Content&lt;/main&gt;
    &lt;aside&gt;Account Sidebar&lt;/aside&gt;
  &lt;/&gt;
);

const App = () =&gt; {
  return (
    &lt;Router&gt;
      &lt;Route path="/account" component={Account} /&gt;
      &lt;Route path="/" component={Home} /&gt;
    &lt;/Router&gt;
  );
};

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</code></pre>
<p>Hier haben wir nun das doppelte Routing vermieden, allerdings zu Ungunsten der Layout-Struktur, die nun dupliziert wurde. In einer typischen Anwendung könnten wir nun hergehen und die Struktur in eine eigene Layout-Komponente abstrahieren:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> Layout = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> (
  &lt;&gt;
    &lt;main&gt;{props.content}&lt;/main&gt;
    &lt;aside&gt;{props.sidebar}&lt;/aside&gt;
  &lt;/&gt;
);

const Home = () =&gt; &lt;Layout content="Home Content" sidebar="Home Sidebar" /&gt;;
const Account = () =&gt; (
  &lt;Layout content="Account Content" sidebar="Account Sidebar" /&gt;
);

const App = () =&gt; {
  return (
    &lt;Router&gt;
      &lt;Route path="/account" component={Account} /&gt;
      &lt;Route path="/" component={Home} /&gt;
    &lt;/Router&gt;
  );
};

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</code></pre>
<p>Wer die Code-Beispiele jetzt ausprobiert wird hierbei ein Verhalten feststellen, das in den meisten Fällen ungewollt ist: <strong>React Router</strong> geht sehr locker und lässig mit den Pfaden beim Path-Matching um. Und so sehen wir beim Aufruf der <code>/account</code> URL nicht nur die <code>Account</code>-Komponente sondern ebenfalls die <code>Home</code>-Komponente. Dies passiert, weil <code>/account</code> <strong>auch</strong> den Pfad <code>/</code> <strong>beinhaltet</strong>, und somit werden beide Komponenten gerendert. Das ist durchaus so gewollt, wo wäre es z.B. möglich einzelne Seitenbereiche unter einem bestimmten URL Präfix zu gliedern und dabei eine Komponente auf jeder dieser Routen rendern zu lassen.</p>
<p>Denken wir an einen Benutzer-Account und stellen uns eine Sidebar vor. Vielleicht entwickeln wir gerade eine Community. Dort gibt es einen Benutzerbereich in verschiedene Unterkategorien unterteilt ist: <code>/account/edit</code>, um das eigene Profil zu bearbeiten, <code>/account/images</code>, um die eigenen Bilder anzusehen oder <code>/account/settings</code>, um Änderungen an den eigenen Einstellungen vorzunehmen. Wir können nun eine generische Route in unserer Anwendung einfügen:</p>
<pre><code class="hljs jsx language-jsx">&lt;Route path=<span class="hljs-string">"/account"</span> component={AccountSidebar} /&gt;</code></pre>
<p>Die <code>AccountSidebar</code>-Komponente würde nun auf jeder Unterseite innerhalb des Account-Bereichs angezeigt, solange eben die URL mit <code>/account</code> beginnt.</p>
<h3 id="matching-einschränken-via-prop">Matching einschränken via Prop</h3>
<p>Um das Matching zwischen dem <code>path</code> und der URL bewusst einzuschränken bietet uns React Router die <code>exact</code> Prop auf der <code>Route</code>-Komponente. Wird diese Boolean-Prop angegeben, wird eine Route nur noch dann gerendert wenn ihre <code>path</code>-Prop auch exakt mit der aktuellen URL übereinstimmt:</p>
<pre><code class="hljs jsx language-jsx">&lt;Route exact path=<span class="hljs-string">"/"</span> component={Home} /&gt;</code></pre>
<p>Die Reihenfolge wo genau die Prop angegeben wird ist dabei, wie immer in <strong>JSX</strong>, zu vernachlässigen, ich schreibe sie gern direkt vor die <code>path</code>-Prop um den Eindruck einer „sprechenden“ Prop zu vermitteln: hier habe ich eine <strong>Route</strong> mit dem <strong>exact path</strong>. In unserem Beispiel mit der Account-Sidebar würde die Sidebar bei Verwendung der <code>exact</code>-Prop nun nur noch dann gerendert wenn die URL <code>/account</code> entspricht, jedoch nicht mehr bei <code>/account/edit</code>, <code>/account/images</code> oder <code>/account/settings</code>.</p>
<h3 id="matching-auf-eine-route-limitieren-via-switch-komponente">Matching auf eine Route limitieren via Switch-Komponente</h3>
<p>Die <code>exact</code>-Prop bezieht sich dabei immer nur auf eine <strong>einzelne Route</strong> und lässt andere Routen davon gänzlich unberührt. Haben wir eine Reihe von URLs von denen in bestimmten Fällen mehrere Routen matchen können, wird das mitunter mühsam jeder einzelnen dieser Routen eine weitere Prop hinzuzufügen. Hier hilft uns der nächste Import aus dem <strong>React Router</strong> Paket weiter: <code>Switch</code>.</p>
<p>Mit der <code>Switch</code>-Komponente, die sich um eine Reihe von <code>&lt;Route /&gt;</code>-Elementen legt, sorgen wir dafür, dass jeweils immer nur die <strong>erste</strong> Route deren <code>path</code> mit der aktuellen URL übereinstimmt gerendert wird. Oft ist es keine schlechte Idee Routen grundsätzlich in einem <code>Switch</code>-Element zu verpacken, außer man möchte eben explizit, dass mehrere Routen gerendert werden. Statt der Verwendung der <code>exact</code>-Prop wie im obigen Beispiel, wäre auch die Verwendung der <code>Switch</code>-Komponente möglich:</p>
<pre><code class="hljs jsx language-jsx">&lt;Router&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/account"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Account}</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Home}</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span></code></pre>
<p>Beim Aufruf der <code>/account</code> URL würde nun gleich die erste Route zutreffen und alle folgenden Routen würden ignoriert, wir würden also nur die <code>Account</code>-Komponente rendern. Dabei prüft die <code>Switch</code>-Komponente auch stets nur ihre <strong>direkten</strong> Kind-Elemente auf ein Matching mit der URL. Enthält die <code>Account</code>-Komponente wiederum eigene Routen, was problemlos möglich ist, sind diese von der Switch-Komponente unbeeindruckt und werden gerendert wenn ihr <code>path</code> mit der aktuellen URL übereinstimmt.</p>
<p>Dies ermöglicht uns darüber hinaus die Erstellung einer 404 Fehlerseite als Fallback-Route. Lassen wir die <code>path</code>-Prop aus, bedeutet dies, dass diese Route auf <strong>jede</strong> URL zutrifft. Nutzen wir sie also innerhalb eines <code>Switch</code>-Elements als letzte Komponente sagen wir dem <strong>React Router</strong> damit: <em>rendere diese Komponente immer dann wenn keine andere Route zutrifft, und zwar nur dann!</em> Und das sieht dann so aus:</p>
<pre><code class="hljs jsx language-jsx">const Error404 = () =&gt; &lt;h1&gt;404 – Seite nicht gefunden&lt;/h1&gt;;

const App = () =&gt; (
  &lt;Router&gt;
    &lt;Switch&gt;
      &lt;Route path="/account" component={Account} /&gt;
      &lt;Route path="/contacts" component={Contacts} /&gt;
      &lt;Route path="/inbox" component={Inbox} /&gt;
      &lt;Route exact path="/" component={Home} /&gt;
      &lt;Route component={Error404} /&gt;
    &lt;/Switch&gt;
  &lt;/Router&gt;
);</code></pre>
<p>In diesem Fall ist zusätzlich zum <code>Switch</code>-Element auch noch eine <code>exact</code>-Prop bei der <code>/</code> Route notwendig, da sonst diese immer zutreffen würde wenn vorher keine andere der Routen auf die aktuelle URL zutrifft, da der Router eben so funktioniert, dass bspw. auch <code>/existiert-nicht</code> unter der <code>/</code>-Route gefunden werden würde. Mit der <code>exact</code>-Prop auf der <code>Home</code>-Route passiert eben genau dies nicht und stattdessen sehen wir unsere <code>Error404</code>-Komponente die am Ende unseres <code>Switch</code>-Blocks alle Aufrufe abfängt. Vergleichbar mit dem <code>default</code>-Fall in einem <code>switch</code>-Statement in JavaScript.</p>
<h3 id="parameter-in-urls">Parameter in URLs</h3>
<p>Kaum eine Anwendung kommt ohne URLs aus, die Parameter enthält. Auch dieser Fall wird natürlich vom React Router abgedeckt und in einer Form die jedem der schon einmal mit anderen Routing-Mechanismen gearbeitet hat durchaus vertraut vorkommen dürfte, nämlich durch die Verwendung eines Parameter-Namens mit vorangestellten Doppelpunkt (<code>:</code>).</p>
<pre><code class="hljs jsx language-jsx">&lt;Route path=<span class="hljs-string">"/users/:userid"</span> component={UserProfile} /&gt;</code></pre>
<p>Dabei kann hier eingeschränkt werden was genau der Parameter als solchen erkennen soll. Möchte ich bspw. auf einer Route die Sortierung auf <em>aufsteigend</em> (asc) oder <em>absteigend</em> (desc) beschränken, kann ich dies durch einen regulären Ausdruck in Klammern, die ich unmittelbar an den Parameter anhänge:</p>
<pre><code class="hljs jsx language-jsx">&lt;Route path=<span class="hljs-string">"/products/:order(asc|dec)"</span></code></pre>
<p>Die obige Route würde dann nur zutreffen wenn die URL <code>/products/asc</code> oder <code>/products/desc</code> lautet.</p>
<p>Möchte ich im ersten Beispiel, dass nur numerische Werte als <code>:userid</code> erlaubt sind, so kann ich dafür die Route definieren: <code>/users/:userid(\d*)</code> oder <code>/users/:userid([0-9]*)</code> und somit würde die URL <code>/users/123</code> die <code>UserProfile</code>-Komponente rendern, <code>/users/abc</code> hingegen nicht.</p>
<p>Findet der <strong>React Router</strong> eine solche URL mit einem Parameter, extrahiert er dessen Wert und übergibt ihn in einer <code>match</code>-Prop an die gerenderte Komponente.</p>
<h3 id="weiterleitung-bestimmter-routen-steuern">Weiterleitung bestimmter Routen steuern</h3>
<p>Neben der <code>Route</code>-Komponente, um auf bestimmte Routen zu reagieren, bietet React Router auch noch eine <code>Redirect</code>-Komponente. Diese enthält eine <code>to</code>-Prop mit der ein Ziel angegeben werden kann und sie ist dazu gedacht um deklarativ (d.h. im <strong>JSX</strong>) entscheiden zu können, wohin ein Benutzer in bestimmten Situationen umgeleitet wird. Wann immer eine <code>Redirect</code>-Komponente mit lediglich einer <code>to</code>-Prop gerendert wird, wird eine entsprechende Weiterleitung auf die in der <code>to</code>-Prop angegebene URL ausgeführt.</p>
<p>Ein gängiger Anwendungsfall für eine <code>Redirect</code>-Komponente ist bspw. die Umleitung auf einen Login-Seite für eingeloggte Benutzer, wenn dieser noch nicht eingeloggt ist:</p>
<pre><code class="hljs jsx language-jsx">&lt;Route
  exact
  path=<span class="hljs-string">"/"</span>
  render={() =&gt; {
    <span class="hljs-keyword">return</span> isLoggedIn ? &lt;Dashboard /&gt; : &lt;Redirect to="/login" /&gt;;
  }}
/&gt;</code></pre>
<p>Hier nutzen wir die <code>render</code>-Prop der <code>Route</code>-Komponente, um in einer Funktion abzufragen ob ein Benutzer eingeloggt ist (mittels <code>isLoggedIn</code>) und zeigen auf der <code>/</code> URL entweder eine Dashboard-Komponente oder rendern eben einen Redirect zu <code>/login</code>, der den Benutzer dann eben auf eine Login-Seite weiterleiten würde.</p>
<p>Eine zweite Variante Weiterleitungen zu definieren bietet sich uns durch die Verwendung der <code>Redirect</code>-Komponente innerhalb eines <code>&lt;Switch/&gt;</code>-Elements. Hier verhält sie sich so wie die <code>Route</code>-Komponente und greift nur dann wenn nicht bereits eine andere Route oder ein anderer Redirect mit der aktuellen URL übereingestimmt hat.</p>
<p>Wird die <code>Redirect</code>-Komponente in einem <code>&lt;Switch/&gt;</code>-Element benutzt (und nur dann!) kann sie auch eine <code>from</code>-Prop bekommen. Diese entspricht der <code>path</code>-Prop bei der <code>Route</code>-Komponente, sorgt also dafür, dass der Redirect nur durchgeführt wird wenn die aktuelle URL dem Wert der <code>from</code>-Prop entspricht:</p>
<pre><code class="hljs jsx language-jsx">&lt;Switch&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"/old"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/new"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/new"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{NewComponent}</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span></span></code></pre>
<p>Die <code>Redirect</code>-Komponente verhält sich dabei was das Matching der URLs angeht genau wie die <code>Route</code>-Komponente. Sie unterstützt ebenfalls die <code>exact</code> Prop um ein exaktes Matching zu erzwingen und sie unterstützt auch die Umleitung an andere Routen mit Parameter:</p>
<pre><code class="hljs jsx language-jsx">&lt;Switch&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"/users/:userid"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/users/profile/:userid"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/users/profile/:userid"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{UserProfile}</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span></span></code></pre>
<p>Beim Aufruf der URL <code>/old</code> (erstes Beispiel) bzw. <code>/users/123</code> (zweites Beispiel) wird der Benutzer dann auf die als <code>to</code>-Prop angegebene URL umgeleitet.</p>
<h3 id="verwendung-der-router-props">Verwendung der Router Props</h3>
<p>Jede Komponente die vom React Router gerendert wird weil sie als <code>component</code>-Prop einer <code>Route</code>-Komponente angegeben wurde bekommt automatisch drei für das Routing relevante Props übergeben:</p>
<ul>
<li><code>match</code></li>
<li><code>location</code></li>
<li><code>history</code></li>
</ul>
<p>Auf diese kann innerhalb der jeweiligen Komponente wie auf jede andere Prop auch über <code>this.props</code> in <strong>Klassen-Komponenten</strong> oder <code>props</code> in <strong>Function Components</strong> zugegriffen werden:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> { BrowserRouter <span class="hljs-keyword">as</span> Router, Route } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;

<span class="hljs-keyword">const</span> Example = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(props);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Example<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
};

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/users/:userid"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Example}</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span>
);

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Schauen wir uns die Konsolen-Ausgabe dieser Komponente an, sehen wir beim Aufruf der URL <code>/users/123</code> ein Resultat das diesem entspricht (gekürzt):</p>
<pre><code class="hljs javascript language-javascript">{
  <span class="hljs-attr">history</span>: { <span class="hljs-comment">/* ... */</span> },
  <span class="hljs-attr">location</span>: { <span class="hljs-comment">/* ... */</span> },
  <span class="hljs-attr">match</span>: {
    <span class="hljs-attr">path</span>: <span class="hljs-string">"/:userid"</span>,
    <span class="hljs-attr">url</span>: <span class="hljs-string">"/users/123"</span>,
    <span class="hljs-attr">isExact</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">params</span>: {
      <span class="hljs-attr">userid</span>: <span class="hljs-string">"123"</span>
    }
  }
}</code></pre>
<p>Ohne bereits jetzt im Detail auf jede einzelne Eigenschaft einzugehen, bekommen wir hier einen Eindruck auf welche Eigenschaften des Routers wir hier zugreifen können. Für den Moment interessiert uns erst einmal die <code>match</code>-Eigenschaft. Diese enthält bei einer zutreffenden URL in <code>match.params</code> die Parameter, die wir im <code>path</code> definiert haben mitsamt ihrer Werte. In diesem Fall also <code>match.params.userid</code> mit dem Wert <code>123</code>.</p>
<p>In einer Benutzerprofil-Komponente könnten wir nun etwa hergehen und einen API-Request starten um uns alle relevanten Daten für den Benutzer mit der BenutzerID <code>123</code> zu besorgen und die Profilansicht dieses Benutzers darzustellen.</p>
<p><strong>React Router</strong> stellt dabei sicher dass in jeder mit dem Router verbundenen Komponente die <code>match</code> Eigenschaft immer existiert und diese auch immer eine <code>params</code>-Eigenschaft hat, die entweder die Parameter enthält (falls vorhanden) oder aber ein leeres Objekt ist. Es ist daher <strong>sicher</strong> auf <code>props.match.params</code> zuzugreifen, ohne befürchten zu müssen, dass eine dieser Eigenschaften <code>undefined</code> ist und somit einen Fehler wirft.</p>
<p>Auch die <code>render</code>-Prop auf der <code>Route</code>-Komponente erhält alle Props des Routers übergeben:</p>
<pre><code class="hljs jsx language-jsx">&lt;Route
  path=<span class="hljs-string">"/users/:userid"</span>
  render={(props) =&gt; {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Benutzerprofil für die ID {props.match.params.userid}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
  }}
/&gt;</code></pre>
<h3 id="navigation-zwischen-einzelnen-routen">Navigation zwischen einzelnen Routen</h3>
<p>Haben wir erst einmal eine Anwendung in mehrere Routen unterteilt, wollen wir natürlich auch zwischen diesen URLs verlinken. Dies ginge natürlich mit dem HTML <code>&lt;a href="..."&gt;...&lt;/a&gt;</code> Element. Keine Frage. Allerdings lösen wir damit einen komplett neuen „harten“ Seitenaufruf im Browser aus, verlassen die aktuelle Seite <strong>komplett</strong> und rufen die neue Seite komplett neu auf.</p>
<p>Das heißt wir fordern ein HTML-Dokument an, das HTML-Dokument lädt CSS und das JavaScript mit unserer React-Anwendung erneut vom Server (oder holt es idealerweise aus dem Browser-Cache), initialisiert alles neu und entscheidet auf Basis der geänderten URL welche Route gerendert werden soll. Etwaiger State den wir zuvor global gesetzt haben würde dadurch zurückgesetzt.</p>
<p>Das ist aber eben nicht das Verhalten das wir uns in einer Single Page Applikation wünschen. Hier möchten wir schließlich das HTML mitsamt seinem CSS und JavaScript nur einmal vom Server laden. Wir möchten den globalen State beim Navigieren zwischen den einzelnen Routen persistieren und nur die Teile der Seite neu rendern, die sich auch basierend auf der Route ändern sollen.</p>
<p>Hierzu bringt uns <strong>React Router</strong> die <code>Link</code>-Komponente mit. Diese wird wie alle anderen Komponenten aus dem <code>react-router-dom</code>-Paket importiert und besitzt eine <code>to</code>-Prop die man grob mit dem <code>href</code>-Attribut bei HTML <code>a</code>-Elementen vergleichen kann:</p>
<pre><code class="hljs jsx language-jsx">&lt;Link to=<span class="hljs-string">"/account"</span>&gt;Account&lt;<span class="hljs-regexp">/Link&gt;</span></code></pre>
<p>Intern nutzt <strong>React Router</strong> für die Darstellung dieser Links ebenfalls ein ganz gewöhnliches <code>&lt;a href /&gt;</code>, jedoch werden Klicks auf diese Links abgefangen und an eine Router-interne Funktion weitergeleitet, die sich dann darum kümmert neue Seiteninhalte auf Basis der neuen URL darzustellen, ohne dabei einen vollständigen Pageload auszulösen.</p>
<p>Neben der <code>to</code>-Prop kann ein <code>Link</code> auch eine <code>innerRef</code> besitzen die eine über <code>createRef()</code> oder <code>useRef()</code> erzeugte Ref erhalten kann, sowie eine <code>replace</code>-Prop mit der wir festlegen können, dass wir die aktuelle URL in der Browser-History <em>ersetzen</em> wollen statt einen neuen History-Eintrag zu erzeuge. Beim Klick auf den Zurück-Button im Browser kann dann nicht mehr auf die vorherige Route zurückgesprungen werden.</p>
<p>Alle weiteren Props die dem <code>&lt;Link /&gt;</code>-Element übergeben werden werden an das erzeugte <code>a</code>-Element weitergereicht. So würde <code>&lt;Link to="/" title="Homepage"&gt;Home&lt;/Link&gt;</code> in der Ausgabe entsprechend das folgende Markup erzeugen: <code>&lt;a href="/" title="Homepage"&gt;Home&lt;/a&gt;</code>.</p>
<h3 id="sonderausprägung-navlink">Sonderausprägung: NavLink</h3>
<p>Eine besondere Ausprägung des <code>Link</code>-Elements stellt der <code>NavLink</code> dar. Neben den Props die auch die <code>Link</code>-Komponente erhalten kann, kennt der <code>NavLink</code> darüber hinaus seinen aktuellen Zustand in dem Sinne, dass er weiß ob er gerade auf die aktuelle Seite verlinkt. Ist dies der Fall können ihm mittels <code>activeClassName</code> und <code>activeStyle</code> ein alternatives Erscheinungsbild verpasst werden.</p>
<p>Ein klassisches Beispiel ist hier eine Seitennavigation, bei der der jeweils aktuelle Menüpunkt farblich hervorgehoben wird.</p>
<pre><code class="hljs jsx language-jsx">&lt;NavLink to="/" activeClassName="active"&gt;Home&lt;/NavLink&gt;
&lt;NavLink to="/account" activeClassName="active"&gt;Account&lt;/NavLink&gt;
&lt;NavLink to="/contacts" activeClassName="active"&gt;Kontakte&lt;/NavLink&gt;</code></pre>
<p>Hier würde der Link der jeweils aktuellen Seite, und nur dieser, die Klasse <code>active</code> erhalten. Befinden wir uns bspw. auf der <code>/account</code> URL, wäre das Markup dementsprechend:</p>
<pre><code class="hljs markup language-markup">&lt;a <span class="hljs-attribute">href</span>=<span class="hljs-string">"/"</span>&gt;Home&lt;/a&gt;
&lt;a <span class="hljs-attribute">href</span>=<span class="hljs-string">"/account"</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">"active"</span>&gt;Account&lt;/a&gt;
&lt;a <span class="hljs-attribute">href</span>=<span class="hljs-string">"/contacts"</span>&gt;Kontakte&lt;/a&gt;</code></pre>
<p>Weitere <strong>Props</strong> die ein <code>NavLink</code>-Element enthalten kann sind <code>exact</code> und <code>strict</code>, analog zu den entsprechenden <strong>Props</strong> bei der <code>Route</code>-Komponente, sowie <code>isActive</code>. Letztere erwartet eine Funktion, die entweder <code>true</code> (aktive Seite entspricht dem <code>NavLink</code>) oder <code>false</code> (aktive Seite entspricht ihm nicht) zurückgibt. Die Funktion selbst bekommt vom Router als erstes Argument das <code>match</code> Objekt und als zweites Argument das <code>location</code> Objekt übergeben. Die Funktion kann anhand dieser Information nun ermitteln ob sie den jeweiligen <code>NavLink</code> als aktiv markiert oder nicht.</p>
<h3 id="programmatisch-navigieren-mit-der-history-api">Programmatisch Navigieren mit der History API</h3>
<p>Nun wissen wir, wie wir durch <code>Route</code>-Elemente auf verschiedene URLs mit dem Rendering entsprechender Komponenten reagieren können und wir wissen, wie wir einen harten Pageload durch die Verwendung des <code>&lt;Link /&gt;</code>-Elements verzichten. Doch in manchen Fällen ist es notwendig einen Wechsel der URL programmatisch zu forcieren. Etwa um den Benutzer auf eine andere Seite weiter zu leiten nachdem ein asynchroner Request erfolgreich war.</p>
<p>Zu diesem Zweck dient die <code>history</code> Eigenschaft, die der Router allen als Route verwendeten Komponenten in den <code>Props</code> übergibt:</p>
<pre><code class="hljs javascript language-javascript">{
  <span class="hljs-attr">history</span>: {
    <span class="hljs-attr">action</span>: <span class="hljs-string">"POP"</span>
    block: <span class="hljs-built_in">Function</span>(prompt),
    <span class="hljs-attr">go</span>: <span class="hljs-built_in">Function</span>(number),
    <span class="hljs-attr">goBack</span>: <span class="hljs-built_in">Function</span>(),
    <span class="hljs-attr">goForward</span>: <span class="hljs-built_in">Function</span>(),
    <span class="hljs-attr">length</span>: <span class="hljs-number">1</span>
    push: <span class="hljs-built_in">Function</span>(path, state)
    replace: <span class="hljs-built_in">Function</span>(path, state)
  },
  <span class="hljs-attr">location</span>: { <span class="hljs-comment">/* ... */</span> },
  <span class="hljs-attr">match</span>: { <span class="hljs-comment">/* ... */</span> }
}</code></pre>
<p>In unserem besonderen Interesse liegen hier die beiden Funktionen <code>push()</code> sowie <code>replace()</code>. Mittels <code>props.history.push('/ziel')</code> können wir die URL im Browser auf <code>/ziel</code> ändern, sowie ein Rerendering auslösen. Dabei wird wie auch bei der Verwendung der <code>Link</code>-Komponente ein neuer Eintrag in der Browser-History erzeugt. Möchten wir hingegen keinen neuen Eintrag in der Browser-History erzeugen, können wir stattdessen die <code>props.history.replace('/ziel')</code> Funktion verwenden.</p>
<p>Die Funktion <code>props.history.go()</code> ermöglicht es uns in der Browser-History programmatisch vor- und zurück zu blättern. Die Funktion erwartet dabei einen Integer als Parameter der angibt um wie viele Schritte in der History geblättert werden soll. Negative Werte blättern dabei zurück, während positive Werte vorwärts blättern. Die beiden Funktionen <code>goBack()</code> und <code>goForward()</code> sind dabei Shortcuts, die jeweils einen Schritt in der History zurück- bzw. vorblättern. Sie entsprechen also <code>go(-1)</code> bzw. <code>go(1)</code>.</p>
<p>Die <code>action</code> Eigenschaft verrät uns durch welche Aktion ein Benutzer auf der aktuellen Route gelandet ist. Sie ist entweder <code>POP</code>, <code>PUSH</code> oder <code>REPLACE</code>, wobei <code>POP</code> sowohl bedeuten kann, dass es sich um den initialen Seitenaufruf handelt oder der Benutzer den Zurück-Button im Browser gedrückt hat, <code>PUSH</code> bedeutet, dass die <code>history.push()</code> Funktion aufgerufen wurde, was auch beim Klick auf einen <code>&lt;Link /&gt;</code> der Fall ist. Ist der Wert der <code>action</code>-Eigenschaft <code>REPLACE</code> - ihr könnt es euch denken - wurde <code>history.replace()</code> aufgerufen oder ein <code>&lt;Link /&gt;</code>-Element geklickt, dass eine <code>replace</code>-Prop besitzt.</p>
<h3 id="komponenten-mit-dem-router-über-die-hoc-verbinden">Komponenten mit dem Router über die HOC verbinden</h3>
<p>Jede Komponente die als <code>component</code>-Prop innerhalb eines <code>&lt;Router /&gt;</code>-Elements verwendet wird, bekommt die Router Props (<code>history</code>, <code>location</code>, <code>match</code>) automatisch vom übergeben. Doch manchmal möchten wir auch in Komponenten die nicht als direkte Route verwendet werden auf Router-Funktionalität zugreifen. Etwa, weil wir auf eine andere Seite weiterleiten möchten und dafür <code>history.push()</code> verwenden möchten.</p>
<p>Zu diesem Zweck stellt <strong>React Router</strong> die <code>withRouter</code> Higher Order Component bereit. Komponenten die nicht direkt als Router-Komponente eingesetzt werden bekommen dann ebenfalls die drei Props des Routers übergeben:</p>
<pre><code class="hljs jsx language-jsx">withRouter(MyComponent);</code></pre>
<p>Doch die Komponente erfüllt noch einen anderen Zweck, der allerdings eher Workaround-Charakter hat und ab <strong>React Router 5.0.0</strong> behoben ist: sie hebt das sogenannte <strong>„Update-Blocking“</strong> auf.</p>
<p>In einigen Fällen kann es vorkommen, dass Komponenten zur Optimierung der Performance als <code>PureComponent</code> implementiert oder von einem <code>React.memo()</code> optimiert werden und dementsprechend ein Rerendering unterbinden wenn sich weder die eigenen <strong>Props</strong> noch der <strong>State</strong> der jeweiligen Komponente ändern. Da die meisten Router-Komponenten wie bspw. <code>NavLink</code> auf die Daten des Routers durch den <strong>React Context</strong> zugreifen würde eine solche Komponente dann unter Umständen keine Kenntnis darüber erlangen, dass ein Kind-Element neu gerendert werden muss.</p>
<p>Die Lösung für dieses Problem ist dann, die entsprechende Komponente in eine <code>withRouter()</code> HOC zu verpacken, die dann bei jeder Änderung im Routing die neuen Props mit der neuen Location an die jeweilige Komponente übergibt und in dieser somit ein Rerendering verursacht. Dies ist bspw. der Fall bei der Verwendung mit der State Management Library <strong>Redux</strong>. Wird eine Komponente über die <code>connect()</code> Funktion in Redux mit dem Redux-Store verbunden, unterbindet diese Komponente das Rerendering von Router spezifischen Teilen, außer es ändert sich gleichzeitig etwas im Store.</p>
<p>In diesem Fall hilft es dann entsprechend die Komponente mit einem <code>withRouter()</code> Aufruf zu wrappen:</p>
<pre><code class="hljs javascript language-javascript">withRouter(connect()(MyComponent));</code></pre>
<p>Dies wurde mit der Verwendung der neuen <strong>Context API</strong> aus <strong>React 16.3.0</strong> im <strong>React Router</strong> ab Version <strong>5.0.0</strong> behoben und ist daher in erster Linie für Projekte relevant, in denen noch ältere Versionen zum Einsatz kommen.</p>
</div>
<div class="chapter">
  <h1 id="state-management">State Management</h1>
<p>Mit zunehmender Größe einer Anwendung wächst meist auch deren Komplexität und die Daten, die mit der Anwendung verwaltet werden sollen. Also anders gesagt: der <strong>Application State</strong> wird schwieriger und unübersichtlicher zu verwalten. Wann gebe ich wie, welcher Komponente welche Props hinein. Wie wirken sich diese Props auf den State meiner Komponente aus und was passiert wenn ich den State in einer Komponente modifiziere.</p>
<p>Auch wenn React hier in den letzten Jahren zunehmend deutlich besser geworden ist, gerade mit der neuen <strong>Context API</strong> und dem <strong>useReducer-Hook</strong> einiges zur besseren Übersichtlichkeit von komplexen Datenstrukturen getan hat ist es noch immer nicht ganz einfach immer alle Daten und Datentransformationen im Blick zu haben. Um dieses Problem zu lösen gibt es einige externe Tools für <strong>globales State Management</strong>, die sich im Ecosystem um React herum gebildet haben.</p>
<p>Zu den bekannteren Tools dieser Art wäre hier einerseits <strong>MobX</strong>, das sich selbst als <em>„Simple, scalable state management“</em> beschreibt, also als Werkzeug für <em>simples und skalierbares State Management</em>. Auf der anderen Seite haben wir <strong>Redux</strong>, zweifellos der „Platzhirsch“ in der React-Welt, mitentwickelt unter anderem von Dan Abramov und Andrew Clark, die inzwischen auch dem offiziellen React-Team angehören. Redux bezeichnet sich als <em>„A predictable state container for JavaScript apps“</em> also als <em>„vorhersehbarer State Container für JavaScript-Anwendungen“</em>.</p>
<p>In diesem Kapitel soll es insbesondere um <strong>Redux</strong> gehen. Einerseits, weil ich selbst mit <strong>Redux</strong> in vielen Projekten gearbeitet und sehr gute Erfahrungen damit machen durfte, andererseits aber auch weil es mit (laut npmjs.com) wöchentlich rund <strong>4 Millionen Installationen</strong> ganz klar deutlich mehr im Mainstream angekommen ist als <strong>MobX</strong>, mit immer respektablen, verglichen jedoch mit <strong>Redux</strong> doch überschaubaren <strong>200.000 Installationen</strong>.</p>
<p><strong>Redux</strong> erfreut sich dabei noch immer an steigender Beliebtheit und hat wachsende Downloadzahlen zu verzeichnen obwohl es bereits mehrmals von irgendwelchen Propheten tot gesagt wurde. Als die finale <strong>Context API</strong> in <strong>React 16.3.0</strong> veröffentlicht wurde hieß es, dass <strong>Redux</strong> damit obsolet würde (wurde es nicht), als mit <strong>React 16.8.0</strong> die <strong>Hooks</strong> und hier insbesondere der stark an <strong>Redux</strong> angelehnte <strong>useReducer-Hook</strong> eingeführt wurde gab es diese Stimmen erneut.</p>
<p>In der Realität sieht das so aus, dass die Zahl der Installationen auch nach Einführung von <strong>Context</strong> und <strong>Hooks</strong> weiter steigen und <strong>Redux</strong> selbst intern <strong>Gebrauch</strong> dieser neuen Möglichkeiten macht, um einerseits die Performance zu verbessern und andererseits die Verwendung der eigenen API zu vereinfachen. Darüber hinaus hat <strong>Redux</strong> inzwischen ein unheimlich großes Ecosystem an eigenen Addons und Tools um sich versammelt, das auch durch die in React neu hinzugekommenen Funktionen nicht ersetzt wird.</p>
<h3 id="einführung-in-redux">Einführung in Redux</h3>
<p>Bei <strong>Redux</strong> handelt es sich also wie beschrieben um einen <em>vorhersehbaren State Container</em>. Doch was bedeutet das genau? An dieser Stelle möchte ich gern etwas weiter ausholen, da ich es für wichtig erachte das Grundprinzip zu verstehen um hinterher Fehler zu vermeiden die schnell gemacht werden, hat man das Prinzip hinter <strong>Redux</strong> nicht zumindest in sehr groben Ansätzen verinnerlicht.</p>
<p>Erst einmal haben wir mit <strong>Redux</strong> ein Tool, das in Teilen angelehnt ist an die Prinzipien der <strong>Flux Architektur</strong>. Diese wurde - wie auch <strong>React</strong> selbst - von <strong>Facebook</strong> entwickelt, um die Entwicklung clientseitiger Web Anwendungen zu vereinfachen. Das Grundprinzip sieht dabei einen <strong>unidirektionalen Datenfluss</strong> vor, bei dem Daten immer nur <strong>in eine Richtung</strong> fließen. Also das Prinzip, wie wir es bereits aus <strong>React</strong> selbst kennen: eine <strong>Aktion</strong> (bspw. ausgelöst durch einen Button-Klick) ändert den <strong>State</strong>, die <strong>State-Änderung</strong> löst ein <strong>Rerendering</strong> aus und erlaubt es dann weitere Aktionen auszuführen.</p>
<p>Nach diesem Prinzip funktioniert auch <strong>Redux</strong>, mit dem entscheidenden Unterschied jedoch, dass der State eben <strong>global</strong> verwaltet wird statt nur innerhalb einer Komponente und somit alle Komponenten, egal wo im Seitenbaum sich diese befinden, auf <strong>sämtliche Daten</strong> zugreifen können.</p>
<p>Um Redux in einem Projekt zu nutzen, müssen wir es natürlich zuerst wieder einmal über die Kommandozeile installieren:</p>
<pre><code class="hljs bash language-bash">npm install redux react-redux</code></pre>
<p>bzw. mit Yarn:</p>
<pre><code class="hljs bash language-bash">yarn add redux react-redux</code></pre>
<p>Installiert werden hier <strong>zwei</strong> Pakete. Die Library <code>redux</code> selbst und <code>react-redux</code>. Während mit dem <code>redux</code> Paket die eigentliche State Management Library installiert wird, werden mit <code>react-redux</code> die sog. <strong>Bindings</strong> installiert. Auf gut Deutsch gesagt ist dies einfach nur ein Paket mit einigen <strong>React-Komponenten</strong> die konkret für die Verwendung von <strong>Redux</strong> mit <strong>React</strong> entwickelt und daraufhin optimiert wurden. Keine große Magie.</p>
<p>Theoretisch wäre auch die Verwendung von <strong>Redux</strong> alleine möglich, allerdings müssten wir uns dann selbst darum kümmern zu schauen wann Komponenten neu gerendert werden und darum, wie Daten aus einer Komponente in den State Container rein und wieder raus kommen. Da wir das nicht wollen, weil sich jemand anderes der sich viel besser damit auskennt als wir alle das bereits gemacht hat, nutzen wir eben zusätzlich <code>react-redux</code>.</p>
<h3 id="store-actions-und-reducer">Store, Actions und Reducer</h3>
<p>Nicht von den möglicherweise noch unbekannten Begriffen verunsichern lassen. Wir gehen sie der Reihe nach durch und irgendwann macht es Klick.</p>
<p>Alle Daten in <strong>Redux</strong> befinden sich in einem sogenannten <strong>Store</strong>, der sich um die Verwaltung des globalen <strong>States</strong> kümmert. Theoretisch kann eine Anwendung auch mehrere Stores haben, im Konzept von Flux ist das sogar explizit so vorgesehen, in <strong>Redux</strong> ist das jedoch um Komplexität zu reduzieren eher unüblich und so beschränken sich React Anwendungen die <strong>Redux</strong> einsetzen meist auch auf lediglich einen <em>einzigen</em> <strong>Store</strong> als <strong>Single Source of Truth</strong>, also als <em>die</em> einzige wahre Quelle für alle Daten. Der Store stellt Methoden bereit um die sich in ihm befindlichen Daten zu verändern (<code>dispatch</code>), zu lesen (<code>getState</code>), und auf Änderungen zu reagieren (<code>subscribe</code>).</p>
<p>Die einzige Möglichkeit um Daten in einem <strong>Store</strong> zu verändern ist dabei durch das Auslösen (<em>„dispatchen“</em>) von <strong>Actions</strong>. Auch hier lässt sich <strong>Redux</strong> wieder von Ideen aus der Flux Architektur inspirieren und macht es erforderlich diese <strong>Actions</strong> im Format der <strong>Flux Standard Actions</strong> (FSA) zu halten. Eine solche <strong>FSA</strong> bestehen aus einem simplen JavaScript-Objekt das immer <strong>zwingend</strong> eine <code>type</code>-Eigenschaft besitzen <em>muss</em> und darüber hinaus die drei weiteren Eigenschaften <code>payload</code>, <code>meta</code> und <code>error</code> besitzen <em>kann</em>, wobei uns in erster Linie einmal die <code>payload</code> interessieren soll, mit der wir es in 9 von 10 Fällen in denen wir eine <strong>Action</strong> <em>dispatchen</em> zu tun haben werden.</p>
<p>Die <strong>Payload</strong> stellt sozusagen den <em>Inhalt</em> einer <strong>Action</strong> dar und kann vom simplen Boolean oder String, über numerische Werte, bis hin zu komplexen Arrays oder Objekten beliebige Daten beinhalten die serialisierbar sind, also in Form einer JSON-Repräsentation gespeichert werden können.</p>
<p>Beispiel für eine typische <strong>Action</strong> in <strong>Redux</strong>:</p>
<pre><code class="hljs javascript language-javascript">{
  <span class="hljs-attr">type</span>: <span class="hljs-string">"SET_USER"</span>,
  <span class="hljs-attr">payload</span>: {
    <span class="hljs-attr">id</span>: <span class="hljs-string">"d929e553-7079-4309-8c7d-2d2db39922c6"</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">"Manuel"</span>
  }
}</code></pre>
<p>Wird eine <strong>Action</strong> durch die vom <strong>Store</strong> bereitgestellte <code>dispatch</code>Methode ausgelöst, wird der zum Zeitpunkt des Aufrufs aktuelle <strong>State</strong> zusammen mit der ausgelösten <strong>Action</strong> an die <strong>Reducer</strong> übergeben. Ein <strong>Reducer</strong> ist eine <strong>pure Function</strong>, die wir ebenfalls bereits aus React kennen, und dient dazu um aus dem <strong>aktuellen State</strong> und der jeweiligen Action mit ihren <code>type</code> und <code>payload</code> Eigenschaften einen <strong>neuen State</strong> zu erzeugen. Zur Erinnerung: eine <strong>pure Function</strong> erzeugt stets die <strong>selbe Ausgabe</strong> bei <strong>gleichen Eingabeparametern</strong>, egal wie oft diese aufgerufen wird. Dieses Verhalten ist es, das sie vorhersehbar und dadurch auch gleichzeitig einfach testbar macht.</p>
<p>Beispiel für einen <strong>Reducer</strong>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> reducer = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> {
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'PLUS'</span>: {
      <span class="hljs-keyword">return</span> state + action.payload;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'MINUS'</span>: {
      <span class="hljs-keyword">return</span> state - action.payload;
    }
    <span class="hljs-keyword">default</span>: {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
  }
};</code></pre>
<p>Ein <strong>Store</strong> erwartet bei seiner Erstellung grundsätzlich einen einzigen <strong>Reducer</strong>, jedoch bietet <strong>Redux</strong> hier mit der <code>combineReducers()</code>-Funktion eine Möglichkeit um diese <strong>Reducer</strong>-Funktion zur besseren Verständlichkeit und Lesbarkeit in beliebig viele kleine Teilstücke zu splitten und anschließend zu einem großen, gemeinsamen <strong>Reducer</strong> zusammen zu setzen, auch <strong>Root-Reducer</strong> genannt. Wird dann eine Action <em>dispatched</em> wird jeder <strong>Reducer</strong> mit jeweils den gleichen Parametern, nämlich dem <strong>State</strong> und der <strong>Action</strong>, aufgerufen. Diese Methode schauen wir uns in diesem Kapitel später noch etwas genauer an.</p>
<p>Da jeder <strong>Reducer</strong> auf die <code>type</code>-Eigenschaft einer <strong>Action</strong> reagiert ist es ein Stück weit zur weit verbreiteten Konvention geworden alle verwendeten Types in gleichnamige Variablen auszulagern, da ein Tippfehler im ersten Moment nicht immer gleich auffällt (bspw. <code>USER_ADDDED</code>), der JavaScript-Interpreter jedoch einen Fehler wirft beim Zugriff auf eine nicht definierte Variable. So findet man in Apps in denen <strong>Redux</strong> eingesetzt wird zu Beginn einer Datei oft einen Code-Block von folgendem Format:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> PLUS = <span class="hljs-string">'PLUS'</span>;
<span class="hljs-keyword">const</span> MINUS = <span class="hljs-string">'MINUS'</span>;</code></pre>
<p>Dies dient eben dazu, um Kohärenz bei den verwendeten <strong>Action Types</strong> sicher zu stellen.</p>
<h3 id="einen-store-erstellen">Einen Store erstellen</h3>
<p>Um einen Store zu erstellen der unseren globalen State verwalten wird, importieren wir die <code>createStore</code> Funktion aus dem <code>redux</code> Paket, rufen diese auf und übergeben ihr eine <strong>Reducer</strong>-Funktion. Die Funktion gibt uns daraufhin das Store-Objekt zurück mit Methoden um mit dem Store zu arbeiten: <code>dispatch</code>, <code>getState</code> sowie <code>subscribe</code>, wobei letztere eine eher untergeordnete Rolle bei der Arbeit mit React spielt, da die Komponenten aus dem <code>react-redux</code> Paket sich um das Rerendering von Komponenten kümmern, die von einer Änderung am <strong>State</strong> betroffen sind.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;

<span class="hljs-keyword">const</span> initialState = <span class="hljs-number">0</span>;

<span class="hljs-keyword">const</span> counterReducer = <span class="hljs-function">(<span class="hljs-params">state = initialState, action</span>) =&gt;</span> {
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'PLUS'</span>: {
      <span class="hljs-keyword">return</span> state + (action.payload || <span class="hljs-number">0</span>);
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'MINUS'</span>: {
      <span class="hljs-keyword">return</span> state - (action.payload || <span class="hljs-number">0</span>);
    }
    <span class="hljs-keyword">default</span>: {
      <span class="hljs-keyword">return</span> state;
    }
  }
};

<span class="hljs-keyword">const</span> store = createStore(counterReducer);</code></pre>
<p>Hier haben wir einen ersten und noch sehr simplen Store mit einem Counter-Reducer erstellt. Da wir der <code>createStore</code> Funktion hier nur den ersten Parameter übergeben, wird die <code>counterReducer</code>-Funktion beim Initialisieren mit <code>undefined</code> als vorherigen <code>state</code> aufgerufen, weshalb der <code>initialState</code> als Standardparameter eingesetzt wird. Dieser entspricht hier dem numerischen Wert <code>0</code>.</p>
<p>Übergeben wir der <code>createStore</code> Funktion einen zweiten Parameter, so würde dieser als erster State beim Initialisieren an die Reducer-Funktion übergeben werden:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> store = createStore(counterReducer, <span class="hljs-number">3</span>);</code></pre>
<p>Hier wäre der Startwert für unseren <code>state</code>-Parameter der an die <code>counterReducer</code>-Funktion übergeben wird <code>3</code> statt <code>undefined</code>, der <code>initialState</code> Standardparameter würde nicht einspringen und unser Counter würde bei <code>3</code> beginnen zu zählen, statt bei <code>0</code>.</p>
<p>Als initiale <strong>Action</strong> wird eine Redux-interne Action <em>dispatched</em>, die die Form <code>{type: '@@redux/INIT5.3.p.j.l.8'}</code> besitzt. Daher greift in unserem <code>switch</code>-Block der <code>default</code>-Fall und gibt einfach nur den übergebenen <code>state</code> (der in diesem Fall dem <code>initialState</code> entspricht) zurück.</p>
<p>Ein solcher <code>default</code>-Fall ist wichtig. Greift kein anderer <code>case</code> im <code>switch</code>, muss stets der letzte Stand des States aus der Funktion zurückgegeben werden um unerwünschte Seiteneffekte zu vermeiden. Die <code>Reducer</code>-Funktion wird bei <strong>jedem</strong> <code>dispatch</code>-Aufruf ausgeführt und ihr Rückgabewert bestimmt immer den <strong>nächsten State!</strong></p>
<p>Rufen wir nun gleich nach der Initialisierung <code>store.getState()</code> auf, erhalten wir unseren <code>initialState</code> zurück: <code>0</code>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-built_in">console</span>.log(store.getState()); <span class="hljs-comment">// 0</span></code></pre>
<p>Wir können nun etwas rumspielen, verschiedene <strong>Actions dispatchen</strong> und schauen wie unser <strong>State</strong> auf die <strong>Actions</strong> jeweils reagiert:</p>
<pre><code class="hljs javascript language-javascript">store.dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'PLUS'</span>, <span class="hljs-attr">payload</span>: <span class="hljs-number">2</span> });
<span class="hljs-built_in">console</span>.log(store.getState()); <span class="hljs-comment">// 2</span>

store.dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'PLUS'</span>, <span class="hljs-attr">payload</span>: <span class="hljs-number">1</span> });
<span class="hljs-built_in">console</span>.log(store.getState()); <span class="hljs-comment">// 3</span>

store.dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'MINUS'</span>, <span class="hljs-attr">payload</span>: <span class="hljs-number">2</span> });
<span class="hljs-built_in">console</span>.log(store.getState()); <span class="hljs-comment">// 1</span></code></pre>
<p>Hier <em>dispatchen</em> wir zweimal eine <strong>Action</strong> mit dem <code>type</code> <code>PLUS</code> und einmal eine Action vom <code>type</code> <code>MINUS</code>. Wir übergeben jeweils eine <code>payload</code>, mit der wir angeben um wie viele Ziffern wir den letzten State hoch- oder runterzählen wollen. Unsere <strong>State-Mutation</strong> findet also wie folgt statt:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-number">0</span> (initialer State) + <span class="hljs-number">2</span> (payload) = <span class="hljs-number">2</span> (neuer State)
<span class="hljs-number">2</span> (alter State)     + <span class="hljs-number">1</span> (payload) = <span class="hljs-number">3</span> (neuer State)
<span class="hljs-number">3</span> (alter State)     - <span class="hljs-number">2</span> (payload) = <span class="hljs-number">1</span> (neuer State)</code></pre>
<p>Dieser State ist dabei noch denkbar simpel und besteht lediglich aus einem einzigen Wert. Später werden wir uns noch anschauen wie wir komplexeren <strong>State</strong> aus verschiedenen Objekten und mit mehreren <strong>Reducern</strong> erstellen.</p>
<h3 id="action-creators-vs-actions">Action Creators vs. Actions</h3>
<p>Wer Artikel über <strong>Redux</strong> liest oder auch in die offizielle Doku schaut wird immer wieder mit den Begriffen <strong>Action</strong> und <strong>Action Creator</strong> konfrontiert. Mir selbst fiel es anfangs etwas schwer die Unterschiede zu verstehen und ich weiß auch von anderen, dass es nicht nur mir so erging. Erschwerend kommt hinzu, dass die Begriffe auch gelegentlich synonym verwendet werden obwohl sie es nicht sind. Daher möchte ich an dieser Stelle kurz einen keinen Exkurs einwerfen um die beiden Begriffe <strong>Action Creator</strong> und <strong>Action</strong> voneinander abzugrenzen.</p>
<p>Die <strong>Action</strong> haben wir oben bereits kennengelernt und ist ein einfaches und möglichst <em>serialisierbares</em> <strong>Objekt</strong>, mit dem wir beschreiben wie wir den State verändern wollen. Es enthält immer zwingend eine <code>type</code>-Eigenschaft und meist auch eine <code>payload</code>.</p>
<p>Ein <strong>Action</strong> <em><strong>Creator</strong></em> hingegen ist eine <strong>Funktion</strong>, die schlussendlich eine <strong>Action</strong> <strong>zurückgibt</strong>, also sozusagen eine <strong>Factory</strong>, die eine <strong>Action</strong> <em>erstellt</em> (daher: <em>Creator</em>). Meist werden <strong>Action Creators</strong> dazu verwendet um in ihnen <strong>Logik zu kapseln</strong>, die zur Erstellung einer <strong>Action</strong> notwendig ist. Manchmal werden sie aber auch einfach verwendet um die doch recht umständliche Natur der <strong>Actions</strong> hinter einer einprägsamen Funktion weg zu abstrahieren. <strong>Action Creators</strong> werden dann an Stelle der ursprünglichen <strong>Action</strong> als Parameter der <code>dispatch</code>-Methode aufgerufen.</p>
<p>Typische <strong>Action Creators</strong> aus unserem obigen Beispiel würden dann bspw. so aussehen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">type</span>: <span class="hljs-string">'PLUS'</span>, <span class="hljs-attr">payload</span>: number };
};

<span class="hljs-keyword">const</span> subtract = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">type</span>: <span class="hljs-string">'MINUS'</span>, <span class="hljs-attr">payload</span>: number };
};</code></pre>
<p>Oder wer mit den <strong>Shorthand Notationen</strong> aus <strong>ES2015+</strong> vertraut ist kann das Ganze auch noch weiter abkürzen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">payload</span>) =&gt;</span> ({ <span class="hljs-attr">type</span>: <span class="hljs-string">'PLUS'</span>, payload });
<span class="hljs-keyword">const</span> subtract = <span class="hljs-function">(<span class="hljs-params">payload</span>) =&gt;</span> ({ <span class="hljs-attr">type</span>: <span class="hljs-string">'MINUS'</span>, payload });</code></pre>
<p>Anschließend werden die entsprechenden <strong>Action Creators</strong> als Parameter der <code>dispatch</code>-Methode aufgerufen, statt die <strong>Actions</strong> direkt zu übergeben:</p>
<pre><code class="hljs javascript language-javascript">store.dispatch(add(<span class="hljs-number">2</span>));
store.dispatch(add(<span class="hljs-number">1</span>));
store.dispatch(subtract(<span class="hljs-number">2</span>));</code></pre>
<p>Dies geht bei entsprechender Benamung der <strong>Action Creator</strong> Funktionen deutlich zu Gunsten besserer Verständlichkeit des Codes. <strong>Action Creator</strong> sind dabei ein wichtiges Puzzlestück im Redux-Konzept und aus der täglichen Arbeit nicht wegzudenken da sie uns viel Schreibarbeit und Wiederholungen ersparen und somit auch potentielle Fehlerquellen wie bspw. Tippfehler beim <code>type</code> einer <strong>Action</strong> verringern (etwa <code>PLSU</code> statt <code>PLUS</code>).</p>
<h3 id="komplexe-reducer">Komplexe Reducer</h3>
<p>Die bisherigen Beispiele dienten dazu mit dem Konzept von <strong>Actions</strong> und <strong>Reducern</strong> vertraut zu werden und um zu verstehen, wie <strong>Actions</strong> verwendet werden, um mit dem <strong>Reducer</strong> den <strong>Store</strong> zu mutieren. Typischerweise besteht der <strong>State</strong> in einer React-Anwendung aber aus deutlich komplexeren Daten und Objekten. Werfen wir also einen Blick auf einen Store, wie er realistisch in einer kleinen Anwendung aussehen könnte.</p>
<p>Als Beispiel soll uns das State-Management für eine fiktive kleine <strong>Todo-App</strong> dienen, die sowohl eine Liste mit Todos verwaltet, als auch einen eingeloggten Benutzer beinhaltet. Unser State halt also die beiden Toplevel-Eigenschaften <code>todos</code> (vom Typ Array) und <code>user</code> (vom Typ Objekt). Dies bilden wir in unserem initialen State auch so ab:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> initialState = <span class="hljs-built_in">Object</span>.freeze({
  <span class="hljs-attr">user</span>: {},
  <span class="hljs-attr">todos</span>: [],
});</code></pre>
<p>Zusätzlich, da wir sicherstellen wollen, dass bei jedem Aufruf ein neues State-Objekt erzeugt wird und nicht das alte mutiert wird, umschließen wir unseren initialen State mit einem <code>Object.freeze()</code>. Dies sorgt dafür, dass wir einen <code>TypeError</code> bekommen, sollte das <strong>State-Objekt</strong> direkt mutiert werden.</p>
<p>Schauen wir uns an wie eine <strong>Reducer</strong>-Funktion aussieht könnte, mit der wir den eingeloggten Benutzer setzen, neue Todos hinzufügen und entfernen sowie deren Status ändern können:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> rootReducer = <span class="hljs-function">(<span class="hljs-params">state = initialState, action</span>) =&gt;</span> {
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'SET_USER'</span>: {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">user</span>: {
          <span class="hljs-attr">name</span>: action.payload.name,
          <span class="hljs-attr">accessToken</span>: action.payload.accessToken,
        },
        <span class="hljs-attr">todos</span>: state.todos,
      };
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'ADD_TODO'</span>: {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">user</span>: state.user,
        <span class="hljs-attr">todos</span>: state.todos.concat({
          <span class="hljs-attr">id</span>: action.payload.id,
          <span class="hljs-attr">text</span>: action.payload.text,
          <span class="hljs-attr">done</span>: <span class="hljs-built_in">Boolean</span>(action.payload.done),
        }),
      };
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'REMOVE_TODO'</span>: {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">user</span>: state.user,
        <span class="hljs-attr">todos</span>: state.todos.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> todo.id !== action.payload),
      };
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'CHANGE_TODO_STATUS'</span>: {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">user</span>: state.user,
        <span class="hljs-attr">todos</span>: state.todos.map(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> {
          <span class="hljs-keyword">if</span> (todo.id !== action.payload.id) {
            <span class="hljs-keyword">return</span> todo;
          }
          <span class="hljs-keyword">return</span> {
            ...todo,
            <span class="hljs-attr">done</span>: action.payload.done,
          };
        }),
      };
    }
    <span class="hljs-keyword">default</span>: {
      <span class="hljs-keyword">return</span> state;
    }
  }
};

<span class="hljs-keyword">const</span> store = createStore(rootReducer);</code></pre>
<p>Ich möchte hier gar nicht auf alles was hier passiert zu tief ins Detail eingehen, da es hier darum gehen soll wie ein großer, unübersichtlicher <strong>Reducer</strong> in mehrere kleinere und idealerweise übersichtlichere aufgeteilt werden kann. Doch einige Stellen sind für das generelle Verständnis nicht unwichtig. Gehen wir also der Reihe nach den <code>switch</code>-Block durch, bei dem uns jeder <code>case</code>-Block ein neues State-Objekt zurück gibt.</p>
<p>Angefangen bei <code>SET_USER</code>: das hier erzeugte <strong>State-Objekt</strong> ändert das <code>user</code>-Objekt und setzt dessen <code>name</code>-Eigenschaft auf <code>action.payload.name</code>, sowie die <code>accessToken</code>-Eigenschaft auf <code>action.payload.accessToken</code>. Wer mag, der kann hier stattdessen auch <code>user</code> auf <code>action.payload</code> setzen, dann würden alle in der entsprechenden <strong>Payload</strong> der <strong>Action</strong> übergebenen Eigenschaften im <code>user</code>-Objekt landen. Dabei sollte dann aber sichergestellt sein, dass die <code>action.payload</code> immer ein Objekt ist, da wir ansonsten die Ausgangsform des <code>user</code>-Objekts verändern würden was zu Problemen führen kann, wenn bspw. auch andere Teile des <strong>Reducers</strong> auf das Objekt zugreifen und das Objekt plötzlich keines mehr ist. In unserem Beispiel ignorieren wir aber alle anderen Eigenschaften indem wir explizit nur <code>name</code> und <code>accessToken</code> aus der <strong>Payload</strong> der ausgelösten Action holen.</p>
<p>Neben dem modifizierten <code>user</code> geben wir auch eine <code>todos</code>-Eigenschaft zurück, die wir auf <code>state.todos</code> setzen, also beim bisherigen Wert belassen. <strong>Dies ist wichtig</strong>, da in unserem State-Objekt die <code>todos</code> ansonsten komplett aus dem State entfernt werden würden und wir nun zwar den Benutzer gesetzt, unsere Todos jedoch aus dem State verloren hätten!</p>
<p>Weiter geht es mit <code>ADD_TODO</code>: Hier ist es andersherum und wir geben zuerst einmal den <code>user</code>-Ast unseres State-Trees unverändert zurück. Anschließend fügen wir das neue Todo-Item mittels <code>.concat()</code>-Methode dem <code>todo</code>-Array hinzu. Hier ist es wichtig <code>concat()</code> und nicht <code>push()</code> zu benutzen, da <code>push()</code> eine sog. <em>mutative</em> Methode ist, also den bestehenden State verändert statt einen neuen State zu erzeugen. Mittels <code>state.todos.concat</code> nehmen wir das aktuelle <code>todos</code>-Array als Basis und erzeugen daraus ein neues Array mit dem neuen Todo-Item und geben dieses zurück.</p>
<p>Sehr ähnliches passiert im nächsten Fall: <code>REMOVE_TODO</code>. Hier geben wir wieder zuerst den <code>user</code>-Ast zurück, ehe wir im <code>todos</code>-Array nach dem zu entfernenden Eintrag suchen, um diesen anschließend herauszufiltern. Welcher Eintrag zu entfernen ist, das übergeben wir der Action als <code>action.payload</code> in Form einer Todo-ID. Das gefilterte Array ist dann unser neuer <code>todos</code>-State. Wir nutzen hier die <code>Array.filter()</code>-Methode, da diese anders als bspw. <code>Array.splice()</code> nicht <em>mutativ</em> ist und ein neues Array erzeugt.</p>
<p>Zuletzt haben wir den <code>CHANGE_TODO_STATUS</code> Fall. Mit diesem ändern wir den Status des Todo-Elements, also von <em>Zu erledigen</em> (<code>false</code>) auf <em>Erledigt</em> (<code>true</code>) - oder eben andersherum. Dazu geben wir, erneut, das unveränderte <code>user</code>-Objekt aus dem vorherigen State zurück und iterieren anschließend mittels <code>state.todos.map()</code>durch alle Todos. In der Map-Funktion schauen wir ob die ID des aktuellen Todo-Objekts der ID aus der <code>action.payload</code> entspricht. Ist dies nicht der Fall, geben wir einfach jeweilige Todo-Element unverändert zurück.</p>
<p>Entspricht die ID aus der Payload der ID des aktuellen Todo-Elements, erzeugen wir ein neues Objekt, schreiben alle Eigenschaften mit ihren jeweiligen Werten mittels ES2015+ Spread-Syntax (<code>{ ...todo }</code>) in das neu erzeugte Objekt und überschreiben die <code>done</code>-Eigenschaft mit dem neuen Wert aus der Action-Payload. Wir generieren hier ein neues Objekt statt einfach das bestehende zu überschreiben, da wir ja einen neuen State erzeugen müssen damit unser <strong>Reducer</strong> eine <strong>Pure Function</strong> bleibt. Die Verwendung der <code>Array.map()</code>-Methode sorgt bereits dafür, dass wir außerdem ein neues Array erzeugen.</p>
<p>Hier haben wir es lediglich mit zwei Ästen in unserem State-Tree zu tun: <code>user</code> und <code>todos</code> - und dennoch wird unsere <strong>Reducer</strong>-Funktion bereits sehr lang. Bei steigender Komplexität des States wird die Funktion entsprechend noch länger und vor allem: <strong>fehleranfälliger</strong>. Da wir neben dem veränderten Teil des States auch immer alle anderen Teile zurückgeben müssen - also etwa den unveränderten <code>user</code> wenn wir die <code>todos</code> modifizieren oder eben die <code>todos</code> wenn wir den <code>user</code> modifizieren, wird die Funktion sehr schnell unübersichtlich und schwierig zu verwalten. Zur Erleichterung könnten wir hier auch die Object Spread Syntax aus ES2015+ nutzen und aus dem bisherigen State einen neuen State erzeugen und anschließend den veränderten Ast des State-Trees überschreiben. Das könnte dann am Beispiel des <code>ADD_TODO</code> Falls so aussehen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">case</span> <span class="hljs-string">"ADD_TODO"</span>: {
  <span class="hljs-keyword">return</span> {
    ...state,
    <span class="hljs-attr">todos</span>: state.todos.concat(action.payload),
  };
}</code></pre>
<p>Aber auch das macht die Sache nur unwesentlich einfacher für uns, da es uns noch immer recht schnell passieren kann, dass wir vergessen den alten, unveränderten Teil des States mit zurück zu geben.</p>
<p>Aus diesem Grund stellt <strong>Redux</strong> die <code>combineReducer()</code>-Methode bereit. Mit ihr wird es möglich unsere <strong>Reducer</strong>, bzw. den <strong>State</strong> den diese erzeugen, in einzelne benannte Teilbereiche aufzuteilen, die sich dann jeweils um eine bestimmte Aufgabe kümmern und in eigene Dateien ausgelagert werden können.</p>
<p>Ausgehend von unserem Beispiel hätten wir hier also die beiden <strong>Reducer-</strong>Funktionen <code>user</code> und <code>todos</code>. Beide befinden sich in einer eigenen Datei, die die <strong>Reducer-</strong>Funktion als <code>default</code> exportiert:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// user/reducer.js</span>
<span class="hljs-keyword">const</span> initialState = <span class="hljs-built_in">Object</span>.freeze({});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (state = initialState, action) =&gt; {
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'SET_USER'</span>: {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">name</span>: action.payload.name,
        <span class="hljs-attr">accessToken</span>: action.payload.accessToken,
      };
    }
    <span class="hljs-keyword">default</span>: {
      <span class="hljs-keyword">return</span> state;
    }
  }
};</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// todos/reducer.js</span>
<span class="hljs-keyword">const</span> initialState = <span class="hljs-built_in">Object</span>.freeze([]);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (state = initialState, action) =&gt; {
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'ADD_TODO'</span>: {
      <span class="hljs-keyword">return</span> state.concat(action.payload);
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'REMOVE_TODO'</span>: {
      <span class="hljs-keyword">return</span> state.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> todo.id !== action.payload);
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'CHANGE_TODO_STATUS'</span>: {
      <span class="hljs-keyword">return</span> state.map(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (todo.id !== action.payload.id) {
          <span class="hljs-keyword">return</span> todo;
        }
        <span class="hljs-keyword">return</span> {
          ...todo,
          <span class="hljs-attr">done</span>: action.payload.done,
        };
      });
    }
    <span class="hljs-keyword">default</span>: {
      <span class="hljs-keyword">return</span> state;
    }
  }
};</code></pre>
<p>Wer genau hinschaut stellt fest, dass unsere große, unübersichtliche <strong>Reducer</strong>-Funktion nicht nur in zwei kleinere und deutlich übersichtlichere Funktionen aufgeteilt wurden. Die Funktionen selbst wurden darüber hinaus auch vereinfacht. Statt jeweils auch den <em>unveränderten</em> Teil des <strong>State-Trees</strong> aus dem <strong>Reducer</strong> zurück zu geben, geben wir nur noch den Teil des States zurück, der <em>relevant für den jeweiligen</em> <strong>Reducer</strong> ist. Im <strong>User-Reducer</strong> ist das eben der <strong>Benutzer</strong>, im <strong>Todos-Reducer</strong> entsprechend die <strong>Todos</strong>.</p>
<p>Um unsere beiden <em>kleineren</em> <strong>Reducer</strong> nun wieder zu einer <em>großen</em> <strong>Reducer</strong>-Funktion zusammenzufügen, die wir dann als einzige an die <code>createStore()</code>-Funktion übergeben können, nutzen wir <code>combineReducers()</code>. Diese Funktion erwartet ein Objekt, dessen Eigenschaftennamen denen des erzeugten State-Tree entsprechen. Die Werte müssen jeweils selbst gültige <strong>Reducer</strong> sein:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> { combineReducers, createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;
<span class="hljs-keyword">import</span> userReducer <span class="hljs-keyword">from</span> <span class="hljs-string">'./store/user/reducer'</span>;
<span class="hljs-keyword">import</span> todosReducer <span class="hljs-keyword">from</span> <span class="hljs-string">'./store/todos/reducer'</span>;

<span class="hljs-keyword">const</span> rootReducer = combineReducers({
  <span class="hljs-attr">todos</span>: todosReducer,
  <span class="hljs-attr">user</span>: userReducer,
});

<span class="hljs-keyword">const</span> store = createStore(rootReducer);</code></pre>
<p>Die <code>combineReducers()</code>-Funktion fügt dabei alle Reducer aus dem übergebenen Objekt zu einer neuen Funktion zusammen, die nun als unser <strong>Root Reducer</strong> an die <code>createStore()</code>-Funktion übergeben werden kann. Die erzeugte Funktion ruft dabei beim Auslösen einer Action <em>jeden</em> übergebenen Reducer auf und erstellt aus deren Rückgabewerten dann ein neues State-Objekt, das von der Form dem, des initial übergebenen Objekts entspricht. In unserem Beispiel von oben ist der initiale State also:</p>
<pre><code class="hljs javascript language-javascript">{
  <span class="hljs-string">"todos"</span>: [],
  <span class="hljs-string">"user"</span>: {}
}</code></pre>
<p>Tipp: durch die geschickte Nutzung der ES2015+ Object Shorthand Notation können wir noch ein klein wenig Code sparen, indem wir die Imports so nennen wie die Eigenschaften, die sie im State später einmal repräsentieren. Also:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> user <span class="hljs-keyword">from</span> <span class="hljs-string">'./store/user/reducer'</span>;
<span class="hljs-keyword">import</span> todos <span class="hljs-keyword">from</span> <span class="hljs-string">'./store/todos/reducer'</span>;</code></pre>
<p>Das Objekt das an <code>combineReducers()</code> übergeben wird, schrumpft dann auf ein übersichtlicheres:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> rootReducer = combineReducers({ todos, user });</code></pre>
<p>Die Nutzung von <code>combineReducers()</code> ist allerdings an einige formelle Regeln gebunden die, einmal verinnerlicht, aber nicht wirklich hinderlich oder gar schwer zu merken sind. So muss jede Reducer-Funktion die an <code>combineReducers()</code> übergeben wird die folgenden Kriterien erfüllen:</p>
<ul>
<li>Für jede unbekannte <strong>Action</strong> (also jede <strong>Action</strong>, auf deren <code>type</code>-Eigenschaft wir nicht reagieren) die ein <strong>Reducer</strong> (in seinem <em>zweiten</em> Argument) übergeben bekommt, muss der <code>state</code> zurückgegeben werden, den der <strong>Reducer</strong> stets als <em>erstes</em> Argument bekommt.</li>
<li>Anders als „von Hand“ erzeugte, einfache <strong>Root Reducer</strong> darf eine innerhalb von <code>combineReducer()</code> verwendete <strong>Reducer</strong>-Funktion niemals <code>undefined</code> zurückgeben. Die <code>combineReducers()</code>-Funktion wirft dann einen <strong>Error</strong> um auf diesen Umstand hinzuweisen und dabei die Suche der Fehler-Ursache nicht durch Verlagerung des Fehlers an andere Stelle unnötig zu erschweren. In unserem Beispiel tun wir das, indem wir im <code>default</code>-Fall innerhalb des <code>switch</code>-Blocks den <code>state</code> zurückgeben.</li>
<li>Wenn der im ersten Argument übergebene <code>state</code> vom Typ <code>undefined</code> ist, muss der <strong>initiale State</strong> zurückgegeben werden. Dazu ist es am einfachsten den initialen State als Standardwert zu setzen, wie wir es im obigen Beispiel auch getan haben via <code>state = initialState</code>.</li>
</ul>
<p><strong>Übrigens:</strong> <code>combineReducer()</code> lässt sich auch beliebig „verschachteln“. Und so können auch die <strong>Reducer</strong>-Funktionen die an <code>combineReducer()</code> übergeben werden selbst bereits durch <code>combineReducer()</code> erzeugt worden sein. Dabei sollte allerdings beachtet werden, dass zu fein granulare Aufteilung in immer kleinere State-Äste den Code irgendwann nicht mehr unbedingt übersichtlicher macht. In der Praxis habe ich persönlich bisher mit einer Verschachtelungstiefe von maximal <em>einer</em> Ebene (also insgesamt zwei <code>combineReducer()</code>-Aufrufen, einer innen, einer außen) gearbeitet.</p>
<h3 id="asynchrone-actions">Asynchrone Actions</h3>
<p>Alle <strong>Actions</strong> in vorherigen Beispielen wurden bisher immer <strong>synchron</strong> ausgeführt. D.h. ihre <strong>Action Creators</strong> wurden ausgeführt wann immer wir den State modifizieren wollten ohne dass wir auf das Ergebnis asynchroner Prozesse warten mussten. In dynamischen Web-Anwendungen, in denen die Stärken von <strong>React</strong> am meisten zum Vorschein kommen, haben wir jedoch regelmäßig mit <strong>asynchronen Datenflüssen</strong> zu tun, insbesondere mit Netzwerk-Requests. Hier helfen uns unsere <em>synchronen</em> <strong>Action Creator</strong>-Funktionen nicht wirklich weiter, da die <code>dispatch</code>-Methode eines <strong>Stores</strong> ja zwingend eine <strong>Action</strong> erwartet, die, wie wir bereits gelernt haben ein simples und einfaches Objekt mit einer <code>type</code>-Eigenschaft ist.</p>
<p>Hier kommt jetzt das <strong>Middleware</strong>-Konzept von <strong>Redux</strong> ins Spiel, und mit ihr insbesondere die <strong>Redux Thunk Middleware</strong>. Doch der Reihe nach.</p>
<p>Die <code>createStore</code>-Funktion aus dem <code>redux</code>-Paket, die wir etwas weiter oben bereits benutzt haben um verschiedene Stores zu erzeugen, verarbeitet bis zu drei Parameter:</p>
<ul>
<li>Die <strong>Reducer</strong>-Funktion, die als einziger Parameter zwingend angegeben werden <strong>muss</strong> und sich in Verbindung mit den ausgelösten <strong>Actions</strong> um die Mutation unseres <strong>States</strong> kümmert indem sie mit jeder ausgelösten <strong>Action</strong> einen <strong>State</strong> zurückgibt.</li>
<li>Einen <strong>initialen State</strong>, der bspw. beim Initialisieren des Stores bereits mit Daten befüllt sein kann. Dieser initiale State wird bei der Initialisierung des Stores auch auch die <strong>Reducer</strong>-Funktion übergeben.</li>
<li>Eine sog. <strong>Enhancer</strong>-Funktion (zu dt. etwa: <em>Erweiterungs-Funktion</em>), mit der wir unseren erzeugten Store um eigene Funktionalität erweitern können. Wie etwa die eben angesprochene <strong>Middleware</strong>.</li>
</ul>
<p>Bekommt die <code>createStore</code>-Funktion zwei Parameter übergeben, behandelt sie den zweiten Parameter als <strong>Enhancer</strong> wenn der Parameter eine <strong>Funktion</strong> ist. Andernfalls wird der zweite Parameter als <strong>initialer State</strong> an die <strong>Reducer</strong>-Funktion übergeben.</p>
<p>Eine <strong>Middleware</strong> in <strong>Redux</strong> legt sich dabei um die <code>dispatch</code>-Methode, fängt Aufrufe an diese ab, erlaubt es die aufgerufene <strong>Action</strong> zu modifizieren <em>bevor</em> diese an den <strong>Reducer</strong> übergeben wird und gibt am Ende ihrer Ausführung eine neue <code>dispatch</code>-Funktion zurück. Möchten wir nun bspw. asynchrone Funktionen bzw. Promises als Parameter an die <code>dispatch()</code>-Methode übergeben, können wir den <strong>Store-Enhancer</strong> nutzen um <strong>Middleware</strong> zu registrieren, die es uns erlaubt genau dies zu tun. Die bekannteste dieser Art ist besagte <strong>Thunk Middleware</strong>.</p>
<p>Zur Installation:</p>
<pre><code class="hljs bash language-bash">npm install redux-thunk</code></pre>
<p>oder in Yarn:</p>
<pre><code class="hljs bash language-bash">yarn add redux-thunk</code></pre>
<p>Ist die <strong>Thunk Middleware</strong> installiert, müssen wir sie über die <strong>Redux</strong>-eigene <code>applyMiddleware()</code>-Funktion beim <strong>Enhancer</strong> <em>registrieren</em>. Dazu importieren wir die <strong>Middleware</strong> und die <code>applyMiddleware()</code>-Funktion direkt aus <strong>Redux</strong> und übergeben ihr jede <strong>Middleware</strong> die wir nutzen wollen als eigenen Parameter. In unserem Fall ist das erst einmal nur <code>thunk</code>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> { applyMiddleware, createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;
<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-thunk'</span>;

<span class="hljs-comment">// ...</span>

<span class="hljs-keyword">const</span> store = createStore(reducer, applyMiddleware(thunk));</code></pre>
<p>Durch die Einbindung der <strong>Thunk-Middleware</strong> können wir nun <strong>Action Creator</strong> schreiben, die <em>asynchronen</em> Code ausführen und ihre <strong>Actions</strong> dann <em>dispatchen</em> wenn ein Ergebnis vorliegt. Eine <strong>Thunk</strong>-Funktion ist dabei ein <strong>Action Creator</strong>, der selbst wiederum eine Funktion zurückgibt, deren beiden Parameter eine<code>dispatch()</code> und <code>getState()</code> Funktion sind. In der <strong>Thunk Action Creator</strong>-Funktion können wir dann selbst entscheiden wann der Zeitpunkt gekommen ist um unsere Action zu <em>dispatchen</em>.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> delayedAdd = <span class="hljs-function">(<span class="hljs-params">newTodo</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">dispatch, getState</span>) =&gt;</span> {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">return</span> dispatch({
        <span class="hljs-attr">type</span>: <span class="hljs-string">'ADD_TODO'</span>,
        <span class="hljs-attr">payload</span>: newTodo,
      });
    }, <span class="hljs-number">500</span>);
  };
};

store.dispatch(
  delayedAction({
    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">text</span>: <span class="hljs-string">'Thunk Actions erklären'</span>,
    <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>,
  })
);</code></pre>
<p>In diesem Beispiel erzeugen wir einen <code>delayedAdd</code> <strong>Action Creator</strong>. Dieser erhält das neue Todo-Element übergeben und gibt dann eine neue Funktion in der Form <code>(dispatch, getState) =&gt; {}</code> zurück. Die <strong>Thunk-Middleware</strong> sorgt dann dafür, dass dieser Funktion die <code>dispatch()</code> und <code>getState()</code> Funktionen entsprechend hereingereicht werden. Nach einer Verzögerung von, in diesem Beispiel, 500 ms rufen wir die <code>dispatch()</code>-Funktion mit der <code>ADD_TODO</code> <strong>Action</strong> auf und fügen das neue Objekt hinzu.</p>
<p>Um die Action zu <em>dispatchen</em> können wir den <em>asynchronen</em> <strong>Action Creator</strong> nun genauso verwenden wie wir auch bisher unsere <em>synchronen</em> <strong>Action Creators</strong> <em>dispatched</em> haben, nämlich durch das Übergeben der aufgerufenen Funktion an die <code>dispatch()</code>-Funktion des <strong>Store</strong>: <code>store.dispatch(ActionCreator)</code>. Die Thunk-Middleware erkennt dann, dass es sich um eine <strong>Thunk</strong>-Funktion handelt, führt sie aus und reicht ihr die beiden Argumente <code>dispatch</code> und <code>getState</code> hinein.</p>
<p>Wer bereits mit der <strong>Arrow Function Syntax</strong> aus ES2015 vertraut ist kann das Ganze übrigens auch noch weiter abkürzen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> delayedAdd = <span class="hljs-function">(<span class="hljs-params">newTodo</span>) =&gt;</span> (dispatch, getState) =&gt; {
  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> dispatch({
      <span class="hljs-attr">type</span>: <span class="hljs-string">'ADD_TODO'</span>,
      <span class="hljs-attr">payload</span>: newTodo,
    });
  }, <span class="hljs-number">500</span>);
};</code></pre>
<p>Hier geben wir über die verkürzte <strong>Arrow Function</strong> mit <strong>impliziten Rückgabewert</strong> direkt die dann von der <strong>Thunk-Middleware</strong> aufgerufene Funktion zurück, ohne das <code>return</code> Schlüsselwort dafür verwenden zu müssen. Das spart noch einmal zwei Zeilen Code, macht den Code aber gerade zu Beginn etwas schwieriger zu verstehen.</p>
<h3 id="ein-typisches-beispiel-für-asynchrone-actions-aus-der-praxis">Ein typisches Beispiel für asynchrone Actions aus der Praxis</h3>
<p>In vielen Anwendungen in denen mit Schnittstellen (APIs) gearbeitet wird ist es ein gängiges Muster den Benutzer auf den Lade-Status hinzuweisen sobald Daten von der API bezogen werden. Bspw. über einen grafischen Spinner oder auch nur durch einen Text-Hinweis wie etwa <em>„Daten werden geladen“</em>. Hier eignet sich eine entsprechende <strong>Thunk Action</strong> hervorragend um diesen Anwendungsfall mit einem entsprechenden <strong>Reducer</strong> abzudecken.</p>
<p>Dazu erstellen wir im <strong>Reducer</strong> drei Fälle in denen wir auf die folgenden <strong>Actions</strong> regieren:</p>
<ul>
<li><code>FETCH_REPOS_REQUEST</code>, um zu Beginn des Netzwerk-Requests etwa Fehler aus voran gegangenen Requests zurück zu setzen und um unseren Lade-Status zu initiieren,</li>
<li><code>FETCH_REPOS_SUCCESS</code> , die wir bei erfolgreich erfolgtem Request aufrufen und die das Ergebnis des Requests bekommt sowie das Datum der letzten Aktualisierung dieser Daten, sowie</li>
<li><code>FETCH_REPOS_FAILURE</code> mit der wir auf aufgetretene Fehler reagieren und bspw. einen <code>error</code> Flag setzen um den Benutzer davon in Kenntnis zu setzen, dass sein Request fehlgeschlagen ist.</li>
</ul>
<p>In Form von Code könnte dies dann bspw. so aussehen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> { applyMiddleware, createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;
<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-thunk'</span>;
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;

<span class="hljs-keyword">const</span> initialState = <span class="hljs-built_in">Object</span>.freeze({
  <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">items</span>: [],
  <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">lastUpdated</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">selectedAccount</span>: <span class="hljs-string">'manuelbieh'</span>,
});

<span class="hljs-keyword">const</span> rootReducer = <span class="hljs-function">(<span class="hljs-params">state = initialState, action</span>) =&gt;</span> {
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'FETCH_REPOS_REQUEST'</span>: {
      <span class="hljs-keyword">return</span> {
        ...state,
        <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>,
      };
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'FETCH_REPOS_SUCCESS'</span>: {
      <span class="hljs-keyword">return</span> {
        ...state,
        <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">items</span>: action.payload.items,
        <span class="hljs-attr">lastUpdated</span>: action.payload.lastUpdated,
      };
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'FETCH_REPOS_FAILED'</span>: {
      <span class="hljs-keyword">return</span> {
        ...state,
        <span class="hljs-attr">isFetching</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">error</span>: action.payload,
      };
    }
    <span class="hljs-keyword">default</span>: {
      <span class="hljs-keyword">return</span> state;
    }
  }
};

<span class="hljs-keyword">const</span> fetchGithubRepos = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (dispatch, getState) =&gt; {
  dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'FETCH_REPOS_REQUESTED'</span> });
  <span class="hljs-keyword">const</span> state = getState();
  axios
    .get(<span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">${state.selectedAccount}</span>/repos`</span>)
    .then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
      dispatch({
        <span class="hljs-attr">type</span>: <span class="hljs-string">'FETCH_REPOS_SUCCESS'</span>,
        <span class="hljs-attr">payload</span>: {
          <span class="hljs-attr">lastUpdated</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
          <span class="hljs-attr">items</span>: response.data,
        },
      });
    })
    .catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
      dispatch({
        <span class="hljs-attr">type</span>: <span class="hljs-string">'FETCH_REPOS_FAILURE'</span>,
        <span class="hljs-attr">error</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">payload</span>: error.response.data,
      });
    });
};

<span class="hljs-keyword">const</span> store = createStore(rootReducer, applyMiddleware(thunk));

store.dispatch(fetchGithubRepos());</code></pre>
<p><em>Dispatchen</em> wir hier den <code>fetchGithubRepos()</code> <strong>Action Creator</strong> passiert folgendes:</p>
<p>Zunächst erkennt die <strong>Thunk-Middleware</strong>, dass es sich nicht um eine einfache <strong>Action</strong> (also ein Objekt) sondern um eine Funktion handelt, führt diese aus in der Form <code>Action()(dispatch, getState)</code>. Der <strong>Action Creator</strong> erhält die <code>dispatch</code>-Funktion übergeben um selbst wiederum <strong>Actions</strong> aus der <strong>Action Creator</strong> Funktion heraus <em>dispatchen</em> zu können.</p>
<p>Im <strong>Action Creator</strong> <em>dispatchen</em> wir nun zunächst einmal die <code>FETCH_REPOS_REQUESTED</code> Action. Der <strong>Reducer</strong> reagiert auf die Action, erzeugt ein neues <strong>State-Objekt</strong> indem der <em>bestehende</em> <strong>State</strong> per <strong>ES2015+ Spread Operator</strong> in ein neues Objekt kopiert wird und außerdem einen ggf. existierenden <code>error</code> zurücksetzt auf <code>null</code>. Gleichzeitig wird der State mittels <code>isFetching</code> davon in Kenntnis gesetzt, dass nun ein Request folgen wird. Das ist hier etwas Geschmackssache und so bevorzugen es einige die <code>error</code>-Eigenschaft erst dann wieder auf <code>null</code> zu setzen, wenn der anstehende Request auch tatsächlich erfolgreich war.</p>
<p>Für den Request holen wir uns nun mittels <code>getState()</code> zunächst den <em>aktuellen</em> <strong>State</strong>, aus diesem holen wir uns aus <code>selectedAccount</code> dann den ausgewählten Account, zu dem wir uns anschließend über den API Request die GitHub-Repos besorgen. Wir starten den Request (und nutzen hier wie schon in früheren Beispielen Axios zur Vereinfachung) und reagieren auf zwei mögliche Fälle:</p>
<ul>
<li>Der Request ist erfolgreich und wir beziehen Daten von der GitHub API. Wir <em>dispatchen</em> dann die nächste <strong>Action</strong>, <code>FETCH_REPOS_SUCCESS</code>, übergeben die aktuelle Uhrzeit (die wir später bspw. für Caching oder automatische Reloads benutzen können) sowie das Array mit den Repos, die sich in <code>response.data</code> verbirgt. Da der Request außerdem nicht mehr aktiv ist, setzen wir <code>isFetching</code> wieder zurück auf <code>false</code>.</li>
<li>Der Request schlägt fehlt. In diesem Fall <em>dispatchen</em> wir die <code>FETCH_REPOS_FAILURE</code> Action und übergeben die Fehlermeldung die Axios hier in <code>error.response.data</code> bereithält als Payload. Auch hier setzen wir <code>isFetching</code> wieder zurück auf <code>false</code>, da der Request auch hier beendet ist, wenn auch mit einem für uns unschönen Ergebnis, nämlich einem Fehler.</li>
</ul>
<p>Unser State enthält nun die GitHub-Repos des laut <code>state.selectedAccount</code> ausgewählten Benutzers wenn der Request erfolgreich war oder eine Fehlermeldung wenn er es nicht war. Auf beide Fälle könnten wir nun in unserem User Interface entsprechend reagieren!</p>
<h3 id="debugging-mit-den-redux-devtools">Debugging mit den Redux Devtools</h3>
<p>Zum Inspizieren des Stores haben wir diverse Möglichkeiten, so gibt es bspw. eine praktische <strong>Logger-Middleware</strong>, die uns für jede dispatchte <strong>Action</strong> den vorherigen State, die Action selbst und den neuen State in die Browser-Console logged: <a href="https://github.com/LogRocket/redux-logger">https://github.com/LogRocket/redux-logger</a></p>
<p>Wir können selbstverständlich jederzeit auch manuell mittels <code>console.log(store.getState())</code> den aktuellen State ausgeben, wobei das mühsam ist und insbesondere bei asynchronen Actions manchmal etwas verwirrend sein kann.</p>
<p>Und dann gibt es die <strong>Redux Devtools</strong>. Diese kommen als Browser-Extension daher und integrieren sich nahtlos in die Developer Tools in Chrome und Firefox, auch mit künftigen Edge Versionen ist die Verwendung der <strong>Redux Devtools</strong> möglich sobald die Browser-Engine erst einmal final auf Chromium umgestellt wurde. Gefunden werden können die Extensions in den jeweiligen Add-On Stores:</p>
<ul>
<li>Chrome: <a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd">https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd</a></li>
<li>Firefox: <a href="https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/">https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/</a></li>
</ul>
<p>Sind die <strong>Redux Devtools</strong> erst einmal installiert, bekommen die Developer Tools im Browser einen neuen Tab <strong>„Redux“</strong>, unter dem wir sie finden können. Doch zur Verwendung müssen wir einige Vorkehrungen in unserem Code treffen. Wir müssen sie als weiteren <strong>Enhancer</strong> zu unserem <strong>Store</strong> hinzufügen.</p>
<p class="has-image"><span><img src="./assets/.gitbook/redux-devtools.png" alt="Browser Devtools mit installiertem Redux Addon" /><span class="caption">Browser Devtools mit installiertem Redux Addon</span></span></p>
<p>Die <strong>Redux Devtools</strong> registrieren sich mit zwei eigenen globalen Variable auf dem <code>window</code>-Objekt im Browser: <code>window.REDUX_DEVTOOLS_EXTENSION</code> und <code>window.REDUX_DEVTOOLS_EXTENSION_COMPOSE</code>. Nutzen wir keine eigenen Store Enhancer, wie beispielsweise <code>applyMiddleware()</code> um bspw. Middlewares wie Thunk zu registrieren ist die Sache recht simpel: wir schauen mittels Logical AND Operator (<code>&amp;&amp;</code>) ob die <strong>Redux Devtools</strong> installiert sind und übergeben wenn das der Fall ist einen Aufruf der <code>window.REDUX_DEVTOOLS_EXTENSION</code> an die <code>createStore()</code>-Funktion:</p>
<pre><code class="hljs javascript language-javascript">createStore(
  rootReducer,
  <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__()
);</code></pre>
<p>Damit sehen wir nun automatisch jede ausgelöste <strong>Action</strong> in den <strong>Devtools</strong>, können uns in Detail anschauen welche <strong>Action</strong> mit welcher <strong>Payload</strong> <em>dispatched</em> wurde und können sogar manuell <strong>Actions</strong> <em>dispatchen</em>. Außerdem gibt es die Möglichkeit des <strong>Time Travelings</strong>, also dem „Zurückblättern“ zu vorherigen Zuständen des Stores. Dies ist mitunter sehr hilfreich beim Debugging.</p>
<p>Hier ist es besonders wichtig dass unsere <strong>Reducer</strong> <em>Pure Functions</em> sind, damit sie beim Durchblättern durch die Historie des <strong>Stores</strong> auch jedesmal wieder erneut den gleichen <strong>State</strong> erzeugen wie beim ursprünglichen Aufruf. Ansonsten läuft man möglicherweise einem Bug hinterher, der einfach nicht reproduzierbar ist, da er mit jedem Aufruf einen unterschiedlichen <strong>State</strong> erzeugt.</p>
<p>Wird wie bei unserem letzten Beispiel bereits eine Enhancer-Funktion verwendet, nutzen wir stattdessen die <code>window.REDUX_DEVTOOLS_EXTENSION_COMPOSE</code> Funktion. Diese Funktion ist eine <code>compose</code>-Funktion die es ermöglicht <em>mehrere</em> <strong>Enhancer</strong>-Funktionen zu einer <em>einzelnen</em> zu kombinieren die dann der Reihe nach aufgerufen werden. Also das gleiche Prinzip, wie wir es schon bei der <code>combineReducers()</code>-Methode für <strong>Reducer</strong> kennengelernt haben.</p>
<p>Auch Redux selbst bietet mit <code>compose</code> eine solche Funktion um mehrere Enhancer-Funktionen zu einer einzelnen zu kombinieren. Diese importieren wir der Einfachheit halber um eine neue, eigene <code>composeEnhancer()</code>-Funktion zu erstellen die nun von einer Bedingung abhängt: sind die Redux Devtools installiert, nutzt sie die <code>REDUX_DEVTOOLS_EXTENSION_COMPOSE</code>-Funktion um die <strong>Devtools</strong> dem <strong>Store-Enhancer</strong> zuzufügen. Sind sie nicht installiert nutzen wir stattdessen die Redux eigene <code>compose()</code>-Funktion um eine Funktion von gleicher Signatur zu erzeugen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> { applyMiddleware, compose, createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;
<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">'thunk-middleware'</span>;

<span class="hljs-keyword">const</span> composeEnhancers =
  <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
    ? <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({})
    : compose;

<span class="hljs-comment">// ...</span>

<span class="hljs-keyword">const</span> store = createStore(
  rootReducer,
  composeEnhancers(applyMiddleware(thunk))
);</code></pre>
<p>Wer sich jetzt hier von den ganzen Funktionen und Begrifflichkeiten überwältigt fühlt den kann ich etwas trösten: das ist in der Praxis normal gar nicht so sehr von Relevanz das alles zu verstehen und zu beherrschen. Ich selbst nutze die <strong>Redux Devtools</strong> in jedem Projekt in dem ich <strong>Redux</strong> verwende und noch immer muss ich jedesmal erneut nachschlagen, wie genau das doch gleich funktionierte mit der Einbindung der Devtools. Speziell dieser Text dient daher also primär dazu das Bewusstsein dafür zu schaffen wie das Debugging von <strong>Redux-Stores</strong> möglich ist und denjenigen, die gern genaueres darüber wissen möchten einen kleinen Leitfaden mit an die Hand zu geben.</p>
<h3 id="verwendung-von-redux-mit-react">Verwendung von Redux mit React</h3>
<p>Nun haben wir bereits ziemlich genau kennengelernt wie wir einen neuen <strong>Store</strong> erzeugen, wie wir <strong>Actions</strong> <em>dispatchen</em>, welche Rolle der <strong>Reducer</strong> spielt und wie wir <strong>Middleware</strong> einsetzen. Doch wie bringen wir das jetzt unter einen Hut mit <strong>React?</strong></p>
<p>Hier kommt nun das <code>react-redux</code> Paket ins Spiel, das gleich zu Beginn des Kapitels bereits einmal angerissen wurde. Dies sind die <em>„offiziellen React Bindings für Redux“</em>, also die offizielle Anbindung von <strong>Redux</strong> an <strong>React</strong>, die von den Redux-Entwicklern gepflegt wird und ursprünglich von Dan Abramov entwickelt wurde, der inzwischen auch Teil des offiziellen React Core Teams ist.</p>
<p>Das Paket besteht aus im wesentlichen aus lediglich zwei React-Komponenten, bzw. einer Komponente und einer Funktion, die eine <strong>Higher Order Component</strong> erzeugt (plus einer weiteren Funktion, die von React Redux selbst intern verwendet wird, in der täglichen Arbeit aber praktisch nicht von Relevanz ist). Da wäre zum einen die <code>Provider</code>-Komponente, die wir um den Teil unseres Komponenten-Baums legen, innerhalb dessen wir später auf den gemeinsam genutzten <strong>Store</strong> zugreifen wollen, sowie die <code>connect()</code>-Funktion, die eine <strong>Higher Order Component</strong> zurückgibt und mit der wir einzelne Komponenten dann mit dem Store zu <em>verbinden</em> können.</p>
<h4 id="die-provider-komponente">Die Provider Komponente</h4>
<p>Da eine Anwendung in den meisten Fällen nur einen <strong>Store</strong> besitzt und alle Komponenten dieser Anwendung auf genau diesen Zugriff bekommen sollen, wird die <code>Provider</code>-Komponente üblicherweise sehr weit oben in der Komponenten-Hierarchie eingesetzt. Nicht selten als die erste und damit oberste Komponente überhaupt. Die <code>Provider</code>-Komponente bekommt dabei einen <strong>Redux Store</strong> als <code>store</code>-Prop übergeben und enthält darüber hinaus Kind-Elemente. Alle ihre Kind-Elemente haben dann entsprechend die Möglichkeit auf den in der <code>store</code>-Prop angegebenen <strong>Store</strong> zuzugreifen, diesen also zu lesen und durch das Auslösen von <strong>Actions</strong> zu verändern:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;
<span class="hljs-keyword">import</span> { Provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;

<span class="hljs-keyword">const</span> dummyReducer = <span class="hljs-function">(<span class="hljs-params">state = {}, action</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> state;
};

<span class="hljs-keyword">const</span> store = createStore(dummyReducer);

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hier haben wir nun Zugriff auf den erzeugten Redux-Store<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
);

ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
);</code></pre>
<p>Statt wie in den meisten anderen Beispielen in diesem Buch übergeben wir hier der <code>ReactDOM.render()</code>-Methode diesmal nicht nur das <code>&lt;App /&gt;</code>-Element, sondern umschließen dieses außerdem mit der <code>Provider</code>-Komponente, die den zuvor erzeugten (Dummy-)Store übergeben bekommt.</p>
<p>Die <code>Provider</code>-Komponente kann auch ineinander geschachtelt werden, Komponenten die mit dem Store verbunden werden nutzen dann immer den <strong>Store</strong> der <em>nächsthöheren</em> <code>Provider</code>-Komponente. Ein solches Vorgehen ist aber eher unüblich und man würde in einer solchen Situation, in der zwei Stores parallel existieren sollen, wohl eher die Reducer beider Stores über die <code>combineReducer()</code>-Funktion zu einem gemeinsamen Store verbinden um schließlich wieder nur noch ein gemeinsames <code>Provider</code>-Element für alle Komponenten zu nutzen.</p>
<h4 id="komponenten-via-connect-funktion-mit-dem-store-verbinden">Komponenten via connect-Funktion mit dem Store verbinden</h4>
<p>Dies war noch die eher leichtere Übung. Etwas umständlicher wird es beim zweiten Teil, nämlich dem <strong>Verbinden</strong> einer React-Komponente mit dem <strong>Redux Store</strong> über besagte <code>connect()</code>-Funktion. Diese kann bis zu 4 Parameter erhalten, wovon die ersten 3 Funktionen sind, die selbst wiederum zum Teil bis zu 3 Parameter übergeben bekommen können. Au weia. Die gute Nachricht: in den deutlich überwiegenden Fällen benötigen wir in der Praxis maximal 2 der 4 Parameter und bei diesen beiden auch jeweils nur jeweils den ersten Parameter. Arbeiten wir uns der Reihe nach daran ab, von simpel zu komplex.</p>
<p>Die grundsätzliche Funktionssignatur ist die folgende:</p>
<pre><code class="hljs javascript language-javascript">connect(
  mapStateToProps,
  mapDispatchToProps,
  mergeProps,
  options
);</code></pre>
<p>Zuerst einmal erzeugt der Aufruf der <code>connect()</code>-Funktion eine <strong>Higher Order Component</strong>. Diese können wir nutzen, um bestimmte Teile des States aus dem Store an die von dieser umschlossenen Komponente zu übergeben. Um zu entscheiden welcher Teil des States an die Komponente übergeben wird nutzen wir den ersten Parameter, die meist als <code>mapStateToProps</code>-Funktion bezeichnet wird, so, wie sie auch in der Doku genannt wird.</p>
<h4 id="zugriff-auf-teile-des-globalen-states-über-mapstatetoprops">Zugriff auf Teile des globalen States über mapStateToProps</h4>
<p>Die <code>mapStateToProps</code>-Funktion bekommt als ersten Parameter den kompletten <strong>State</strong> von Redux übergeben, als zweiten, optionalen Parameter die in der Doku als <code>ownProps</code> bezeichneten „eigenen“ Props der Komponente. Also diejenigen, die ggf. an die erzeugte HOC übergeben werden. Je nachdem ob nur einer oder zwei Parameter übergeben werden, wird die Funktion dann entweder immer nur dann aufgerufen wenn sich etwas im <strong>Redux State</strong> ändert <em>oder</em> auch dann, wenn sich die <strong>Props</strong> die der Komponente ggf. übergeben werden ändern.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> mapStateToProps = <span class="hljs-function">(<span class="hljs-params">state, ownProps</span>) =&gt;</span> {
  <span class="hljs-comment">// ...</span>
};</code></pre>
<p>In beiden Fällen wird von der Funktion ein <strong>Objekt</strong> als Rückgabewert erwartet. Die Eigenschaften dieses Objekts werden dann als die sog. <code>stateProps</code> an die Komponente übergeben. Erinnern wir uns nochmal zurück an unseren Todo-Store von etwas weiter oben. Als Beispiel möchten wir nun einer Komponente die Todos vorgefiltert nach ihrem Status (erledigt oder nicht erledigt) übergeben, sowie die Anzahl der Todos insgesamt.</p>
<p>Unsere <code>mapStateToProps</code>-Funktion sieht dann etwa so aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> mapStateToProps = <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">openTodos</span>: state.todos.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> todo.completed !== <span class="hljs-literal">true</span>),
    <span class="hljs-attr">completedTodos</span>: state.todos.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> todo.completed === <span class="hljs-literal">true</span>),
    <span class="hljs-attr">totalCount</span>: state.todos.length,
  };
};</code></pre>
<p>Die Eigenschaften dieses Objekts, also <code>openTodos</code>, <code>completedTodos</code> und <code>totalCount</code> werden dann als <strong>Props</strong> an die umschlossene Komponente übergeben. Dies passiert indem wir der connect()-Funktion die mapStateToProps Funktion übergeben. Diese gibt uns dann eine HOC zurück, der wir wiederum die Komponente übergeben, in der wir auf unsere drei Props aus dem State zugreifen wollen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> ConnectedTodoList = connect(mapStateToProps)(TodoList);</code></pre>
<p>Nutzen wir nun im <strong>JSX</strong> ein <code>&lt;ConnectedTodoList /&gt;</code> Element und befindet sich dieses auch innerhalb eines von der <code>Provider</code>-Komponente umschlossenen Teils der Anwendung, wird die <code>TodoList</code> gerendert mit den obigen Props aus dem globalen <strong>Redux Store:</strong></p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> { combineReducers, createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;
<span class="hljs-keyword">import</span> { Provider, connect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;
<span class="hljs-keyword">import</span> user <span class="hljs-keyword">from</span> <span class="hljs-string">'./store/user/reducer'</span>;
<span class="hljs-keyword">import</span> todos <span class="hljs-keyword">from</span> <span class="hljs-string">'./store/todos/reducer'</span>;

<span class="hljs-keyword">const</span> rootReducer = combineReducers({ todos, user });

<span class="hljs-keyword">const</span> store = createStore(rootReducer);

<span class="hljs-keyword">const</span> TodoList = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
      {props.totalCount} Todos. Davon {props.completedTodos.length}{' '}
      abgeschlossen und {props.openTodos.length} noch offen.
    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
);

<span class="hljs-keyword">const</span> mapStateToProps = <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">openTodos</span>: state.todos.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> todo.completed !== <span class="hljs-literal">true</span>),
    <span class="hljs-attr">completedTodos</span>: state.todos.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> todo.completed === <span class="hljs-literal">true</span>),
    <span class="hljs-attr">totalCount</span>: state.todos.length,
  };
};

<span class="hljs-keyword">const</span> ConnectedTodoList = connect(mapStateToProps)(TodoList);

ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ConnectedTodoList</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>,
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>)
);</code></pre>
<p>Hier rendern wir eine ziemlich spartanische <code>TodoList</code>-Komponente, die uns zu Demonstrationszwecken lediglich die Anzahl aller Todos, sowie die Anzahl der offenen und bereits erledigten Todos anzeigt.</p>
<p>Über den zweiten möglichen Parameter der <code>mapStateToProps</code>-Funktion, üblicherweise als <code>ownProps</code> bezeichnet, ist es möglich innerhalb der Funktion auf die <strong>Props</strong> der Komponente zuzugreifen um bspw. darüber entscheiden zu können welchen Teil des States wir in die verbundene Komponente hereinreichen wollen. Möchten wir also bspw. entweder immer nur die offenen Todos <em>oder</em> die geschlossenen Todos zurückgeben, und soll die Entscheidung darüber auf einer Prop basieren, könnte der entsprechende Teil so aussehen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> mapStateToProps = <span class="hljs-function">(<span class="hljs-params">state, ownProps</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> filteredTodos =
    ownProps.type === <span class="hljs-string">'completed'</span>
      ? state.todos.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> todo.completed === <span class="hljs-literal">true</span>)
      : state.todos.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> todo.completed !== <span class="hljs-literal">true</span>);

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">totalCount</span>: state.todos.length,
    <span class="hljs-attr">todos</span>: filteredTodos,
  };
};

<span class="hljs-keyword">const</span> ConnectedTodoList = connect(mapStateToProps)(TodoList);

ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ConnectedTodoList</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"completed"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span>,
  document.getElementById('root')
);</span></code></pre>
<p>Über <code>ownProps.type</code> schauen wir zunächst, ob wir die erledigten Todos anzeigen wollen oder die offenen. Anschließend filtern wir <code>state.todos</code> entsprechend und geben jeweils nur die gewünschten Todos aus dem State zurück. Da wir nun die übergebenen Todos nicht mehr nach Typ unterteilen sondern in der <code>mapStateToProps</code>-Funktion bereits eine Vorauswahl treffen, geben wir die Todos unter einer allgemeinen <code>todos</code>-Eigenschaft zurück, wodurch wir nun via <code>props.todos</code> auf diese Zugreifen können innerhalb der Komponente.</p>
<p>Über die <code>mapStateToProps()</code>-Funktion erhalten wir also Lese-Zugriff auf den kompletten <strong>State</strong> aus unserem <strong>Redux Store</strong>. Sämtliche Daten die wir in einer Komponente nutzen wollen geben wir hier als Objekt zurück. Die entsprechende React-Komponente wird dann immer nur neu gerendert wenn sich auch tatsächlich die relevanten Daten im Store geändert haben. Dann wird entsprechend ein Rerendering der verbundenen Komponente ausgelöst.</p>
<h4 id="actions-dispatchen-über-mapdispatchtoprops">Actions dispatchen über mapDispatchToProps</h4>
<p>Weiter geht es mit dem zweiten Parameter für die <code>connect()</code>-Funktion: <code>mapDispatchToProps</code>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> mapDispatchToProps = <span class="hljs-function">(<span class="hljs-params">dispatch, ownProps</span>) =&gt;</span> {
  <span class="hljs-comment">// ...</span>
};</code></pre>
<p>oder alternativ:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> mapDispatchToProps = {
  <span class="hljs-comment">// ...</span>
};</code></pre>
<p>Während wir mittels <code>mapStateToProps</code> <strong>lesend</strong> auf den Store zugreifen, erlaubt es uns <code>mapDispatchToProps</code> durch das Dispatchen von Actions <strong>schreibend</strong> auf den Store einzuwirken. Die Funktionssignatur ist dabei sogar erst einmal recht ähnlich zu <code>mapStateToProps</code>, nur bekommen wir als ersten Parameter eben nicht den State übergeben, sondern die <code>dispatch</code>-Methode des Stores, mit dem wir uns verbinden. Der zweite Parameter entspricht auch hier den <code>ownProps</code>, also den <strong>Props</strong>, die der Komponente selbst übergeben werden. Als kleine Besonderheit ist es möglich ein <code>mapDispatchToProps</code>-<strong>Objekt</strong> statt einer Funktion an den <code>connect()</code>-Aufruf zu übergeben. Doch dazu später mehr. Schauen wir uns zuerst einmal an wie die <code>mapDispatchToProps</code>-<strong>Funktion</strong> verwendet wird.</p>
<p>Dazu wollen wir unsere <code>TodoList</code>-Komponente um die Möglichkeit erweitern neue Todos hinzuzufügen, als erledigt zu markieren oder ganz aus der Liste zu löschen. Die entsprechenden <strong>Actions</strong> sind im Beispiel über <strong>Reducer</strong> weiter oben in diesem Kapitel bereits vorgesehen: <code>ADD_TODO</code>, <code>REMOVE_TODO</code> und <code>CHANGE_TODO_STATUS</code>. Nun wollen wir es ermöglichen, dass ein Benutzer der mit unserer Anwendung interagiert, diese <strong>Actions</strong> auslösen kann:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Helper-Funktion zur Erzeugung einer (hoffentlich ;)) eindeutigen ID</span>
<span class="hljs-keyword">const</span> getPseudoRandomId = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
  <span class="hljs-built_in">Math</span>.random()
    .toString(<span class="hljs-number">36</span>)
    .slice(<span class="hljs-number">-6</span>);

<span class="hljs-keyword">const</span> mapDispatchToProps = <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">addTodo</span>: <span class="hljs-function">(<span class="hljs-params">text</span>) =&gt;</span>
      dispatch({
        <span class="hljs-attr">type</span>: <span class="hljs-string">'ADD_TODO'</span>,
        <span class="hljs-attr">payload</span>: {
          <span class="hljs-attr">id</span>: getPseudoRandomId(),
          text,
        },
      }),
    <span class="hljs-attr">removeTodo</span>: <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span>
      dispatch({
        <span class="hljs-attr">type</span>: <span class="hljs-string">'REMOVE_TODO'</span>,
        <span class="hljs-attr">payload</span>: id,
      }),
    <span class="hljs-attr">changeStatus</span>: <span class="hljs-function">(<span class="hljs-params">id, done</span>) =&gt;</span>
      dispatch({
        <span class="hljs-attr">type</span>: <span class="hljs-string">'CHANGE_TODO_STATUS'</span>,
        <span class="hljs-attr">payload</span>: {
          id,
          done,
        },
      }),
  };
};</code></pre>
<p>Hier geben wir ein Objekt mit den drei Eigenschaften <code>addTodo</code>, <code>removeTodo</code> und <code>changeStatus</code> zurück, die unter jeweils genau diesem Namen an eine verbundene Komponente, also in unserem Fall an die <code>TodoList</code>, in ihren <strong>Props</strong> übergeben wird. Dazu übergeben wir die <code>mapStateToProps()</code>-Funktion als zweiten Parameter an <code>connect()</code>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> ConnectedTodoList = connect(
  mapStateToProps,
  mapDispatchToProps
)(TodoList);</code></pre>
<p>Die <strong>Actions</strong>, die wir hier in <code>mapDispatchToProps</code> inline übergeben, werden für gewöhnlich in entsprechende <strong>Action Creator</strong> Funktionen extrahiert. Diese sorgen für bessere Lesbarkeit, sind leichter testbar und normalerweise auch verständlicher:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> addTodo = <span class="hljs-function">(<span class="hljs-params">text</span>) =&gt;</span> ({
  <span class="hljs-attr">type</span>: <span class="hljs-string">'ADD_TODO'</span>,
  <span class="hljs-attr">payload</span>: {
    <span class="hljs-attr">id</span>: getPseudoRandomId(),
    text,
  },
});

<span class="hljs-keyword">const</span> removeTodo = <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> ({
  <span class="hljs-attr">type</span>: <span class="hljs-string">'REMOVE_TODO'</span>,
  <span class="hljs-attr">payload</span>: id,
});

<span class="hljs-keyword">const</span> changeStatus = <span class="hljs-function">(<span class="hljs-params">id, done</span>) =&gt;</span> ({
  <span class="hljs-attr">type</span>: <span class="hljs-string">'CHANGE_TODO_STATUS'</span>,
  <span class="hljs-attr">payload</span>: {
    id,
    done,
  },
});</code></pre>
<p>Unsere <code>mapStateToProps</code>-Funktion verkürzt sich dann und wird deutlich übersichtlicher:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> mapDispatchToProps = <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">addTodo</span>: <span class="hljs-function">(<span class="hljs-params">text</span>) =&gt;</span> dispatch(addTodo(text)),
    <span class="hljs-attr">removeTodo</span>: <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> dispatch(removeTodo(id)),
    <span class="hljs-attr">changeStatus</span>: <span class="hljs-function">(<span class="hljs-params">id, done</span>) =&gt;</span> dispatch(changeStatus(id, done)),
  };
};</code></pre>
<p>Doch diese Variante hat noch einen weiteren entscheidenden Vorteil: da wir hier einiges an Wiederholung im Code haben und Entwickler Wiederholungen natürlich möglichst vermeiden, bietet uns Redux eine Abkürzung. Stimmen die Funktionssignaturen der <strong>Action Creators</strong> mit denen der Funktionen überein, wie wir sie aus <code>mapDispatchToProps</code> zurückgeben, können wir unsere <strong>Action Creators</strong> als <strong>ES2015+ Shorthand Objekt</strong> zurückgeben! <strong>Redux</strong> setzt den notwendigen <code>dispatch()</code>-Aufruf dann von allein um alle Funktionen herum.</p>
<p>Mit dem folgenden Code erreichen wir also die identische Funktionalität wie mit dem Code aus dem vorherigen Beispiel:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> mapDispatchToProps = {
  addTodo,
  removeTodo,
  changeStatus,
};</code></pre>
<p>Doch Vorsicht: dies funktioniert tatsächlich nur wenn auch alle <strong>Action Creator</strong>-Funktionen mit den gleichen Funktionen aus der verbundenen React-Komponente aufgerufen werden und <code>mapDispatchToProps</code> genau in dieser Form als Objekt übergeben wird!</p>
<p>Durch die Verwendung der beiden Funktionen <code>mapStateToProps</code> und <code>mapDispatchToProps</code> ergibt sich ein Aufruf der in etwa dem folgenden entspricht:</p>
<pre><code class="hljs jsx language-jsx">&lt;TodoList todos={...} addTodo={...} removeTodo={...} changeStatus={...} /&gt;</code></pre>
<p>Alle Eigenschaften, die die wir aus <code>mapStateToProps</code> wie auch die, die wir aus <code>mapDispatchToProps</code> zurückgeben, werden an die Komponente übergeben, die mittels <code>connect()</code>-Funktion mit dem <strong>Store</strong> verbunden wird. In der Komponente (in obigen Beispiel in der <code>TodoList</code>-Komponente) können wir dann über die <strong>Props</strong> darauf zugreifen und durch den Aufruf der Funktionen aus <code>mapDispatchToProps</code> <strong>Actions</strong> <em>dispatchen</em> oder durch den Zugriff auf die Eigenschaften aus <code>mapStateToProps</code> den State aus dem <strong>Store</strong> auslesen.</p>
<p>Möchten wir nur <code>mapDispatchToProps()</code> an den <code>connect()</code>-Aufruf übergeben um aus einer Komponente heraus <strong>Actions</strong> dispatchen zu können, müssen jedoch den State selbst in der Komponente nicht lesen, kann als erster Parameter <code>null</code> übergeben werden:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> ConnectedTodoList = connect(
  <span class="hljs-literal">null</span>,
  mapDispatchToProps
)(TodoList);</code></pre>
<h4 id="die-stateprops-und-die-dispatchprops-zusammenführen-mit-mergeprops">Die StateProps und die DispatchProps zusammenführen mit mergeProps</h4>
<p>Der dritte Parameter deckt einen Fall ab, der in der Praxis eher äußerst selten vorkommt. Ich möchte ihn daher an dieser Stelle der Vollständigkeit halber nicht unerwähnt lassen, aber auch nicht zu sehr im Detail drauf eingehen. Hier handelt es sich um die <code>mergeProps()</code>-Funktion:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> mergeProps = <span class="hljs-function">(<span class="hljs-params">stateProps, dispatchProps, ownProps</span>) =&gt;</span> {
  <span class="hljs-comment">// ...</span>
};</code></pre>
<p>Die Funktion bekommt als ersten Parameter das Ergebnis von <code>mapStateToProps</code> und<code>mapDispatchToProps</code>, sowie abermals <code>ownProps</code> übergeben. Als Rückgabewert wird ein neues Objekt erwartet, dessen Eigenschaften dann ebenfalls über die Props an die mit dem Store verbundene Komponente übergeben werden.</p>
<p>Diese Funktion kann hilfreich sein wenn man bspw. ohne die Verwendung der <strong>Thunk Middleware</strong> gewisse <strong>Actions</strong> dispatchen möchte, die auf Daten aus dem State angewiesen sind. Auch denkbar wäre es, die <strong>Actions</strong> zu filtern, basierend auf dem State, so dass eine Komponente bspw. eine mögliche <code>updateProfile()</code> <strong>Action</strong> nicht hereingereicht bekommt wenn <code>state.profile</code> nicht existiert, der Benutzer also etwa nicht eingeloggt ist. Solche Bedingungen lassen sich aber innerhalb der Komponenten selbst in der Regel deutlich eleganter lösen.</p>
<h4 id="zuletzt-die-optionen-als-vierter-parameter-für-connect">Zuletzt: die Optionen als vierter Parameter für connect()</h4>
<p>Wer soweit ist den 4. Parameter zu benötigen, der sollte ziemlich genau wissen was er dort tut. Redux ist standardmäßig so optimiert, dass die Optionen nur in sehr seltenen Ausnahmefällen überhaupt benutzt werden müssen. So kann etwa ein eigener Context angegeben werden den Redux nutzen soll oder es können eigene Vergleichsfunktionen übergeben werden, mittels denen ermittelt wird ob eine Komponente neu gerendert werden soll oder nicht. Die komplette Liste der verfügbaren Optionen ist die folgende:</p>
<pre><code class="hljs javascript language-javascript">{
  <span class="hljs-attr">context</span>: <span class="hljs-built_in">Object</span>,
  <span class="hljs-attr">pure</span>: boolean,
  <span class="hljs-attr">areStatesEqual</span>: <span class="hljs-built_in">Function</span>,
  <span class="hljs-attr">areOwnPropsEqual</span>: <span class="hljs-built_in">Function</span>,
  <span class="hljs-attr">areStatePropsEqual</span>: <span class="hljs-built_in">Function</span>,
  <span class="hljs-attr">areMergedPropsEqual</span>: <span class="hljs-built_in">Function</span>,
  <span class="hljs-attr">forwardRef</span>: boolean,
}</code></pre>
<p>Wer das Gefühl hat die Optionen zu benötigen (meist ist die Antwort darauf „nein“) schaut am besten einmal in die offizielle Doku: <a href="https://react-redux.js.org/api/connect#options-object">https://react-redux.js.org/api/connect#options-object</a></p>
<h4 id="wie-wir-alle-teile-des-puzzles-miteinander-verbinden">Wie wir alle Teile des Puzzles miteinander verbinden</h4>
<p>Nun wissen wir welchen Zweck der <code>Provider</code> erfüllt und wie wir die <code>connect()</code>-Funktion einsetzen. Werfen wir nun doch einmal einen Blick auf ein sehr umfangreiches aber dafür auch vollständiges Beispiel einer voll funktionsfähigen TodoList-App, mit der wir neue Todos hinzufügen, diese als erledigt oder nicht erledigt markieren und auch wieder entfernen können:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// store/todos/reducer.js</span>
<span class="hljs-keyword">const</span> initialState = <span class="hljs-built_in">Object</span>.freeze([]);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (state = initialState, action) =&gt; {
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'ADD_TODO'</span>: {
      <span class="hljs-keyword">return</span> state.concat(action.payload);
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'REMOVE_TODO'</span>: {
      <span class="hljs-keyword">return</span> state.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> todo.id !== action.payload);
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'CHANGE_TODO_STATUS'</span>: {
      <span class="hljs-keyword">return</span> state.map(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (todo.id !== action.payload.id) {
          <span class="hljs-keyword">return</span> todo;
        }
        <span class="hljs-keyword">return</span> {
          ...todo,
          <span class="hljs-attr">done</span>: action.payload.done,
        };
      });
    }
    <span class="hljs-keyword">default</span>: {
      <span class="hljs-keyword">return</span> state;
    }
  }
};</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// store/todos/actions.js</span>
<span class="hljs-keyword">const</span> getPseudoRandomId = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
  <span class="hljs-built_in">Math</span>.random()
    .toString(<span class="hljs-number">36</span>)
    .slice(<span class="hljs-number">-6</span>);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> addTodo = <span class="hljs-function">(<span class="hljs-params">text</span>) =&gt;</span> ({
  <span class="hljs-attr">type</span>: <span class="hljs-string">'ADD_TODO'</span>,
  <span class="hljs-attr">payload</span>: {
    <span class="hljs-attr">id</span>: getPseudoRandomId(),
    text,
  },
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> removeTodo = <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> ({
  <span class="hljs-attr">type</span>: <span class="hljs-string">'REMOVE_TODO'</span>,
  <span class="hljs-attr">payload</span>: id,
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> changeStatus = <span class="hljs-function">(<span class="hljs-params">id, done</span>) =&gt;</span> ({
  <span class="hljs-attr">type</span>: <span class="hljs-string">'CHANGE_TODO_STATUS'</span>,
  <span class="hljs-attr">payload</span>: {
    id,
    done,
  },
});</code></pre>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// TodoList.js</span>
<span class="hljs-keyword">import</span> React, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { connect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;
<span class="hljs-keyword">import</span> { addTodo, removeTodo, changeStatus } <span class="hljs-keyword">from</span> <span class="hljs-string">'./store/todos/actions'</span>;

<span class="hljs-keyword">const</span> TodoList = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> [todoText, setTodoText] = useState(<span class="hljs-string">''</span>);

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;p&gt;{props.todos.length} Todos.&lt;/p&gt;
      &lt;ul&gt;
        {props.todos.map((todo) =&gt; (
          &lt;li key={todo.id}&gt;
            &lt;button
              type="button"
              onClick={() =&gt; {
                props.removeTodo(todo.id);
              }}
            &gt;
              löschen
            &lt;/button&gt;
            &lt;label
              style={{ textDecoration: todo.done ? 'line-through' : 'none' }}
            &gt;
              &lt;input
                type="checkbox"
                name={todo.id}
                checked={Boolean(todo.done)}
                onChange={(e) =&gt; {
                  const { name, checked } = e.target;
                  props.changeStatus(name, checked);
                }}
              /&gt;
              {todo.text}
            &lt;/label&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;input onChange={(e) =&gt; setTodoText(e.target.value)} value={todoText} /&gt;
      &lt;button
        type="button"
        onClick={() =&gt; {
          props.addTodo(todoText);
          setTodoText('');
        }}
      &gt;
        hinzufügen
      &lt;/button&gt;
    &lt;/div&gt;
  );
};

const mapStateToProps = (state) =&gt; ({
  todos: state.todos,
});

const mapDispatchToProps = {
  addTodo,
  removeTodo,
  changeStatus,
};

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(TodoList);</code></pre>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> { combineReducers, createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;
<span class="hljs-keyword">import</span> { Provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;
<span class="hljs-keyword">import</span> todosReducer <span class="hljs-keyword">from</span> <span class="hljs-string">'./store/todos/reducer'</span>;
<span class="hljs-keyword">import</span> TodoList <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoList'</span>;

<span class="hljs-keyword">const</span> rootReducer = combineReducers({
  <span class="hljs-attr">todos</span>: todosReducer,
});

<span class="hljs-keyword">const</span> store = createStore(rootReducer);

<span class="hljs-keyword">const</span> App = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">TodoList</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>
);

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Hier definieren wir zunächst mal unseren <code>todosReducer</code>, sowie die drei <strong>Actions</strong> <code>addTodo</code>, <code>removeTodo</code> und <code>changeStatus</code>, die uns jeweils aus vorherigen Beispielen bekannt vorkommen dürften. Zur besseren Übersicht lagern wir sowohl <strong>Reducer</strong> als auch <strong>Actions</strong> in eigene Dateien aus, die wir in ein eigenes Unterverzeichnis <code>./store/todos</code> legen.</p>
<div class="hint hint--warning">
<p>Achtung, kontrovers: über die „korrekte“ Ordnerstruktur beim Aufteilen einer Anwendung in mehrere Dateien werden immer wieder hitzige Debatten geführt. Ich selbst habe mit vielen unterschiedlichen Strukturen gearbeitet und fand die Aufteilung nach Domäne (also etwa <code>todos</code>, <code>user</code>, <code>repositories</code>, …) und nach Typ (<code>actions</code>, <code>reducer</code>, …) am übersichtlichsten. Andere wiederum bevorzugen es alle Actions in einem Ordner <code>actions</code> zu sammeln, alle Reduer in einem Ordner <code>reducer</code>. Wieder andere vermeiden die Aufteilung von Actions und Reducern in separate Dateien.</p>
<p>Hier gibt es kein eindeutiges <em>Richtig</em> oder <em>Falsch</em>. Dies hängt einerseits von den persönlichen Vorlieben ab, andererseits aber auch ein Stück weit vom sonstigen Aufbau der Anwendung, ihrer Größe, ihrer Komplexität und letztendlich auch davon, wie und von wem die Anwendung auf Entwicklerseite verwendet wird.</p>
</div>
<p>Weiter erstellen wir eine neue Datei die unsere <code>TodoList</code>-Komponente beinhalten wird: <code>./TodoList.js</code>. Mit ihr werden wir gleich unsere Todos anzeigen, neue anlegen oder wieder entfernen, sowie einzelne Todos als erledigt markieren können. Dazu verbinden wir die Komponente über <code>connect()</code> mit dem Store. Dementsprechend müssen wir in der Komponente auch unsere <strong>Actions</strong> importieren, die wir in <code>mapDispatchToProps</code> an <code>connect()</code> übergeben werden. Der besseren Übersichtlichkeit halber nutzen wir die <strong>Object Shorthand Syntax</strong>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> mapDispatchToProps = {
  addTodo,
  removeTodo,
  changeStatus,
};</code></pre>
<p>Die Funktionen werden dann von React Redux automatisch von einem <code>dispatch</code>-Aufruf umschlossen.</p>
<p>In <code>mapStateToProps</code> legen wir fest, dass wir den <code>todos</code>-Ast unseres Stores an die Komponente übergeben wollen. Sowohl <code>mapStateToProps</code> als auch <code>mapDispatchToProps</code> übergeben wir dann an die <code>connect()</code>-Funktion:</p>
<pre><code class="hljs javascript language-javascript">connect(
  mapStateToProps,
  mapDispatchToProps
);</code></pre>
<p>Doch das ist noch nicht alles: die <code>connect()</code>-Funktion erzeugt uns eine neue <strong>HOC</strong>, an die wir unsere <code>TodoList</code>-Komponente übergeben:</p>
<pre><code class="hljs javascript language-javascript">connect(...)(TodoList);</code></pre>
<p>Unsere <code>TodoList</code>-Komponente ist nun mit dem <strong>Redux-Store</strong> verbunden, wir müssen nun nur darauf achten, dass wir sie entsprechend auch nur innerhalb eines <code>&lt;Provider&gt;</code>-Elements verwenden. Wir nutzen außerdem <code>export default</code> vor dem Aufruf der <code>connect()</code>-Funktion um unsere mit dem Store verbundene Komponente zu exportieren.</p>
<p>Zuletzt werfen wir einen Blick auf die <code>index.js</code>, die letztendlich den „Einstiegspunkt“ unserer App darstellt. Hier findet der <code>ReactDOM.render()</code>-Aufruf statt, mit dem wir unsere App in das jeweilige DOM-Element rendern. Doch bevor es soweit ist, passiert hier noch einiges:</p>
<p>Wir importieren <code>combineReducers</code> und <code>createStore</code> aus <code>redux</code>. Damit erstellen wir gleich unser <code>store</code>-Objekt. Dazu importieren wir unseren ausgelagerten <code>todosReducer</code>, den wir an <code>combineReducers()</code> übergeben um einen neuen <strong>Root Reducer</strong> zu erstellen. Das wäre an dieser Stelle noch unnötig, da wir ohnehin nur einen einzigen <strong>Reducer</strong> haben und diesen daher direkt an <code>createStore()</code> übergeben könnten. Allerdings gehen wir in diesem Fall bereits vorsorglich davon aus, dass unsere Anwendung noch weiter wachsen wird und wir mit der Zeit sicherlich noch weitere <strong>Reducer</strong> hinzufügen werden.</p>
<p>Wir importieren außerdem die <code>Provider</code>-Komponente aus <code>react-redux</code>. An diese übergeben wir später den eben erstellten <strong>Store</strong>. Aus der <code>TodoList.js</code> importieren wir unsere verbundene Komponente, die wir letztlich in unserer <code>App</code>-Komponente <em>innerhalb</em> der <code>Provider</code>-Komponente mit unserem <code>store</code>-Objekt verwenden.</p>
<p>Interagieren wir nun mit der TodoList können wir entsprechend neue Todos anlegen, diese über eine Checkbox als erledigt markieren oder über den Löschen-Button vollständig wieder entfernen.</p>
<p>An dieser Stelle macht es sicherlich am meisten Sinn etwas mit der Komponente rumzuspielen und zu schauen wie sich die Interaktion auf den Store auswirkt. Dazu sollten die Redux-Devtools für unseren Store aktiviert werden. Dazu ändern wir in der <code>index.js</code> die Zeile:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> store = createStore(rootReducer);</code></pre>
<p>In die folgende:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> store = createStore(rootReducer, __REDUX_DEVTOOLS_EXTENSIONS__());</code></pre>
<p>Dabei muss sichergestellt sein, dass im verwendeten Browser die Redux Devtools installiert sind.</p>
<h3 id="fazit">Fazit</h3>
<p>Ich muss gestehen, dass ich die Komplexität dieses Kapitels bei weitem unterschätzt habe. <strong>Redux</strong> gehört für mich in vielen Projekten seit Jahren zum Alltagsgeschäft und so fühlt sich die Verwendung von <strong>Redux</strong> mittlerweile ein Stück weit sehr <em>natürlich</em> an, also wie etwas, über dass ich nicht viel nachdenken muss. Grundsätzlich würde ich <strong>Redux</strong> als Tool beschreiben, dass es schafft sehr komplexes State Management sehr einfach, nachvollziehbar und eben <em>vorhersehbar</em> zu machen.</p>
<p>Beim Schreiben dieses Kapitels habe ich dann erst einmal wieder gemerkt wie überwältigend <strong>Redux</strong> aber gerade für Einsteiger sein kann und so kann ich mir vorstellen, dass einige der in diesem Kapitel beschriebenen Dinge trotz meiner Erläuterungen nicht unbedingt gleich verständlich sein werden. Hier sollte es aber tatsächlich helfen mit geöffneten Devtools etwas mit den Actions und den Reducern herumzuspielen um zu verstehen wie das eine das andere beeinflusst und wie die das Zusammenspiel aller Komponenten, also dem Store, dem State, den Props einer Komponente, der <code>connect()</code>-Funktion und letztendlich der Actions und Reducer letztendlich ablaufen.</p>
<p>Sollte es danach immer noch Fragen geben könnt ihr euch jederzeit gern mit Bezug auf dieses Buch an mich wenden!</p>
</div>
<div class="chapter">
  <h1 id="mehrsprachigkeit">Mehrsprachigkeit</h1>
<p>Eins der Themen, das neben <strong>Routing</strong> und <strong>State Management</strong> immer wieder aufkommt ist <strong>Mehrsprachigkeit</strong>. Wie bekomme ich meine Anwendung übersetzt, so dass ein deutscher Benutzer ein deutsches Interface sieht, während andere Benutzer bspw. ein englisches Interface sehen.</p>
<p>Ich möchte in diesem Kapitel nicht generell in die Tiefen der <strong>Internationalisierung</strong> (meist abgekürzt: <strong>i18n</strong>) einsteigen, denn hier soll es um <strong>React</strong> gehen. Ich setze daher ein gewisses (geringes) Grundverständnis voraus, was die Internationalisierung von User Interfaces angeht und konzentriere mich daher insbesondere darauf, wie man diese in React umsetzen kann.</p>
<p>Wie Mehrsprachigkeit in sehr simpler Form für einfache Apps mittels <strong>Context API</strong> umgesetzt werden kann, wurde bereits im Kapitel über die <strong>Context API</strong> demonstriert, wo wir eine sehr rudimentäre Form der Mehrsprachigkeit beispielhaft mit eben dieser API umgesetzt haben. Mit zunehmender Komplexität einer Anwendung steigt aber auch die Komplexität an die Mehrsprachigkeit. Plötzlich werden Dinge wichtig wie die Verwendung von Platzhaltern oder die Verwendung des Plurals. Hier ist es dann irgendwann sinnvoll auf Pakete zurückzugreifen, die genau zu diesem Zweck entwickelt worden sind.</p>
<p>Hier gibt es einige bewährte Optionen im <strong>React Ecosystem</strong> auf die wir zurückgreifen können. Zu den bekannteren gehören hier <strong>Lingui</strong>, <strong>Polyglot</strong>, <strong>i18next</strong> oder <strong>react-intl</strong> und auch Facebook hat mit <strong>FBT</strong> ein eigenes Framework für die Internationalisierung von React Anwendungen im Angebot. In diesem Kapitel geht es vorrangig um <code>i18next</code> und dessen React Bindings <code>react-i18next</code>.</p>
<p>Warum? Nun, ich habe in verschiedenen Projekten mit <code>react-intl</code> und <code>react-i18next</code> gearbeitet, habe die anderen Alternativen ausführlich evaluiert und bin der festen Überzeugung, dass <strong>i18next</strong> in vielerlei Hinsicht die beste der genannten Alternativen darstellt. Es existiert eine sehr große und aktive Community rund um <strong>i18next</strong>, es werden neben <strong>React</strong> auch noch viele andere Frameworks, Libraries und Plattformen unterstützt, es läuft ohne großen Aufwand sowohl clientseitig im Browser als auch serverseitig in Node.js und das Übersetzungsformat von <strong>i18next</strong> wird von so ziemlich allen großen online Übersetzungs-Services als Exportformat angeboten.</p>
<p>Darüber hinaus bot es als erstes Paket bereits wenige Tage nach deren Erscheinen Unterstützung für Hooks und wurde sogar gezielt auf dessen Verwendung optimiert ohne dabei die Abwärtskompatibilität einzubüßen. Dabei bleibt die API überwiegend simpel und einfach zu benutzen und bietet maximale Flexibilität. Um es mit anderen Worten zu sagen: das ganze Paket ist sehr komplett und lässt wenig bis gar keine Wünsche offen.</p>
<h3 id="setup-von-i18next">Setup von i18next</h3>
<p>Um es zu installieren rufen wir wieder unser Terminal auf und geben ein:</p>
<pre><code class="hljs bash language-bash">npm install i18next react-i18next</code></pre>
<p>bzw. mit Yarn:</p>
<pre><code class="hljs bash language-bash">yarn add i18next react-i18next</code></pre>
<p>Wir installieren hier mit <code>i18next</code> das <strong>Internationalisierungs-Framework</strong> selbst, sowie mit <code>react-i18next</code> dessen <strong>React Bindings</strong>, also sozusagen eine Reihe an Komponenten und Funktionen die uns die Arbeit mit i18next in React deutlich erleichtern. So, wie wir das Prinzip schon im Kapitel zu State Management mit <code>redux</code> und <code>react-redux</code> kennengelernt haben.</p>
<p>Starten wir zunächst einmal indem wir uns zwei Objekte anlegen, die unsere Übersetzungen beinhalten. Eins mit Texten in Deutsch, eins mit Texten in Englisch:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> de = {
  <span class="hljs-attr">greeting</span>: <span class="hljs-string">'Hallo Welt!'</span>,
  <span class="hljs-attr">headline</span>: <span class="hljs-string">'Heute lernen wir Internationalisierung mit React'</span>,
  <span class="hljs-attr">messageCount</span>: <span class="hljs-string">'{{count}} neue Nachricht'</span>,
  <span class="hljs-attr">messageCount_plural</span>: <span class="hljs-string">'{{count}} neue Nachrichten'</span>,
};

<span class="hljs-keyword">const</span> en = {
  <span class="hljs-attr">greeting</span>: <span class="hljs-string">'Hello world!'</span>,
  <span class="hljs-attr">headline</span>: <span class="hljs-string">'Today we learn Internationalization with React'</span>,
  <span class="hljs-attr">messageCount</span>: <span class="hljs-string">'{{count}} new message'</span>,
  <span class="hljs-attr">messageCount_plural</span>: <span class="hljs-string">'{{count}} new messages'</span>,
};</code></pre>
<p>Um <strong>i18next</strong> nun in unserer Anwendung zu verwenden, müssen wir es importieren, initialisieren und das React Plugin übergeben. Dies sollte idealerweise am Anfang unserer Anwendung passieren. Möglichst bevor wir unsere App-Komponente an den <code>ReactDOM.render()</code>-Aufruf übergeben.</p>
<p>Dazu importieren wir das <code>i18next</code>-Paket selbst, sowie den benannten Export <code>initReactI18next</code> aus dem <code>react-i18next</code>-Paket:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> i18next <span class="hljs-keyword">from</span> <span class="hljs-string">'i18next'</span>;
<span class="hljs-keyword">import</span> { initReactI18next } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-i18next'</span>;</code></pre>
<p>Anschließend nutzen wir die <code>.use()</code>-Methode um das React Plugin an <strong>i18next</strong> zu übergeben, sowie die <code>.init()</code>-Methode um <strong>i18next</strong> zu initialisieren:</p>
<pre><code class="hljs javascript language-javascript">i18next
  .use(initReactI18next)
  .init({ ... });</code></pre>
<p>Die <code>init()</code>-Methode erwartet dabei ein Config-Objekt, das mindestens die beiden Eigenschaften <code>lng</code> (für die ausgewählte Sprache) sowie <code>resources</code> (für die Übersetzungen selbst) beinhalten sollte. Darüber hinaus ist es oft sinnvoll eine <code>fallbackLng</code> zu erstellen, also eine Fallback-Sprache, die dann benutzt wird wenn eine Übersetzung in der ausgewählten Sprache nicht vorhanden ist. Insgesamt bietet <strong>i18next</strong> hier über 30 verschiedene Konfigurationsoptionen an, doch die genannten drei sind die, die uns für den Moment interessieren:</p>
<pre><code class="hljs javascript language-javascript">i18next.use(initReactI18next).init({
  <span class="hljs-attr">lng</span>: <span class="hljs-string">'en'</span>,
  <span class="hljs-attr">fallbackLng</span>: <span class="hljs-string">'en'</span>,
  <span class="hljs-attr">resources</span>: {
    <span class="hljs-attr">en</span>: {
      <span class="hljs-attr">translation</span>: en,
    },
    <span class="hljs-attr">de</span>: {
      <span class="hljs-attr">translation</span>: de,
    },
  },
});</code></pre>
<p>Wir setzen also die Sprache erst einmal auf Englisch, ebenso die Fallback-Sprache. Dann folgt ein <code>resources</code>-Objekt das etwas Erläuterung bedarf. Das Objekt hat die Form:</p>
<pre><code class="hljs text language-text"><span class="hljs-string">[Sprache]</span>.<span class="hljs-string">[Namespace]</span>.<span class="hljs-string">[Translation Key]</span> = Übersetzung</code></pre>
<p>Die Sprache dürfte klar sein. Das kann <code>de</code> für Deutsch sein, <code>en</code> für Englisch oder auch <code>de-AT</code> für deutsch mit österreichischer Regionalisierung. Die Eigenschaft besitzt als Wert ein Objekt, bestehend aus mindestens einem bis zu theoretisch unbegrenzt vielen <strong>Namespaces</strong>.</p>
<p>Der <strong>Namespace</strong> ist ein zentrales Feature in <strong>i18next</strong> das benutzt werden kann, aber nicht muss. Es erlaubt dem Entwickler größere Übersetzungsdateien in mehrere Teile zu splitten, die bei Bedarf dynamisch nachgeladen werden können. Während dieses Feature bei kleineren Anwendungen nicht unbedingt sinnvoll ist, kann es in größeren und komplexeren Anwendungen dazu benutzt werden um Übersetzungen klein und übersichtlich zu halten, etwa indem jeder größere Seitenbereich einen eigenen <strong>Namespace</strong> erhält. Übersetzungsdateien für diesen Seitenbereich könnten dann separat gepflegt und nur dann geladen werden wenn diese auch benötigt werden.</p>
<p>In <strong>i18next</strong> muss zwingend immer mindestens <em>ein</em> <strong>Namespace</strong> benutzt werden. Standardmäßig heißt dieser <code>translation</code>, dies kann aber durch die <code>defaultNS</code>-Option im Konfigurationsobjekt der <code>.init()</code>-Methode geändert werden. Der <strong>Namespace</strong> ist dabei selbst wiederum ein Objekt, das letztendlich die eigentlichen Übersetzungen enthält in der Form <code>translationKey: value</code>, also etwa <code>greeting: 'Hallo Welt!'</code>.</p>
<p>Der Wert selbst <em>kann</em> wiederum ein Objekt sein:</p>
<pre><code class="hljs javascript language-javascript">{
  <span class="hljs-attr">greeting</span>: {
    <span class="hljs-attr">morning</span>: <span class="hljs-string">'Guten Morgen!'</span>,
    <span class="hljs-attr">evening</span>: <span class="hljs-string">'Guten Abend!'</span>,
  }
}</code></pre>
<p>Oder in verkürzter Form:</p>
<pre><code class="hljs javascript language-javascript">{
  <span class="hljs-string">'greeting.morning'</span>: <span class="hljs-string">'Guten Morgen!'</span>,
  <span class="hljs-string">'greeting.evening'</span>: <span class="hljs-string">'Guten Abend!'</span>,
}</code></pre>
<p>Auch das liegt aber im Ermessen des Entwicklers.</p>
<h3 id="verwendung-von-übersetzungen-in-react-komponenten">Verwendung von Übersetzungen in React Komponenten</h3>
<p>Ist <strong>i18next</strong> erst einmal korrekt eingerichtet und die Übersetzungen angelegt können wir auch schon damit weitermachen unsere Komponenten zu übersetzen. Auch hier bietet uns <strong>i18next</strong> volle Flexbilität: wir bekommen eine <code>withTranslation</code>-HOC für die Verwendung mit <strong>Klassen-Komponenten</strong>, einen <code>useTranslation</code>-Hook, zur Verwendung in <strong>Function Components</strong> und für Fälle, in denen wir Komponenten innerhalb von Übersetzungen nutzen wollen gibt uns <code>react-i18next</code> auch eine entsprechende <code>Trans</code>-Komponente an die Hand.</p>
<h4 id="verwendung-mit-klassen-komponenten-und-withtranslation-hoc">Verwendung mit Klassen-Komponenten und withTranslation()-HOC</h4>
<p>Wir gehen sie der Reihe nach durch und fangen mit der <code>withTranslation()</code>-Funktion an. Diese erzeugt uns eine <strong>HOC</strong> an die wir die zu übersetzende Komponente übergeben und bekommen daraufhin die Props <code>t</code> und <code>i18n</code> in diese hereingereicht. Dazu importieren wir die Funktion zuerst als benannten Export aus dem <code>react-i18next</code>-Paket:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> { withTranslation } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-i18next'</span>;</code></pre>
<p>Anschließend rufen wir die Funktion auf, erhalten eine HOC und übergeben dieser die Komponente, in der wir auf die übersetzten Werte zugreifen möchten. Nutzen wir <strong>Namespaces</strong> können wir außerdem den oder die gewünschten <strong>Namespaces</strong> an die <code>withTranslation()</code>-Funktion übergeben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// Ohne Namespaces (hier wird der Default-Wert benutzt):</span>
<span class="hljs-keyword">const</span> TranslatedComponent = withTranslation()(TranslatedComponent);

<span class="hljs-comment">// Mit nur einem Namespace:</span>
<span class="hljs-keyword">const</span> TranslatedComponent = withTranslation(<span class="hljs-string">'namespace'</span>)(Component);

<span class="hljs-comment">// Mit mehreren Namespaces:</span>
<span class="hljs-keyword">const</span> TranslatedComponent = withTranslation([<span class="hljs-string">'namespace1'</span>, <span class="hljs-string">'namespace2'</span>])(
  TranslatedComponent
);</code></pre>
<p>In der Praxis hat es sich für mich bewährt einzelne Komponenten in eigene Dateien auszulagern und die <code>withTranslation()</code>-HOC beim Export um die Komponente zu legen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// Greeting.js</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">const</span> { t } = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{t('greeting')}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> withTranslation()(Greeting);</code></pre>
<p>So können wir dann beim Import gleich die übersetzte Komponente importieren:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> Greeting <span class="hljs-keyword">from</span> <span class="hljs-string">'./Greeting.js'</span>;</code></pre>
<p>Hier importieren wir dann entsprechend die Komponente mit den durch i18next erweiterten Props <code>t</code>, <code>i18n</code> und <code>tReady</code>.</p>
<p>Die <code>t</code> Funktion ist dabei die zentrale Funktion für alles was mit Übersetzungen zu tun hat. Sie bekommt einen <strong>Translation Key</strong> übergeben und gibt uns den übersetzten Wert zurück, basierend auf unserer aktuell eingestellten Sprache:</p>
<pre><code class="hljs jsx language-jsx">&lt;h1&gt;{t('greeting')&lt;/h1&gt;
// -&gt; &lt;h1&gt;Hello world!&lt;/h1&gt;</code></pre>
<p>Nutzen wir Platzhalter oder Plurale in unseren Übersetzungen, können diese als zweiter Parameter übergeben werden:</p>
<pre><code class="hljs javascript language-javascript">&lt;p&gt;{t('messageCount', { count: 3 })}&lt;/p&gt;
// -&gt; &lt;p&gt;3 new messages&lt;/p&gt;</code></pre>
<p>Die <code>i18n</code> Prop enthält die zuvor initialisierte <strong>i18next</strong>-Instanz. Sie bietet uns einige Eigenschaften und Methoden die für unsere Übersetzungen relevant sein können. Die beiden wichtigsten sind dabei sicherlich:</p>
<ul>
<li><code>i18n.language</code>, um die aktuell ausgewählte Sprache auszulesen</li>
<li><code>i18n.changeLanguage()</code>, um die ausgewählte Sprache zu ändern</li>
</ul>
<p>Um bspw. in einer Komponente die Sprache von <code>en</code> in <code>de</code> zu ändern, kann hier der Aufruf von <code>i18n.changeLanguage('de')</code> benutzt werden.</p>
<h4 id="verwendung-mit-function-components-und-usetranslation-hook">Verwendung mit Function Components und useTranslation()-Hook</h4>
<p>Natürlich können nicht nur <strong>Klassen-Komponenten</strong> mit der <code>withTranslation()</code>-HOC benutzt werden sondern auch <strong>Function Components</strong>. Allerdings können wir in letzteren auch den <code>useTranslation()</code>-Hook verwenden, der die Komponente meist noch etwas übersichtlicher werden lässt. Dazu importieren wir den Hook wie auch die HOC ebenfalls aus dem <code>react-i18next</code>-Paket:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> { useTranslation } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-i18next'</span>;</code></pre>
<p>Der <strong>Hook</strong> lässt uns dann per <strong>Destructuring Assignment Syntax</strong> aus ES2015+ die beiden Eigenschaften <code>t</code> und <code>i18n</code> aus ihm extrahieren:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> Greeting = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> { t, i18n } = useTranslation();
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{t('greeting')}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> i18n.changeLanguage('de')}&gt;de<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> i18n.changeLanguage('en')}&gt;en<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};</code></pre>
<p>Wie auch bereits in der <code>withTranslation()</code>-HOC ist <code>t</code> hier die Funktion um Übersetzungen über ihren <strong>Translation Key</strong> auszugeben und <code>i18n</code> die <strong>i18next</strong>-Instanz. Der Hook stellt also exakt die gleiche Funktionalität bereit wie auch die HOC, ist in <strong>Function Components</strong> aber deutlich übersichtlicher, weil expliziter. Um bestimmte <strong>Namespaces</strong> zu verwenden, können dem Hook wie schon der <code>withTranslation()</code>-Funktion ein String oder ein Array mit Strings übergeben werden:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> { t } = useTranslation(<span class="hljs-string">'namespace'</span>);
<span class="hljs-keyword">const</span> { t } = useTranslation([<span class="hljs-string">'namespace1'</span>, <span class="hljs-string">'namespace2'</span>]);</code></pre>
<p>Wird kein Namespace übergeben, greift auch hier die Default-Einstellung.</p>
<h3 id="komplexe-übersetzungen-mit-der-trans-komponente">Komplexe Übersetzungen mit der Trans-Komponente</h3>
<p>In einigen Fällen kann es notwendig sein React-Komponenten in Übersetzungen zu verwenden. Das ist bspw. der Fall, möchte man die <code>Link</code>-Komponente vom React Router nutzen, um innerhalb einer Übersetzung auf eine andere URL zu verlinken. Das ist nur durch die Verwendung der <code>t()</code>-Funktion nicht ohne weiteres möglich. Hierzu stellt uns <code>react-i18next</code> die <code>Trans</code>-Komponente bereit. Die Verwendung ist nicht immer ganz einfach zu verstehen, aber sie ist ein sehr mächtiges Werkzeug.</p>
<p>Nehmen wir also an wir wollen innerhalb unserer Übersetzung die <code>Link</code>-Komponente verwenden. Der Code sieht vor der Übersetzung also in etwa so aus:</p>
<pre><code class="hljs jsx language-jsx">&lt;p&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"terms"</span> /&gt;</span>
    Ich akzeptiere die <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/terms"</span>&gt;</span>AGB<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></code></pre>
<p>Die Verwendung der Link-Komponente in einer Übersetzung würde hier nicht funktionieren, da Übersetzungen grundsätzlich Strings sind und wir keine Möglichkeit hätten um festzulegen, dass es sich bei <code>&lt;Link&gt;</code> um die Link-Komponente aus dem React-Router Paket handelt.</p>
<p>Die Lösung ist hier nun die Verwendung der <code>Trans</code>-Komponente. Übersetzungen die mit dieser Komponente verwendet werden können nummerierte Platzhalter besitzen. An ihre Stelle werden Komponenten eingesetzt, die an gleicher Position in der <code>Trans</code>-Komponente verwendet werden.</p>
<p>Schauen wir uns das obige Beispiel also einmal unter Verwendung von <code>Trans</code> an:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// Übersetzungen:</span>
<span class="hljs-keyword">const</span> de = {
  <span class="hljs-attr">terms</span>: <span class="hljs-string">'Ich akzeptiere die &lt;1&gt;AGB&lt;/1&gt;.'</span>,
};

<span class="hljs-keyword">const</span> en = {
  <span class="hljs-attr">terms</span>: <span class="hljs-string">'I accept the &lt;1&gt;Terms and Conditions&lt;/1&gt;.'</span>,
};

<span class="hljs-comment">// JSX:</span>
&lt;p&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Trans</span> <span class="hljs-attr">i18nKey</span>=<span class="hljs-string">"terms"</span>&gt;</span>
      I accept the <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/terms"</span>&gt;</span>Terms and Conditions<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>.
    <span class="hljs-tag">&lt;/<span class="hljs-name">Trans</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;</code></pre>
<p>Hier umschließen wir unseren Text mit einem <code>Trans</code>-Element. Der Text dient dabei lediglich als Platzhalter der verwendet wird wenn es zu dem in der <code>i18nKey</code>-Prop angegebenen Wert keine entsprechende Übersetzung gibt. Nun geht es ans Zählen. Wo welcher Text wie ersetzt wird und an welche Stelle eine Komponente tritt ergibt sich aus dem Index-Wert der Kind-Elemente. Analog dazu, wie auch <code>React.createElement()</code>-Funktioniert.</p>
<p>Im obigen Beispiel ergibt sich also folgendes Zähl-Ergebnis:</p>
<pre><code class="hljs text language-text"><span class="hljs-number">0</span>: I accept the
<span class="hljs-number">1</span>: &lt;<span class="hljs-keyword">Link</span> <span class="hljs-keyword">to</span>=<span class="hljs-string">"/terms"</span>&gt;Terms <span class="hljs-literal">and</span> Conditions&lt;/<span class="hljs-keyword">Link</span>&gt;
<span class="hljs-number">2</span>: .</code></pre>
<p>An die Stelle <code>&lt;1&gt;Terms and Conditions&lt;/1&gt;</code> tritt also hier das <code>&lt;Link&gt;</code>-Element, da es im Children-Array den Index-Wert 1 besitzt.</p>
<p>Nun kann das gerade in komplexeren Strukturen in denen es vielleicht sogar mehrere Links gibt ziemlich umständlich werden das zu zählen. Hier bietet <code>react-i18next</code> zwei Möglichkeiten um die Platzhalter automatisch zu generieren. Beide werden als Option beim Initialisieren von i18next gesetzt.</p>
<p>Die erste Option ist das Setzen von <code>saveMissing</code> auf <code>true</code> und die Verwendung einer <code>missingKeyHandler</code> Funktion. Im folgenden Beispiel nutzen wir ein simples <code>console.log()</code> um fehlende Übersetzungen in die Browser-Konsole zu loggen:</p>
<pre><code class="hljs javascript language-javascript">i18next.use(initReactI18next).init({
  <span class="hljs-attr">saveMissing</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">missingKeyHandler</span>: <span class="hljs-function">(<span class="hljs-params">language, namespace, key, fallbackValue</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Fehlende Übersetzung:'</span>, fallbackValue);
  },
  <span class="hljs-comment">// weitere Optionen</span>
});</code></pre>
<p>Wird nun ein <code>i18nKey</code> benutzt der nicht existiert, wird stattdessen der Fallback-Wert, also der Wert aus dem Trans-Element in die Browser Konsole geschrieben:</p>
<div class="hint hint--info">
<p>Fehlende Übersetzung: I accept the &lt;1&gt;Terms and Conditions&lt;/1&gt;.</p>
</div>
<p>Für diese kann nun eine entsprechende Übersetzung angelegt werden. Der React Router Link wurde in der Ausgabe bereits durch den passenden Platzhalter-Index ersetzt, in diesem Fall also <strong>1</strong>.</p>
<p>Als zweite Option können wir statt des <code>missingKeyHandler</code> die <code>debug</code>-Option auf <code>true</code> setzen.</p>
<pre><code class="hljs javascript language-javascript">i18next.use(initReactI18next).init({
  <span class="hljs-attr">debug</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-comment">// weitere Optionen</span>
});</code></pre>
<p>Wir erhalten dann eine Reihe an Debugging-Informationen, wie eben auch einen Hinweis auf fehlende Übersetzungen. Die Ausgabe ist dann etwa:</p>
<div class="hint hint--info">
<p>i18next::translator: missingKey de translation terms I accept the &lt;1&gt;Terms and Conditions&lt;/1&gt;.</p>
</div>
<p>Die Ausgabe ist hier etwas unfänglicher als bei der eigenen <code>missingKeyHandler</code>-Variante, dafür reicht es hier aber auch aus, lediglich eine Option auf <code>true</code> zu setzen.</p>
<p>Innerhalb von <code>&lt;Trans&gt;</code>-Elementen kann übrigens auch die <code>t</code>-Funktion wie gewohnt verwendet werden. So wäre etwa auch folgendes möglich:</p>
<pre><code class="hljs jsx language-jsx">&lt;Trans i18nKey="terms"&gt;
  I accept the{' '}
  &lt;Link to="/terms" title={t('termsTitle')}&gt;
    Terms and Conditions
  &lt;/Link&gt;
  .
&lt;/Trans&gt;</code></pre>
<h3 id="fazit">Fazit</h3>
<p>Mit den in diesem Kapitel gezeigten Beispielen ist es relativ einfach seine Anwendung gleich mehrsprachig zu entwickeln. In der Praxis hat sich i18next dabei für mich persönlich als sehr universelles und vollständiges Tool erwiesen. Die Integration in verscheidene Libraries und Frameworks funktioniert einwandfrei, es bietet alle Funktionen die ein solches i18n-Framework benötigt und mit nur wenigen Funktionen und Komponenten (<code>i18n.changeLanguage()</code>, <code>t</code>, <code>&lt;Trans&gt;</code>) ist es darüber hinaus relativ leicht zu erlernen.</p>
<p>Einmal korrekt aufgesetzt und eingerichtet, hier empfehle ich einen Blick auf die <a href="https://www.i18next.com/overview/configuration-options">vollständigen Optionen von i18next</a>, realisiert man dabei Mehrsprachigkeit in seiner React-Anwendung, ohne dass es sich wie ein Mehraufwand anfühlt. Dafür sorgen auch Online-Services wie <a href="https://locize.com/">Locize.com</a> oder <a href="https://www.lokalise.co">Lokalise.co</a> um nur einige Beispiele zu nennen, mit denen die Erstellung von Übersetzungen verwaltet und zum Teil sogar automatisiert outgesourced werden kann.</p>
</div>
<div class="chapter">
  <h1 id="informationsquellen">Informationsquellen</h1>
<p>Die meisten Informationsquellen in Bezug auf React sind englischsprachig. Selbst deutsche Muttersprachler haben zum Teil englische Bücher geschrieben oder schreiben ihre Newsletter oder Blogs auf Englisch, weil damit natürlich eine deutlich größere Zielgruppe erreicht werden kann. Dies war und ist einer der Gründe, warum ich dieses Buch in deutscher Sprache verfasst habe: ich denke, dass es viele deutschsprachige Entwickler da draußen gibt, die sich gerne in ihrer Muttersprache in ein Thema einlesen möchten.</p>
<p>Dies ändert allerdings nichts daran, dass so ziemlich alle Informationsquellen da draußen nur in Englisch existieren. Ganz kommt man also nicht um Englisch herum wenn man sich nicht nur einlesen sondern auch stets auf dem neuesten Stand bleiben möchte. Ich bitte daher um Verzeihung, wenn die Informationsquellen hier zum deutlich überwiegenden Teil nur in englischer Sprache genannt werden.</p>
<h3 id="twitter">Twitter</h3>
<p>Twitter ist seit jeher eine top aktuelle Quelle wenn es darum geht zu wissen was gerade angesagt ist. Auch das React-Team veröffentlicht neue Änderungen regelmäßig sehr zeitnah auf Twitter. Wer also hier noch keinen Account hat, aber regelmäßig auf dem Laufenden bleiben will, der sollte sich schleunigst einen Account zulegen und hin und wieder mal dort reinschauen.</p>
<p>Ich bin mir ziemlich sicher, dass ich einer Menge Leute unrecht tun werde indem ich hier eine Vielzahl an Accounts auflisten werde, die meiner Meinung nach sehr regelmäßig und zum deutlich überwiegenden Teil interessante Tweets über React verfassen. Denn ich werde vermutlich genau so viele Accounts die ebenso erwähnenswert wären nicht erwähnen. Hier jedoch eine Liste an Accounts denen ich selber folge und die ich ohne Einschränkung empfehlen kann:</p>
<p><a href="https://www.twitter.com/reactjs">@reactjs</a> <a href="https://www.twitter.com/dan_abramov">@dan_abramov</a> <a href="https://www.twitter.com/sophiebits">@sophiebits</a> <a href="https://www.twitter.com/sebmarkbage">@sebmarkbage</a> <a href="https://www.twitter.com/acdlite">@acdlite</a> <a href="https://www.twitter.com/brian_d_vaughn">@brian_d_vaughn</a> <a href="https://www.twitter.com/trueadm">@trueadm</a> <a href="https://www.twitter.com/threepointone">@threepointone</a> <a href="https://www.twitter.com/aweary">@aweary</a> (allesamt React Core Contributors) <a href="https://www.twitter.com/ryanflorence">@ryanflorence</a> <a href="https://www.twitter.com/mjackson">@mjackson</a> <a href="https://www.twitter.com/ken_wheeler">@ken_wheeler</a> <a href="https://www.twitter.com/kentcdodds">@kentcdodds</a> <a href="https://www.twitter.com/kyleshevlin">@kyleshevlin</a> <a href="https://www.twitter.com/mweststrate">@mweststrate</a> <a href="https://www.twitter.com/jaredpalmer">@jaredpalmer</a> <a href="https://www.twitter.com/sebmck">@sebmck</a> <a href="https://www.twitter.com/thekitze">@thekitze</a> <a href="https://www.twitter.com/PhilippSpiess">@PhilippSpiess</a> <a href="https://www.twitter.com/monicalent">@monicalent</a> <a href="https://www.twitter.com/nikkitaftw">@nikkitaftw</a> <a href="https://www.twitter.com/rwieruch">@rwieruch</a> <a href="https://www.twitter.com/jlongster">@jlongster</a> <a href="https://www.twitter.com/eveporcello">@eveporcello</a> <a href="https://www.twitter.com/vincentriemer">@vincentriemer</a> <a href="https://www.twitter.com/kylemathews">@kylemathews</a> <a href="https://www.twitter.com/rauchg">@rauchg</a> <a href="https://www.twitter.com/erinfoox">@erinfoox</a> <a href="https://www.twitter.com/jevakallio">@jevakallio</a> <a href="https://www.twitter.com/okonetchnikov">@okonetchnikov</a> <a href="https://www.twitter.com/manuelbieh">@manuelbieh</a> <a href="https://www.twitter.com/manjula_dube">@manjula_dube</a> <a href="https://www.twitter.com/acemarke">@acemarke</a> <a href="https://www.twitter.com/wisecobbler">@wisecobbler</a> <a href="https://www.twitter.com/mxstbr">@mxstbr</a> <a href="https://www.twitter.com/cpojer">@cpojer</a> <a href="https://www.twitter.com/lithinn">@lithinn</a> <a href="https://www.twitter.com/dabit3">@dabit3</a> <a href="https://www.twitter.com/saifadin">@saifadin</a> <a href="https://www.twitter.com/rickhanlonii">@rickhanlonii</a> <a href="https://www.twitter.com/tylermcginnis">@tylermcginnis</a> <a href="https://www.twitter.com/wesbos">@wesbos</a> <a href="https://www.twitter.com/_developit">@_developit</a> <a href="https://www.twitter.com/ProvablyFlarnie">@ProvablyFlarnie</a> <a href="https://www.twitter.com/emmawedekind">@emmawedekind</a> <a href="https://www.twitter.com/FischaelaMeer">@FischaelaMeer</a></p>
<h3 id="newsletter">Newsletter</h3>
<p>Keine Angst, hier meine ich nicht die Werbeschleudern die jeder von uns ständig ungefragt bekommt und bei denen man sich fragt, ob man sich dort wirklich jemals angemeldet hat. In der React-Szene gibt es tatsächlich eine ganze Reihe sehr interessanter, liebevoll gepflegter und schön gestalteter Newsletter die es sich definitiv lohnt zu abonnieren. Die meisten davon werden wöchentlich verschickt und enthalten einen guten Überblick darüber, was in der letzten Woche in der React-Welt so passiert ist. Für alle, denen Twitter zu schnelllebig, stressig oder zu anstrengend ist:</p>
<ul>
<li><a href="https://react.statuscode.com/">React Status</a> (Peter Cooper / Cooperpress)</li>
<li><a href="https://this-week-in-react.org/">This Week in React</a> (Philipp Spiess)</li>
<li><a href="http://reactjsnewsletter.com/">React.js Newsletter</a> (Tyler McGinnis)</li>
<li><a href="http://newsletter.fullstackreact.com">Fullstack React</a> (Sophia Shoemaker)</li>
<li><a href="https://reactdigest.net/">React Digest</a> (Jakub Chodounsky / Bonobopress)</li>
</ul>
<h3 id="communities">Communities</h3>
<ul>
<li>Deutsche Slack Community: <a href="https://reactjs.de/">https://reactjs.de/</a></li>
<li><a href="https://spectrum.chat/react">https://spectrum.chat/react</a></li>
<li><a href="https://www.reactiflux.com/">https://www.reactiflux.com/</a></li>
</ul>
<h3 id="podcasts">Podcasts</h3>
<p>Wie auch schon bei den Newslettern gibt es einige hochwertige Podcasts über React, jedoch sind mir hier ausschließlich englischsprachige Podcasts bekannt. Wen dies nicht abschreckt, der hört gern mal bei den folgenden Podcasts rein:</p>
<ul>
<li><a href="https://undefined.fm/">The Undefined</a> (Ken Wheeler und Jared Palmer)</li>
<li><a href="https://reactpodcast.com/">React Podcast</a> (Michael Chan aka <a href="https://github.com/chantastic">@chantastic</a>)</li>
<li><a href="https://syntax.fm/">Syntax.fm</a> (Wes Bos und Scott Tolinski)</li>
</ul>
</div>
<div class="chapter">
  <h1 id="tools-und-frameworks">Tools und Frameworks</h1>
<p>Um React herum haben sich mittlerweile ein ganzes Ökosystem an Tools gebildet. Vom Static Site Generator, um simple bis medium-komplexe statische Websites auf Basis von React-Komponenten zu erzeugen über Prototyping-Tools bis hin zu Tools, um die Komponenten der eigenen Anwendung in einer Art Styleguide übersichtlich darzustellen ist hier vieles vertreten. In diesem Unterkapitel möchte ich eine <em>kurze</em> Übersicht über die bekanntesten Tools und Frameworks aus der React-Welt geben.</p>
<h3 id="storybook">Storybook</h3>
<blockquote>
  <p>Storybook is a development environment for UI components. It allows you to browse a component library, view the different states of each component, and interactively develop and test components.</p>
</blockquote>
<p><strong>Storybook</strong> ist ein Tool zur Erstellung von Isolierten UI-Komponenten für React, Vue.js und Angular. <strong>Storybook</strong> dient dabei als eine Art Sandbox-Umgebung in der Komponenten für sich alleine in sog. <strong>Stories</strong> entwickelt werden können und stellt diese in einem übersichtlichen und einfach zu bedienendem Interface dar. Durch die Isolation wird ein sehr hohes Level an Abstraktion ermöglicht, die es auch erlaubt Edge-cases darzustellen und zu testen.</p>
<p><strong>Lizenz:</strong> MIT (Open Source)  <br />
<strong>URL:</strong> <a href="https://storybook.js.org/">https://storybook.js.org/</a>  <br />
<strong>GitHub:</strong> <a href="https://github.com/storybooks/storybook">https://github.com/storybooks/storybook</a></p>
<h3 id="react-styleguidist">React Styleguidist</h3>
<blockquote>
  <p>React Styleguidist is a component development environment with hot reloaded dev server and a living style guide that you can share with your team.</p>
</blockquote>
<p><strong>Styleguidist</strong> geht in die selbe Richtung wie Storybook. Auch mit Styleguidist ist es möglich einen Styleguide aus den UI Komponenten der eigenen Anwendung zu erstellen. Allerdings ist Styleguidist hier etwas impliziter als Storybook und so wird der Styleguide schon zu einem recht hohen Maß aus den <strong>PropTypes</strong> von Komponenten sowie aus <strong>JSDoc</strong>-Kommentaren angereichert. Für alles weitere dienen dann Markdown Dateien im Ordner der jeweiligen Komponente.</p>
<p><strong>Lizenz:</strong> MIT (Open Source)  <br />
<strong>URL:</strong> <a href="https://react-styleguidist.js.org/">https://react-styleguidist.js.org/</a>  <br />
<strong>GitHub:</strong> <a href="https://github.com/styleguidist/react-styleguidist">https://github.com/styleguidist/react-styleguidist</a></p>
<h3 id="docz">Docz</h3>
<blockquote>
  <p>It has never been so easy to document your things!</p>
</blockquote>
<p>Docz ist ein Tool das, wie der Name es bereits erahnen lässt, zur Dokumentation von Komponenten dient. Auch Docz ist letztlich eine Art Styleguide wie bereits die ersten beiden Tools. Dennoch sticht es irgendwo heraus, denn es ist komplett MDX basiert. MDX ist eine um React-Komponenten erweiterte Version des Markdown-Formats. Komponenten werden in <code>.mdx</code>-Dateien beschrieben und können wie in JavaScript selbst importiert und verwendet werden.</p>
<p><strong>Lizenz:</strong> MIT (Open Source)  <br />
<strong>URL:</strong> <a href="https://docz.site/">https://docz.site/</a>  <br />
<strong>GitHub:</strong> <a href="https://github.com/pedronauck/docz">https://github.com/pedronauck/docz</a></p>
<h3 id="react-cosmos">React Cosmos</h3>
<blockquote>
  <p>Dev tool for creating reusable React components</p>
</blockquote>
<p>Noch ein Stück weiter geht <strong>React Cosmos</strong>. Während die ersten drei genannten Tools ihren Fokus auf die Kapselung und die Darstellung reiner UI-Komponenten legen, bricht React Cosmos diese Kapselung bewusst auf und erlaubt es auch externe Abhängigkeiten wie React Router oder Redux durch das Konzept von <em>Fixtures</em> und <em>Proxies</em> darzustellen und zu testen.</p>
<p><strong>Lizenz:</strong> MIT (Open Source)  <br />
<strong>GitHub:</strong> <a href="https://github.com/react-cosmos/react-cosmos">https://github.com/react-cosmos/react-cosmos</a></p>
<h3 id="gatsby">Gatsby</h3>
<blockquote>
  <p>Gatsby is a free and open source framework based on React that helps developers build blazing fast websites and apps</p>
</blockquote>
<p><strong>Gatsby</strong> gehört in die Kategorie der sog. Static Site Generators, also einem Generator für statische Websites. Diese werden in <strong>Gatsby</strong> aus React-Komponenten und GraphQL erzeugt und bestehen letztendlich aus statischen HTML-Dateien. Dabei erzeugt <strong>Gatsby</strong> auch ein JavaScript-Bundle das beim Aufruf deiner Seite geladen wird. Ist das Bundle erst einmal geladen macht <strong>Gatsby</strong> Gebrauch von clientseitigem Rendering, was zur Folge hat, dass die erzeugten Seiten unglaublich schnell („blazing fast“) angezeigt werden, da ab diesem Zeitpunkt der HTTP-Overhead entfällt. <strong>Gatsby</strong> wurde als Open Source Projekt gestartet (und ist dies auch bis heute) und erhielt als solches im Mai 2018 eine beeindruckende Finanzierung von 3,8 Mio USD.</p>
<p><strong>Lizenz:</strong> MIT (Open Source)  <br />
<strong>URL:</strong> <a href="https://www.gatsbyjs.org/">https://www.gatsbyjs.org/</a>  <br />
<strong>GitHub:</strong> <a href="https://github.com/gatsbyjs/gatsby">https://github.com/gatsbyjs/gatsby</a></p>
<h3 id="react-static">React Static</h3>
<blockquote>
  <p>React-Static is a fast, lightweight, and powerful progressive static site generator based on React and its ecosystem.</p>
</blockquote>
<p><strong>React Static</strong> ist eine Alternative zu <strong>Gatsby</strong>. Auch <strong>React Static</strong> ist ein Static Site Generator mit dem statische Websites basierend auf React generiert werden können. Durch seine hohe Finanzierungsrunde ist Gatsby sicherlich das bekanntere der beiden Tools, jedoch ist auch React Static eine durchaus ernste Alternative in diesem Bereich mit einer großen und sehr aktiven Community.</p>
<p><strong>Lizenz:</strong> MIT (Open Source)  <br />
<strong>GitHub:</strong> <a href="https://github.com/nozzle/react-static">https://github.com/nozzle/react-static</a></p>
<h3 id="nextjs">Next.js</h3>
<p>Next.js bezeichnet sich selbstbewusst als „The React Framework" für diverse Anwendungsfälle wie statische und dynamische Websites, große wie kleine Unternehmen, mobile oder klassische Websites und vieles mehr. Und in der Tat ist dieses Framework in der React-Community mit über 36.000 Stars auf GitHub ein anerkanntes Tool zur Entwicklung von Anwendungen mit React und eine echte Alternative zu Create React App. Anders als CRA kommt Next.js gleich mit Unterstützung von serverseitig gerenderten Seiten, was es insbesondere für SEO relevante Themen interessant werden lässt.</p>
<p><strong>Lizenz:</strong> MIT (Open Source)  <br />
<strong>URL:</strong> <a href="https://nextjs.org/">https://nextjs.org/</a>  <br />
<strong>GitHub:</strong> <a href="https://github.com/zeit/next.js">https://github.com/zeit/next.js</a></p>
</div>

  </body>
</html>
