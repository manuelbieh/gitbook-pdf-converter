<!DOCTYPE html>
<html>
  <head>
    <link href="/assets/style.css" rel="stylesheet" type="text/css" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto:400,500,700"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/styles/github.min.css"
    />
  </head>
  <body>
    <div class="chapter cover">
      <img src="/.gitbook/assets/book-cover.png" id="cover" />
    </div>
    <div class="chapter">
<h1 id="vorwort">Vorwort</h1>
<p>In diesem Buch geht es mir darum einen Einstieg zu ermöglichen, fortgeschrittene Themen aufzugreifen und dabei möglichst React Best-Practices zu vermitteln. Wenn ihr mit dem Buch nicht nur versteht wie etwas funktioniert sondern auch warum, dann habe ich mein Ziel erfüllt. Nun hat jeder Entwickler andere Vorstellungen davon welche Methoden die besten sind und wie man am einfachsten, effizientesten oder schönsten Code schreibt. Allerdings halte ich mich hier stark an die Empfehlungen von den Core-Entwicklern bei Facebook, die die ebenfalls von der Community gut angenommenen Empfehlungen von AirBnB und noch einiger anderer Größen aus der „React-Szene“. Alles gewürzt mit einer Prise eigener Erfahrung.</p>
<p>So gibt es bspw. mehrere Wege wie man seine Anwendung später publiziert, ob man es mit Tools wie <strong>Browserify</strong> oder <strong>Webpack</strong> zu einem Bundle packt oder nicht. Ob man seine Komponenten als ES2015-Klassen schreibt oder <code>createClass</code> aus „ES5-Zeiten“ verwendet. Dort wo ich es für sinnvoll erachte, werde ich auf die diversen gängigen Methoden eingehen um nicht nur Wege vorzugeben sondern auch Alternativen aufzuzeigen.</p>
<p>Ich möchte hier jedoch primär möglichst auf die modernsten, aktuellsten und in den meisten Fällen auch einfachsten Methoden eingehen, weshalb ich für die meisten Code-Beispiele von einem Setup mit <strong>Webpack</strong>, <strong>Babel</strong> und <strong>ES2015</strong> (und neuer) ausgehen werde, das ich im weiteren Verlauf aber noch einmal sehr genau beschreiben werde. Wer zuvor nie mit ES2015+ in Berührung kam wird sicherlich einen Augenblick länger benötigen die Beispiele zu verstehen, ich werde mich indes bemühen alle Beispiele verständlich zu halten und auch auf ES2015+ noch genauer eingehen. JavaScript-Grundkenntnisse sollten jedoch bei der Lektüre vorhanden sein.</p>
<p>Dieses Buch deckt außerdem nur das Thema <strong>Einstieg in React</strong> ab und bietet keinen Einstieg in JavaScript. Grundsätzliche und an einigen wenigen Stellen sicherlich auch etwas tiefergehende Kenntnisse in JavaScript werden daher vorausgesetzt, wobei ich alles möglichst einsteigerfreundlich erkläre, auch wenn man bisher nur einigermaßen oberflächlich mit JavaScript in Kontakt war. Ich setze nicht voraus, dass jeder Leser fehlerfrei erklären kann wie ein JavaScript-Interpreter funktioniert, ich gehe aber sehr wohl davon aus, dass der Leser einigermaßen darüber Bescheid weiß, wie Scopes in JavaScript funktionieren, was ein Callback ist, wie <code>Promise.then()</code> und <code>Promise.catch()</code> funktionieren und wie das Prinzip asynchroner Programmierung mit JavaScript funktioniert.</p>
<p><strong>Aber keine Sorge:</strong> das klingt komplizierter als es am Ende eigentlich ist. Jeder Leser der in der Vergangenheit bereits bspw. mit jQuery gearbeitet hat, sollte beim größten Teil dieses Buches keine Verständnisprobleme haben und meinen Erklärungen folgen können.</p>
</div><div class="chapter">
<h1 id="über-den-autor">Über den Autor</h1>
<p><strong>Manuel Bieh,</strong> seit 2012 als Freelancer im Bereich Frontend-/JavaScript-Entwicklung tätig.</p>
<p>Bevor ich mich dazu entschied als Freelancer zu arbeiten hatte ich ebenfalls bereits fast 10 Jahre Erfahrung als Web-Entwickler, meist mit dem Fokus auf Frontend-Entwicklung, in verschiedenen Unternehmen gesammelt. Lange Zeit habe ich mich eher als Generalist statt als Spezialist gesehen und so gab und gibt es wenige bekannte Frontend-Technologien mit denen ich während meiner beruflichen Laufbahn nicht schon mal zumindest kurz in Berührung gekommen wäre. Als Spezialist habe ich mich aber außer wenn es generell um JavaScript geht nirgendwo gesehen. Dies änderte sich dann schlagartig als mir ein befreundeter Entwickler in 2014 erstmals von React erzählte und ich dann durch Neugierde und ganz konkret durch ein Projekt für Zalando erstmals intensiver mit React in Kontakt kam.</p>
<p>Anfangs fremdelte ich noch etwas, so wie übrigens viele, die neu in React einsteigen, doch je länger und intensiver ich mich mit React auseinandersetzte, desto mehr schlug meine anfängliche Skepsis in Begeisterung um. Seitdem hat mich React so gepackt, dass seitdem meine Projekte allesamt so ausgewählt habe, dass dort React im Einsatz ist (und dessen Einsatz auch sinnvoll ist!). In dieser Zeit habe ich viel gelernt (und lerne auch immer noch jeden Tag dazu), habe dabei in kleinen Teams mit unter 5 und in recht großen Teams mit über 30 Leuten gearbeitet und dort mein React-Wissen eingebracht und selbst immer wieder neue Eindrücke und Wissen mitgenommen.</p>
<p>Die Komplexität von React ist dabei aber nicht zu unterschätzen. Und so ist es zwar möglich relativ schnell in ziemlich kurzer Zeit eine Anwendung mit React zu entwickeln. Wenn man aber Wert auf hohe Qualität legt gibt es dort viele Stellschrauben an denen man drehen kann um Code-Qualität, Performance und Wartbarkeit zu erhöhen, die teilweise auch Leuten nicht bekannt sind die schon viel und lange mit React entwickelt haben. Und so würde ich mich selbst nach mehrjähriger intensiver und täglicher Arbeit mit React sicher noch immer nicht als absoluten Experten bezeichnen. Aber ich denke, dass mit der Zeit dennoch genug Wissen zusammengekommen ist welches ich in Form dieses Buches weitergeben kann um euch den Einstieg zu erleichtern und auch noch den einen oder anderen Profi-Tipp an die Hand zu geben.</p>
</div><div class="chapter">
<h1 id="einführung">Einführung</h1>
<h2 id="was-ist-react-eigentlich-und-was-ist-es-nicht">Was ist React eigentlich und was ist es nicht?</h2>
<p>Zitieren wir hier an erster Stelle mal die React-Dokumentation, denn die bringen es sehr prägnant auf den Punkt:</p>
<blockquote>
  <p>[React is] a library for building user interfaces.</p>
</blockquote>
<p>Auch wenn die Erklärung sehr kurz ist kann man aus ihr alle essentiellen Dinge ableiten die wichtig sind für die Arbeit mit React und um zu verstehen worum es sich dreht. React ist erst einmal nur eine Library, kein vollständiges Framework mit unzähligen Funktionen mit dem ihr ohne weitere Abhängigkeiten komplexe Web-Anwendungen entwickeln könnt. Und da kommen wir auch schon zum zweiten Teil des Satzes: for building user interfaces.</p>
<p>React ist also erst einmal lediglich eine <strong>Library</strong> die es euch einfach macht <strong>Benutzerinterfaces</strong> zu entwickeln. Keine Services oder Methoden um API-Calls zu machen, keine built-in Models oder ORM. Nur User Interfaces. Sozusagen nur der View-Layer eurer Anwendung. That’s it! In diesem Zusammenhang liest man gelegentlich, dass React das „V“ in <strong>MVC</strong> (<em>Model-View-Controller</em>) oder <strong>MVVM</strong> (<em>Model-View-ViewModel</em>) darstellt. Das trifft es in meinen Augen ganz gut.</p>
<p>React bietet einen <strong>deklarativen</strong> Weg um den <strong>Zustand</strong> (<em>State</em>) eines User Interfaces zu beschreiben. Vereinfacht gesagt bedeutet das, ihr beschreibt mit eurem Code im Grunde explizit wie euer User Interface aussehen soll, abhängig davon in welchem State eine Komponente sich befindet. Einfaches Beispiel zur Veranschaulichung dieses Prinzips: ist ein Benutzer eingeloggt, zeige das Dashboard, ist er es nicht, zeige das Login-Formular.</p>
<p>Die Logik selbst befindet sich dabei komplett im JavaScript-Teil der Anwendung (dort, wo sie also immer hingehören sollte) und nicht in den Templates selbst, wie das bei den allermeisten anderen Web-Frameworks die Regel ist. Klingt erst einmal kompliziert, wird aber im weiteren Verlauf immer deutlicher was damit eigentlich gemeint ist.</p>
<p>React arbeitet dabei komponentenbasiert, d.h. man entwickelt gekapselte funktionale Komponenten die beliebig zusammengestellt (composed) und wiederverwendet werden können. Erweiterung von Komponenten ist zwar möglich, jedoch sehr unüblich in der React-Welt. Hier wird auch von offizieller Seite das Composition Model propagiert, bei dem mehrere Komponenten zu einem „Gesamtbild“ zusammengefügt werden statt mit Inheritance, also Vererbung zu arbeiten.</p>
<p>Bedeutet das jetzt also, dass ich keine komplexen Web-Anwendungen mit React entwickeln kann? Nein. Absolut nicht. React besitzt ein sehr großes, sehr aktives und zum großen Teil auch sehr hochqualitatives Ecosystem an Libraries, die wiederum auf React basieren, es erweitern oder ergänzen und so zu einem mächtigen Werkzeug werden lassen, das sich hinter großen Frameworks wie Ember oder Angular nicht verstecken braucht. Im Gegenteil. Ist man erst einmal in die Welt des React-Ökosystems eingetaucht und hat sich einen Überblick verschafft, hat man ganz schnell eine Reihe an wirklich guten Tools und Libraries gefunden mit denen man professionelle, super individuelle und hochkomplexe Anwendungen entwickeln kann.</p>
<h2 id="wann-sollte-ich-react-benutzen-und-wann-nicht">Wann sollte ich React benutzen und wann nicht?</h2>
<p>Insbesondere kurz nachdem React an Fahrt aufnahm wurde oft die Frage gestellt ob die Tage von jQuery nun gezählt sind, ob man nun alles mit React entwickeln kann oder gar soll oder wann der Einsatz von React sinnvoll oder vielleicht auch gar nicht sinnvoll ist.</p>
<p>React ist, wie wir bereits geklärt haben erst einmal eine Library für die Erstellung von User Interfaces. User Interfaces bedeuten immer Interaktion. Und Interaktion geht zwangsweise in den meisten Fällen einher mit State-Management. Ich drücke einen Knopf und ein Dropdown öffnet sich. Ich ändere also den Zustand von <em>geschlossen</em> auf <em>offen</em>. Ich gebe Daten in ein Eingabefeld ein und bekomme angezeigt ob meine eingegebenen Daten valide sind. Sind sie es nicht, ändert sich der Zustand des Eingabefeldes von <em>gültig</em> in <em>ungültig</em>. Und genau hier kommt React ins Spiel. Habe ich keine Interaktion oder „sich ändernde Daten“ auf meiner Seite weil ich z.B. eine reine statische Image-Seite für ein Unternehmen entwickle, brauche ich <em>wahrscheinlich</em> kein React.</p>
<p>Falsch umgesetzt kann React hier sogar schaden, da auf einer Image-Website oftmals der Content im Vordergrund steht und sofern man seine React-Komponenten nicht bereits serverseitig vorrendert, können die meisten Suchmaschinen mit der Seite erst einmal wenig anfangen. React macht es uns aber glücklicherweise sehr einfach unsere Komponenten serverseitig zu rendern, von daher ist das noch ein Problem welches sich in der Regel leicht beheben lässt.</p>
<p>Habe ich hingegen sehr viel Interaktion und ein Interface das sich oft aktualisiert, wird der Einsatz von React mit ziemlich hoher Wahrscheinlichkeit sehr viel Zeit und Nerven sparen. Grundsätzlich gilt hier die Faustregel: je mehr Interaktion in einer Website oder Web-Anwendung stattfindet und je komplexer diese ist, desto mehr lohnt sich der Einsatz von React. Das griffigste Beispiel sind hier <strong>Single Page Applications</strong> (<em>SPA</em>), bei denen die Anwendung nur einmal im Browser aufgerufen und initialisiert wird und jegliche weitere Interaktion und Kommunikation mit dem Server über XHR (den meisten besser bekannt als „AJAX-Requests“) abläuft.</p>
<p>Ich habe es kürzlich selbst in einem Projekt erlebt, dass ich ein Anmeldeformular entwickeln musste, welches mir ziemlich simpel erschien und ich startete erst einmal ohne React. Im Laufe der Entwicklung stellte sich heraus, dass zum Zwecke besserer Usability immer mehr (Hintergrund-)Interaktion nötig wurde. So sollte bspw. nachträglich eine automatische Live-Validierung von Formulardaten eingebaut und der Anmeldeprozess in 2 Schritte unterteilt werden, so dass ich recht zügig dann doch auf React zurückgegriffen habe, weil mir das manuelle State-Management und die <strong>imperative</strong> Veränderung des User Interfaces einfach zu umständlich wurde.</p>
<p>Imperativ bedeutet in dem Fall, dass ich dem Browser sage was er machen soll, wohingegen ich bei <em>deklarativem</em> Code, wie man ihn mit React schreibt, lediglich das gewünschte Endergebnis anhängig vom aktuellen Zustand beschreibe. Eines der Kernprinzipien von React. Um beim Beispiel von oben zu bleiben: statt zu sagen „ich bin nun eingeloggt, lieber Browser, bitte blende nun das Login-Formular aus und zeige mir das Dashboard“, definiere ich zwei Ansichten: So, lieber Browser, soll mein Interface aussehen wenn ich eingeloggt bin (Dashboard-Ansicht) und so, wenn ich es nicht bin (Login-Ansicht). Welche der Ansichten angezeigt wird entscheidet dann React anhand des Zustands der Komponente.</p>
<h2 id="wo-hat-react-seinen-ursprung">Wo hat React seinen Ursprung?</h2>
<p>React wurde ursprünglich von bzw. bei <strong>Facebook</strong> entwickelt und später dann, bereits 2013, unter der BSD Lizenz als Open Source der Öffentlichkeit zugänglich gemacht, die nach einigen Protesten in eine MIT-Lizenz geändert wurde. Und so basiert auch ein sehr großer Teil von Facebook auf React. Mittlerweile sollen sich dort sogar über <strong>50.000</strong> eigene Komponenten im Einsatz befinden. Was insofern schön ist, als dass Facebook dadurch natürlich ein großes Interesse an der permanenten Weiterentwicklung hat und man nicht befürchten muss, dass man seine Anwendung auf Basis einer Technologie entwickelt hat die plötzlich nicht mehr weiterentwickelt wird.</p>
<p>Die React Core-Entwickler leisten dabei sehr gute Arbeit darin, die Community frühzeitig in Entscheidungen mit einzubeziehen und mitdiskutieren zu lassen. Eigens dazu gibt es ein Github-Repository mit <a href="https://github.com/reactjs/rfcs">React RFCs</a> („Request for Comments“), mittels dessen geplante Änderungen frühzeitig zur Diskussion gestellt werden und mittels dessen dem React-Team auch eigene Vorschläge unterbreitet werden können.</p>
<p><strong>Breaking Changes</strong>, also Änderungen die nicht abwärtskompatibel sind, folgen einem festen <em>Deprecation Schema</em> und so werden Methoden, Eigenschaften und Funktionen deren Entfernung geplant ist erst einmal für einige Zeit mit aussagekräftigen <strong>Deprecation Warnings</strong> versehen und sogar Tools bereitgestellt, mit denen sich alter Code weitestgehend automatisiert anpassen lässt (<a href="https://github.com/reactjs/react-codemod">React-Codemod</a>). React hält sich hier strikt an Semver-Konventionen.</p>
<p>Dies bedeutet das nur neue Major-Releases (<code>16.x.x</code> auf <code>17.x.x</code>) Breaking Changes enthalten, Minor-Releases (bspw. <code>16.2.x</code> auf <code>16.3.x</code>) enthalten neue Features oder bekommen Deprecation Warnings, die den Entwickler auf kommende Major-Releases vorbereiten während Patch-Releases (bspw.<code>16.3.0</code> auf <code>16.3.1</code>) lediglich Bugfixes beinhalten.</p>
<p>Vor dem Release von Major oder Minor Releases gibt es regelmäßig auch alpha, beta und rc (Release Candidate) Versionen, mit denen man vorab schon einen Blick auf kommende Features werfen kann. Diese sind aber jeweils mit Vorsicht zu genießen, da sich die Funktionsweise neuer Features bis zum endgültigen Release noch ändern könnten.</p>
<p class="has-image"><span><img src="https://lh4.googleusercontent.com/Hr0ay3GzvzT9N28o2JJldO6pwPaj9hj2xyQh0F3L11-2HDuS3ftjaUOJ0xRpv7oYNobcPdrMBAGcXKUOBUBq_cLK1i__A0nFhzGB7sT0blghpGFQshzqJrQPaOg0hAyV7UgD8tu0" alt="Beispiel für eine Deprecation Warning" /><span class="caption">Beispiel für eine Deprecation Warning</span></span></p>
<p>Dies ist sicher dem Umstand geschuldet, dass eben auch bei Facebook sehr viele React-Komponenten im Einsatz sind und man dort nicht einfach mal eben tiefgreifende Änderungen vornehmen kann ohne Probleme zu verursachen. Die Gedanken und Begründungen der Entwickler lassen sich dabei jederzeit ausführlich im Github Issue-Tracker verfolgen, alle wichtigen Änderungen werden dabei in sog.<a href="https://github.com/facebook/react/issues?utf8=%E2%9C%93&q=is%3Aissue%20is%3Aopen%20umbrella"> Umbrella-Tickets</a> zusammengefasst.</p>
</div><div class="chapter">
<h1 id="ab-ins-kalte-wasser">Ab ins kalte Wasser</h1>
<p>Nun hatten wir bereits das „Was“, das „Wann“ und das „Wo“. Kommen wir also zum „Wie“ und schreiben unsere erste kleine <strong>React-Komponente</strong>. Neben <strong>React</strong> selbst benötigen wir für die Ausgabe unserer App im Browser auch das Package <strong>ReactDOM</strong> um unsere Anwendung <strong>mounten</strong> zu können, also grob gesagt: im Browser nutzbar zu machen.</p>
<p>Ein sehr minimalistisches Setup um schnell mit React loslegen zu können, sieht wie folgt aus:</p>
<pre><code class="hljs markup language-markup"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Hallo React!<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">crossorigin</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/react@16.3.0/umd/react.development.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">crossorigin</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/react-dom@16.3.0/umd/react-dom.development.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">
<span class="hljs-comment">// Platzhalter für unsere erste Komponente</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Wir erstellen also das Grundgerüst für ein gewöhnliches HTML-Dokument und laden <strong>React</strong> und <strong>ReactDOM</strong> in der jeweils aktuellsten Stable-Version vom unpkg-CDN die uns dann jeweils als globale Variable im <code>window</code> Objekt unter <code>window.React</code> und <code>window.ReactDOM</code> zur Verfügung stehen. Ansonsten sehen wir hier vorerst nur eine leere Seite mit einem (noch inhaltlosen) <code>&lt;div id="app"&gt;</code>. Dieses div nutzen wir gleich als sogenannte <strong>Mount-Node</strong>, um dort unsere erste React-Komponente anzuzeigen.</p>
<div class="hint hint--info">
<p>Sind mehrere React-Komponenten im Spiel redet man üblicherweise von einer <strong>App</strong>, <strong>WebApp</strong> oder <strong>Single Page App</strong>. Die Grenzen ab wann eine Komponente als App bezeichnet wird sind dabei aber fließend. Einige Entwickler reden auch schon bei einer einzigen Komponente von einer App.
Eine feste Definition gibt es dafür nicht.</p>
</div>
<p>Starten wir also klassischerweise mit dem üblichen „Hello World“ Beispiel und setzen das Script an die Stelle an der sich oben der Platzhalter befindet:</p>
<pre><code class="hljs javascript language-javascript">&lt;script&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> React.createElement(<span class="hljs-string">'div'</span>, {<span class="hljs-attr">id</span>: <span class="hljs-string">'hello-world'</span>}, <span class="hljs-string">'Hello World'</span>);
  }
}
ReactDOM.render(
  React.createElement(HelloWorld),
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'app'</span>)
);
<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre>
<p>Und damit haben wir bereits die erste einfache React-Komponente implementiert! Setzen wir diesen Code nun an die Stelle unseres Platzhalters aus dem vorangegangenen Code-Snippet. Sehen wir im Browser die folgende Ausgabe:</p>
<p class="has-image"><span><img src="https://lh5.googleusercontent.com/ELTAFiAHh3_lN8ETxYyNxvdSHs9-ZRzdmEZG_43ecDI3tkbJWtqLoaELcyMkKIKQcxyVs0kiaw9WYG_Ms5y8iUUId2mIh5-PiAunsc7XwlQ5BVS51YHi4S3LUcY-Vocb7VbCFqJJ" alt="Unsere erste React-Komponente im Browser." /><span class="caption">Unsere erste React-Komponente im Browser.</span></span></p>
<p>Sieht für’s Erste einmal gar nicht so kompliziert aus, oder? Gehen wir den Code einmal Schritt für Schritt durch. Die relevanten Stellen im Code habe ich fett hervorgehoben.</p>
<blockquote>
  <p><code>class HelloWorld</code></p>
</blockquote>
<p>Hier geben wir dem Kind seinen Namen. Unsere Komponente hat in dem Fall den Namen <strong>HelloWorld</strong>. Bei der Namensgebung sind der Fantasie grundsätzlich keine Grenzen gesetzt, doch Achtung: React-Komponenten müssen stets mit einem Großbuchstaben beginnen! So wäre helloWorld also kein gültiger Name für eine Komponente, HELLOWORLD hingegen schon (wenn auch sehr unüblich).</p>
<p>Die gängige Art der Benennung von Komponenten folgt der <strong>UpperCamelCase</strong>-Form. Auch längere, selbsterklärende Namen sind nicht unüblich. So wäre also ein Name wie <strong>UserNotificationView</strong> für eine Komponente keineswegs exotisch.</p>
<blockquote>
  <p><code>extends React.Component</code></p>
</blockquote>
<p>Hier erweitern wir schließlich die React interne Klasse <code>React.Component</code> wodurch unsere Klasse erst einmal zu einer Komponente wird die wir in React nutzen können. Neben der <code>React.Component</code> gibt es außerdem auch die <code>React.PureComponent</code> als Komponenten-Klasse, sowie eine zweite Form, die sogenannte <em>Stateless Functional Component</em>. Diese ist lediglich eine JavaScript-Funktion, die einem bestimmten Muster folgt. Beide werden im weiteren Verlauf noch ausführlich beleuchtet und sind an dieser Stelle zum Grundverständnis erst einmal weniger wichtig.</p>
<blockquote>
  <p><code>render()</code></p>
</blockquote>
<p>Unsere Komponente besteht lediglich aus dem einzigen zwingenden Bestandteil einer Komponente, nämlich der <code>render()</code>-Methode. Mittels dieser wird React mitgeteilt wie die entsprechende Komponente dargestellt (sprich: „gerendert“) werden soll. Eine Komponente hat zwingend einen <code>return</code>-Wert. Dieser kann entweder ein explizites <code>null</code> sein, um bewusst nichts anzuzeigen (jedoch nicht <code>undefined</code>!), ein React-Element oder ab Version 16 auch ein Array.</p>
<p>Im Falle eines Arrays darf dieser Strings, Numbers, React-Elemente oder ebenfalls <code>null</code> als Werte enthalten. Die <code>render()</code>-Methode dient also dazu <strong>deklarativ</strong> den Zustand unseres Interfaces zu beschreiben. All das, was wir aus ihr per <code>return</code> zurückgeben, zeigt uns React beim Render als Ausgabe im Browser an.</p>
<p>Auch wenn man in der Gestaltung seiner JavaScript-Klassen natürlich vollkommen frei ist und dies daher nicht zwingend notwendig ist, so wird die <code>render()</code>-Methode der Übersicht halber in der Regel meist als letzte Methode einer Komponente definiert. So wird es z.B. in den Code-Guidelines von AirBnB, dessen Entwickler in der React-Szene sehr aktiv sind, aber auch von vielen anderen bekannten Entwicklern vorgegeben oder zumindest empfohlen. Aus eigener Erfahrung kann ich sagen, dass es die tägliche Arbeit mit React deutlich erleichtert sich an diese Empfehlung zu halten<strong>.</strong></p>
<p class="has-image"><span><img src="../.gitbook/assets/react-no-render-error.png" alt="Fehlermeldungen bei fehlender render()-Methode" /><span class="caption">Fehlermeldungen bei fehlender render()-Methode</span></span></p>
<p class="has-image"><span><img src="../.gitbook/assets/invalid-react-element.png" alt="Fehlermeldung bei fehlerhafter render()-Methode" /><span class="caption">Fehlermeldung bei fehlerhafter render()-Methode</span></span></p>
<blockquote>
  <p><code>React.createElement()</code></p>
</blockquote>
<p>Wie erwähnt gibt die <code>render()</code>-Methode einer React-<strong>Komponente</strong> in den meisten Fällen ein React-<strong>Element</strong> zurück. React-Elemente sind sozusagen die kleinsten aber dennoch gleichzeitig auch die wesentlichen Bausteine in einer React-Anwendung und beschreiben, was der Benutzer letztendlich auf seinem Bildschirm sieht. Neben <code>React.cloneElement()</code> und <code>React.isValidElement()</code> ist <code>React.createElement()</code> zudem eine von lediglich 3 Top-Level API-Methoden (sieht man von mittlerweile veralteten (<em>deprecated</em>) Methoden einmal ab).</p>
<p>Die Methode erwartet 1-n Parameter:</p>
<ol>
<li>„Typ“, das können HTML-Elemente als String sein, also bspw. <code>'div'</code>, <code>'span'</code> oder <code>'p'</code> aber auch andere React-Komponenten</li>
<li>sog. „Props“, das sind im grundlegenden Sinn schreibgeschützte (<em>readonly</em>) „Eigenschafts-Objekte“ einer Komponente. Abgeleitet vom engl. <em>Properties</em> eben.</li>
<li>sowie beliebig viele Child-Elemente, die selbst wieder React-Elemente, Arrays, Funktionen oder auch einfacher Text sein können. Eine Komponente muss aber nicht zwingend auch Child-Elemente besitzen.</li>
</ol>
<p>Letztendlich ist ein React-Element unter der Haube nichts weiter als ein unveränderliches (<em>immutable</em>) JavaScript-Objekt zur Beschreibung von Eigenschaften, die React mitteilen wie etwas (und was) dargestellt werden soll. React erstellt nach dieser Beschreibung den sog. <strong>Virtual DOM</strong>. Dieser stellt eine Repräsentation des HTML-Baums in Form eines JavaScript-Objekts dar. Dieser Virtual DOM wird anschließend von React dazu verwendet, um möglichst nur die Teile einer Anwendung zu aktualisieren, in denen auch tatsächlich eine Änderung vorgenommen wurde wenn der Benutzer mit der Anwendung interagiert, Daten verändert oder Events auslöst.</p>
<p>Dadurch, dass React nicht einfach bei jeder State-Änderung die komplette Anwendung neu in den DOM schreibt, was aus Performance-Sicht sehr kostspielig wäre, sondern mittels eines <strong>Reconciliation</strong> (zu deutsch etwa <em>„Abgleich“</em>) genannten Prozesses zuvor vergleicht was geändert wurde, somit die Schreibvorgänge auf ein Minimum reduziert, wird ein zum Teil enormer Geschwindigkeitsvorteil erreicht gegenüber anderen Frameworks und Libraries die viele DOM-Operationen vornehmen.</p>
<p>Bei der täglichen Arbeit wird man <code>React.createElement()</code> jedoch für gewöhnlich niemals in dieser Form aufrufen, da uns <strong>JSX</strong>, eine von Facebook entwickelte Syntax-Erweiterung für JavaScript, diese Arbeit abnehmen und massiv erleichtern wird. Dennoch halte ich es für wichtig von ihrer Existenz zu wissen um zu verstehen wie JSX im Hintergrund arbeitet um so mögliche Fehlerquellen ausschließen zu können.</p>
<p>JSX sieht auf den ersten Blick aus wie HTML bzw. XML/XHTML, jedoch mit deutlich erweitertem Funktionsumfang und der Möglichkeit JavaScript-Ausdrücke darin zu verwenden. JSX ist eine Abstraktion um die Art, wie man React-Elemente erstellt, für den Entwickler <strong>deutlich</strong> zu vereinfachen. So würde unser obiges Beispiel:</p>
<p><code>React.createElement('div', {id: 'hello-world'}, 'Hello World');</code></p>
<p>würde in JSX ganz einfach wie folgt geschrieben werden:</p>
<p><code>&lt;div id="hello-world"&gt;Hello World&lt;/div&gt;</code></p>
<p>Was für viele Einsteiger in React erst einmal sehr befremdlich wirkt, ich habe in diesem Zusammenhang mal den schönen Begriff <strong>JSX-Schock</strong> gelesen, stellt sich aber nach etwas Rumspielerei jedoch sehr schnell als unglaublich praktisch heraus und ist meines Erachtens einer der wesentlichen Gründe warum React letztendlich so viel an Beliebtheit in so kurzer Zeit gewonnen hat.</p>
<p>Zurück zum Wesentlichen: unsere Komponente bekommt hier also über den <code>return</code>-Wert der <code>render()</code>-Methode mitgeteilt, dass sie ein Element vom typ <code>div</code> mit der id <code>hello-world</code> und dem Child-Element (in dem Fall ein Textknoten) mit dem Inhalt <code>Hallo Welt</code> darstellen soll.</p>
<blockquote>
  <p><code>ReactDOM.render(Element, Container)</code></p>
</blockquote>
<p>Zu guter Letzt kommt mit <code>ReactDOM</code> die zweite Library ins Spiel. <strong>ReactDOM</strong> ist zuständig für das Zusammenspiel von React mit dem DOM (<em>Document Object Model</em>), also oberflächlich ausgedrückt: dem <strong>Web-Browser</strong>. Wie auch schon React selbst besitzt ReactDOM nur sehr wenige Top-Level API-Methoden. Wir konzentrieren uns vorerst mal auf die <code>render()</code>-Methode, die sozusagen das Herzstück von ReactDOM im Browser ist.</p>
<p>Trotz der Namensgleichheit hat diese <strong>erst einmal nicht direkt</strong> etwas mit der Methode innerhalb von React-Komponenten zu tun sondern dient lediglich dazu ein React-Element in eine angegebene <strong>„Root-Node“</strong> zu rendern, also stumpf ausgedrückt: anzuzeigen. In unserem Fall wird hier unsere <code>HelloWorld</code>-Komponente in das <code>&lt;div id="app"&gt;</code> gerendert. Die Root-Node wird dabei <strong>nicht ersetzt</strong>, sondern die Komponente wird <strong>innerhalb des Containers</strong> eingesetzt.</p>
<p><strong>ReactDOM</strong> sorgt also dafür, <strong>dass</strong> wir die angegebene Komponente überhaupt erst einmal im Browser sehen können. <strong>Was</strong> wir dort genau sehen haben wir zuvor in der <code>render()</code>-Methode der Komponente über das angegebene React-Element als <code>return</code>-Wert beschrieben. Beim Aufruf von <code>ReactDOM.render()</code> wird dabei das als ersten Parameter angegebene <strong>React-Element</strong> in den als zweiten Parameter angegebenen <strong>Container</strong> gerendert.</p>
<div class="hint hint--info">
<p>Beim ersten Aufruf der <code>ReactDOM.render()</code> Funktion wird sämtlicher möglicherweise vorhandene Inhalt des Ziel-Containers durch den von React ermittelten, darzustellenden Inhalt ersetzt. Bei jedem weiteren Aufruf verwendet React einen internen Vergleichs-Algorithmus für bestmögliche Effizienz, um nicht die komplette Anwendung vollständig neu zu rendern!</p>
<p>In der Praxis ist das allerdings weniger von Relevanz, da die <code>ReactDOM.render()</code> Funktion bei der Erstellung von Single Page Apps üblicherweise nur einmalig ausgeführt wird, für gewöhnlich beim Laden einer Seite. React verändert dabei auch niemals den Ziel-Container selbst, sondern lediglich dessen Inhalt. Besitzt das Container-Element also eigene Attribute wie Klassen, IDs oder data-Attribute bleiben diese auch nach dem Aufruf von <code>ReactDOM.render()</code> erhalten.</p>
</div>
<p>Damit ist das generelle Funktionsprinzip von React erst einmal erklärt, unsere erste Komponente ist implementiert und im Browser zu sehen!</p>
</div><div class="chapter">
<h1 id="tools-und-setup">Tools und Setup</h1>
<h2 id="tools">Tools</h2>
<p>Um störungsfrei und komfortabel mit React arbeiten zu können sollten einige Bedingungen erfüllt sein. Nicht alles davon ist <strong>zwingend</strong> notwendig, es erleichtert das Entwicklerleben jedoch ungemein, weswegen ich dennoch <strong>dringend</strong> dazu rate und auch bei allen folgenden Beispielen davon ausgehen werde, dass ihr diese Tools installiert habt:</p>
<h3 id="nodejs-und-npm">Node.js und npm</h3>
<p>Node werden die meisten möglicherweise als „serverseitiges JavaScript“ kennen, das ist allerdings nicht die ganze Wahrheit. In erster Linie ist Node einmal eine JavaScript Laufzeitumgebung, die sich eben hervorragend für Netzwerkanwendungen eignet, also klassische Webserver. Darüber hinaus bringt Node auch ein Tool zur Paketverwaltung mit, nämlich <strong>npm</strong>, mit dem sich spielend einfach neue JavaScript-Libraries auf dem eigenen Rechner installieren lassen. Außerdem lassen sich auch eigene Commandline-Scripts damit schreiben und ausführen, was sich später noch als sehr praktisch erweisen wird.</p>
<p>Statt Node direkt zu installieren, empfehle ich nvm (Node Version Manager) für Mac und Linux bzw. nvm-windows für Windows. Nvm hat den Vorteil, dass es einerseite keine Admin-Rechte benötigt um Packages global zu installieren und man andererseits mit einem simplen Befehl auf der Kommandozeile (nvm install [version]) die auf dem System installierte Version aktualisieren kann. Für einer Liste aller verfügbaren Version kannst du ganz einfach nvm ls-remote (Mac/Linux) bzw. nvm list available (Windows) benutzen. Ich empfehle im weiteren Verlaufe dieses Buch die aktuelle LTS (Long Term Support) Version zu benutzen.</p>
<h3 id="yarn">Yarn</h3>
<p>Während Node mit npm bereits einen guten und soliden Package-Manager mitbringt, geht yarn noch ein Stück weiter, bietet besseres caching, dadurch auch bessere Performance, einfachere Kommandos und kommt darüber hinaus, wie React, ebenfalls aus dem Hause Facebook und wurde dort entwickelt u.a. um die Arbeit mit React noch etwas angenehmer zu gestalten. Während alles, was hier im weiteren Verlauf des Buches beschrieben wird, auch mit npm ausgeführt werden kann, würde ich dennoch empfehlen Yarn zu installieren, da dies gerade in React-Kreisen mehr und mehr an Gewicht gewinnt, insbesondere wegen seiner Einfachheit und seiner verbesserten Performance ggü. npm. Sind Node und npm erst einmal installiert, lässt sich Yarn einfach als globales Package über npm installieren:</p>
<p><code>npm install --global yarn</code></p>
<p>oder einfach kurz:</p>
<p><code>npm i -g yarn</code></p>
<p>Wir haben gerade außerdem unser erstes Package installiert. Easy! Das Commandline-Flag <code>--global</code> (bzw. <code>-g</code>) sorgt dabei dafür, dass die <code>yarn</code> Executable global installiert wird und von überall auf eurem Gerät auf der Kommandozeile ausgeführt werden kann.</p>
<h3 id="babel">Babel</h3>
<p>Babel ist ein Tool, das für gewöhnlich lediglich als Dependency (Abhängigkeit) und für gewöhnlich als npm-Paket in React basierten Projekten zum Einsatz kommt und an dieser Stelle nicht explizit installiert werden muss. Babel erlaubt es nicht oder <em>noch</em>-nicht standardkonformen oder noch nicht von allen gängigen Browsern unterstützten JavaScript-Code in interpretierbaren und ausführbaren Code zu <em>transpilieren</em>.</p>
<div class="hint hint--info">
<p>Transpilieren (engl. <em>transpiling</em>) nennt man einen Prozess, bei dem der Sourcecode von einer Sprache in ein entsprechendes funktional identisches Gegenstück einer anderen Sprache umgewandelt wird. In unserem Fall eben von JSX oder ES2015+ in valides, ausführbares und vom Browser unterstütztes JavaScript.</p>
</div>
<p>Babel besteht aus einem Core-Modul (<code>@babel/core</code>) das lediglich einige APIs bereitstellt, die dann von <strong>Plugins</strong> für das entsprechende Transpiling verwendet werden. Diese Plugins werden oft zu sog. <strong>Presets</strong> zusammengefasst, die dann wiederum mehrere Plugins gleichzeitig installieren. Die in React basierten Projekten üblichsten Presets sind <code>@babel/preset-react</code> (um JSX zu lesen und zu übersetzen) und <code>@babel/preset-env</code>, welches abhängig von einer Ziel-Umgebung modernes JavaScript so umschreibt, dass es eben auch ältere Browser verstehen.</p>
<p>Das @-Zeichen vor dem Namen bedeutet dabei, dass es sich um eine Organisation innerhalb der npm Registry (dem npm-Paketverzeichnis) handelt und kann als eine Art Namespace betrachtet werden. Im Fall von Babel findet man dort die offiziellen Pakete die von den Babel-Maintainern dort veröffentlich werden. Bevor Babel in der Version 7 erschien gab es diese Organisation noch nicht und die Pakete wurden mit einem Bindestrich im Namen getrennt. So hieß <code>@babel/preset-react</code> eben <code>babel-preset-react</code>, <code>@babel/core</code> war <code>babel-core</code> usw. Also nicht verwirren lassen, sollte euch in einem Projekt mal <code>babel-core</code> statt <code>@babel/core</code> begegnen. In diesem Fall handelt es sich also einfach um Babel 6 (oder eine ältere Version).</p>
<h3 id="webpack">Webpack</h3>
<p>Webpack ist ebenfalls eins der zentralen Tools im React-Ecosystem ohne das ein effizentes Arbeiten mit React kaum möglich oder zumindest deutlich umständlicher wäre. Hier handelt es sich um einen sog. <strong>Module-Bundler</strong>, der Modul basierte Entwicklung, wie sie manch einer vielleicht bereits aus NodeJS kennen mag, in den Browser bringt. Dadurch wird es ermöglicht Anwendungscode übersichtlich in einzelnen Files zu verteilen, die jeweils ihre Abhängigkeiten über <code>import</code> oder <code>require()</code> in ihren eigenen <strong>Module-Scope</strong> laden und damit innerhalb des Moduls verfügbar machen. Am Ende fällt dann nur noch eine einzelne JavaScript-Datei heraus (auf Wunsch auch mehrere), so dass nicht mehr jede einzelne unserer Komponenten, und das können schnell mal über 100 werden, einzeln über <code>&lt;script src="..."&gt;&lt;/script&gt;</code> im HTML eingebunden werden muss.</p>
<p>Wow. Klingt unfassbar kompliziert, passiert aber nach einigen wenigen Beispielen nahezu intuitiv von ganz allein und hat man sich erst einmal daran gewöhnt, wird man sich fragen wie man jemals ohne Module-Bundler arbeiten konnte.</p>
<p>Neben dem Module-Bundling selbst kann Webpack auch beigebracht werden Dateien mit JSX durch Babel in JavaScript zu transpilieren, Bilder, Stylesheets oder andere Assets in einen build-Ordner zu kopieren der später auf einen Server deployed wird und viele andere Dinge. Wie eine solche Konfiguration aussehen kann beleuchten wir später noch einmal genau, weshalb das Webpack Kommandozeilen-Tool auch an dieser Stelle noch nicht installiert werden muss.</p>
<h3 id="ide-editor-plugins">IDE-/Editor-Plugins</h3>
<p>Alle Bekannten Editoren und IDEs wie bspw. Webstorm, Atom, Visual Studio Code oder Sublime (aber auch so ziemlich jeder andere moderne Editor oder IDE) bietet Plugins oder inzwischen sogar bereits native Funktionen für die bessere Unterstützung für React und JSX. Hier rate ich dringend zur Installation dieser Plugins, da diese in der Regel für deutlich besseres Syntax-Highlighting sorgen, teilweise Code-Vervollständigung und andere Nettigkeiten bieten. In Atom ist das <a href="https://atom.io/packages/language-babel">language-babel</a>, in VS Code gibt es hier u.a. <a href="https://marketplace.visualstudio.com/items?itemName=dzannotti.vscode-babel-coloring">Babel ES6/ES7</a> und in Sublime lohnt sich in Blick auf <a href="https://github.com/babel/babel-sublime">babel-sublime</a>. Nutzt ihr Webstorm, habt ihr seit Version 10 sogar native Unterstützung für React-Syntaxhighlighting.</p>
<h3 id="browser-plugins">Browser-Plugins</h3>
<p>Für den Browser empfehle ich dringend jeweils die React-Devtools für <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">Chrome</a> und <a href="https://addons.mozilla.org/de/firefox/addon/react-devtools/">Firefox</a> zu installieren, für den späteren Verlauf außerdem die Redux-Devtools für beide Browser (<a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd">Chrome</a>, <a href="https://addons.mozilla.org/de/firefox/addon/remotedev/?">Firefox</a>). Die Devtools fügen sich nahtlos als neuer Tab in die bestehenden Browser-Devtools ein und bieten einen enormen Mehrwert beim Debugging von React-Komponenten.</p>
<p class="has-image"><span><img src="../.gitbook/assets/image.png" alt="Chrome mit installierten Devtools-Plugins für React und Redux" /><span class="caption">Chrome mit installierten Devtools-Plugins für React und Redux</span></span></p>
<p>So lässt sich bspw. der State direkt im Browser manipulieren und die Auswirkungen live beobachten. Ich würde soweit gehen und behaupten, dass ein effizientes Debugging ohne die Devtools-Erweiterungen kaum oder sogar gar nicht möglich ist.</p>
<h2 id="setup">Setup</h2>
<p>Manch einer hat in der Vergangenheit darüber gescherzt, dass man gut und gerne Tage damit verbringen kann ein Setup aufzusetzen bevor man die erste Zeile Code schreibt. Und in der Tat: ein ordentliches Setup ist wichtig, bestimmt es doch ein Stück weit auch die Qualität und Wartbarkeit der Anwendung, die man auf Basis seines Setups entwickelt.</p>
<p>Hier hat die große React-Community aber bereits sehr gute Vorarbeit geleistet. Und so listet die Seite JavaScriptStuff aktuell <strong>189 Projekte</strong> in der Rubrik <a href="https://www.javascriptstuff.com/react-starter-projects/"><strong>React Starter Projects</strong></a>. Auch Facebook selbst, bzw. konkret <strong>Dan Abramov</strong>, Core-Entwickler bei Facebook und Autor von <strong>Redux</strong>, ist dort mit <strong>Create-React-App</strong> („CRA“) vertreten. Das Projekt ist mit über 45.000 Stars auf Github mittlerweile so etwas wie der de-facto Standard wenn es um React Starter Projekte geht und beschreibt sich auf Github selbst mit:</p>
<blockquote>
  <p>Create React apps with no build configuration</p>
</blockquote>
<p>Und in der Tat, <strong>Create React App</strong> macht es gerade Einsteigern (aber nicht nur diesen) sehr einfach ein sehr robustes und gutes Setup mit nur einem Befehl auf der Kommandozeile zu erzeugen:</p>
<p><code>yarn create react-app projektname</code></p>
<p>Wer stattdessen npm bevorzugt, muss momentan noch zwei Befehle ausführen:</p>
<p><code>npm install -g create-react-app</code></p>
<p>… um die <strong>Create React App</strong> Executable global zu installieren und anschließend</p>
<p><code>create-react-app projektname</code></p>
<p>Und schon wird im Ordner „<em>projektname</em>“ ein vollständiges React-Setup mit einigen kleinen Beispiel-Komponenten erzeugt. Ich würde empfehlen dies jetzt einfach mal zu tun, denn die ersten Code-Beispiele werden zu Beginn allesamt auf einem gewöhnlichen CRA-Setup basieren und können so recht einfach ausprobiert werden.</p>
<div class="hint hint--warning">
<p>Der Projektname muss den <a href="https://docs.npmjs.com/files/package.json#name">Kriterien für die <code>name</code>-Eigenschaft</a> des <code>package.json</code>-Formats von npm haben. Dies bedeutet, neben einigen anderen Kriterien, er darf nur Kleinbuchstaben beinhalten, keine Leerzeichen und dürfen maximal aus 214 Buchstaben bestehen. Die vollständigen Kriterien finden sich in der npm Dokumentation</p>
</div>
<p>Später werde ich euch dann zeigen wie ihr die <code>eject</code>-Funktion benutzt um eigene Änderungen an der Konfiguration vornehmen zu können. Aber für den Beginn (und auch noch recht weit darüber hinaus) reicht erst einmal das Basis-Setup, da dieses bereits sehr umfangreich ist und viele Themen abdeckt, so dass wir uns weniger mit dem Setup beschäftigen müssen und direkt in den Code eintauchen können.</p>
<p>Nachdem CRA das Basis-Setup erstellt und seine Paket-Abhängigkeiten (<em>Dependencies</em>) installiert hat gibt es uns noch eine kurze Anleitung wie wir mit CRA an unserem ersten React-Projekt arbeiten können.</p>
<p class="has-image"><span><img src="https://lh6.googleusercontent.com/im1UToBbzUiXTseQk1AZTD2_WvPVnImgokKU-HLPHPzS06C-H9xdoyL0-xn8q4iDsFCCKXKxERxmuRE7Co0nJTTI1aPEaMg99aS5QXa9xYlwkS0JRVjTV0DM8Yuv8Z83FTgJ8XPN" alt="Create-React-App ist bereit!" /><span class="caption">Create-React-App ist bereit!</span></span></p>
<h3 id="yarn-start">yarn start</h3>
<p>Hiermit starten wir einen Entwicklungs-Server über den wir unsere neu erstellte App im Browser aufrufen können. Dieser kümmert sich auch darum alle Dateien im Ordner zu beobachten und unsere App mit all seinen Abhängigkeiten neu zu „kompilieren“ sobald wir eine Änderung an einem der Files vornehmen.</p>
<h3 id="yarn-build">yarn build</h3>
<p>Erstellt einen Build unserer App, die wir dann bspw. auf einen öffentlichen Server deployen können. Dieser Build ist gegenüber dem Development-Build (<code>yarn start</code>) auf Performance optimiert, weswegen das Ausführen von <code>yarn build</code> für gewöhnlich deutlich länger dauert als <code>yarn start</code>.</p>
<h3 id="yarn-test">yarn test</h3>
<p>Führt Tests aus. Als Test-Framework bringt CRA das ebenfalls von Facebook entwickelte <strong>Jest</strong> mit. Jest bringt hier aus meiner Sicht einen sehr entschiedenen Vorteil mit gegenüber anderen Testing-Frameworks, nämlich das sog. <strong>Snapshot-Testing</strong> bei dem sozusagen eine Art <em>Abbild</em> des aktuellen Zustands einer Komponente erstellt wird, der den Status Quo darstellt und mit dem zukünftige Test-Zustände verglichen werden. So fallen Änderungen, gewünschte wie ungewünschte, sofort ins Auge.</p>
<h3 id="yarn-eject">yarn eject</h3>
<p>Mit <code>yarn eject</code> können wir uns von Create-React-App „verabschieden“. Dabei werden alle build-Scripts, Dependencies und Config-Files in das aktuelle Projektverzeichnis kopiert und wir sind fortan selbst verantwortlich das alles korrekt läuft. Dadurch haben wir mehr Verantwortung, aber eben auch deutlich mehr Freiheiten, da wir von nun an eigene Änderungen an der Standard-Konfiguration von CRA vornehmen können. Da CRA aber schon sehr viel mitbringt, werden wir mit diesem Schritt in diesem Buch noch eine ganze Weile warten, bis wir beim Kapitel angekommen sind in der es um die Konfiguration von Webpack und Co. geht.</p>
</div><div class="chapter">
<h1 id="die-grundlagen">Die Grundlagen</h1>
</div><div class="chapter">
<h1 id="exkurs-es2015">Exkurs ES2015+</h1>
<h2 id="das-„neue“-javascript">Das „neue“ JavaScript</h2>
<p><strong>ES2015</strong> ist kurz gesagt eine modernisierte, aktuelle Version von JavaScript mit vielen neuen Funktionen und Syntax-Erleichterungen. <strong>ES2015</strong> ist der Nachfolger von <strong>ECMAScript</strong> in der Version 5 (<strong>ES5</strong>), hieß daher ursprünglich auch einmal <strong>ES6</strong> und wird auch in einigen Blogs und Artikeln immer noch so bezeichnet. Stößt du also beim Lesen von Artikeln zu React auf den Begriff <strong>ES6</strong> ist damit <strong>ES2015</strong> gemeint. Ich schreibe hier meist von <strong>ES2015+</strong> und meine damit Änderungen die seit 2015 in JavaScript eingeflossen sind. Dazu gehören ES2016 (ES7), ES2017 (ES8) und ES2018 (ES9).</p>
<div class="hint hint--info">
<p>Das <strong>ES</strong> in <strong>ES2015</strong> und <strong>ES6</strong> steht für <strong>ECMAScript</strong>. Die ECMA International ist die Organisation, die hinter der Standardisierung der <strong>ECMA-262</strong> Spezifikation steht, auf der JavaScript basiert. Seit 2015 werden jährlich neue Versionen der Spezifikation veröffentlicht die aus historischen Gründen erst eine fortlaufende Versionsnummer beginnend ab Version 1 hatten, dann jedoch für mehr Klarheit die Jahreszahl ihrer Veröffentlichung angenommen haben. So wird <strong>ES6</strong> heute offiziell als <strong>ES2015</strong> bezeichnet, <strong>ES7</strong> als <strong>ES2016</strong>, usw.</p>
</div>
<p>Wer mit React arbeitet nutzt in vermutlich 99% der Fälle auch <strong>Babel</strong> als <strong>Transpiler</strong> um sein <strong>JSX</strong> entsprechend in <code>createElement()</code>-Aufrufe zu transpilieren. Doch <strong>Babel</strong> transpiliert nicht nur <strong>JSX</strong> in ausführbares JavaScript, sondern hieß ursprünglich mal <strong>6to5</strong> und hat genau das gemacht: mit <strong>ES6</strong>-Syntax geschriebenes JavaScript in <strong>ES5</strong> transpiliert, so dass neuere, zukünftige Features und Syntax-Erweiterungen auch in älteren Browsern ohne Unterstützung für „das neue“ JavaScript genutzt werden konnten.</p>
<p>Auf die meiner Meinung nach wichtigsten und nützlichsten neuen Funktionen und Möglichkeiten in <strong>ES2015</strong> und den folgenden Versionen möchte ich in diesem Kapitel eingehen. Dabei werde ich mich auf die neuen Funktionen beschränken, mit denen man bei der Arbeit mit React häufiger zu tun haben wird und die euch Entwicklern das Leben am meisten vereinfachen.</p>
<p><strong>Wenn du bereits Erfahrung mit ES2015 und den nachfolgenden Versionen hast kannst du dieses Kapitel überspringen!</strong></p>
<h2 id="variablen-deklarationen-mit-let-und-const">Variablen-Deklarationen mit let und const</h2>
<p>Gab es bisher nur <code>var</code> um eine Variable zu deklarieren in JavaScript, kommen in ES2015 zwei neue Schlüsselwörter dazu mit denen Variablen deklariert werden können: <code>let</code> und <code>const</code>. Eine Variablendeklaration mit <code>var</code> wird dadurch in fast allen Fällen überflüssig, meist sind <code>let</code> oder <code>const</code> die sauberere Wahl. Doch wo ist der Unterschied?</p>
<p>Anders als <code>var</code> existieren mit <code>let</code> oder <code>const</code> deklarierte Variablen <strong>nur innerhalb des Scopes in dem sie deklariert wurden!</strong> Ein solcher Scope kann eine Funktion sein wie sie bisher auch schon bei <code>var</code> einen neuen Scope erstellt hat aber auch Schleifen oder gar <code>if</code> Statements!</p>
<p><strong>Grobe Merkregel:</strong> überall dort wo man eine öffnende geschweifte Klammer findet, wird auch ein neuer Scope geöffnet. Konsequenterweise schließt die schließende Klammer diesen Scope wieder. Dadurch sind Variablen deutlich eingeschränkter und gekapselter, was für gewöhnlich eine gute Sache ist.</p>
<p>Möchte man den Wert einer Variable nochmal überschreiben, beispielsweise in einer Schleife, ist die Variable dafür mit <code>let</code> zu deklarieren. Möchte man die Referenz der Variable unveränderbar halten, sollte <code>const</code> benutzt werden.</p>
<p>Doch Vorsicht: anders als bei anderen Sprachen bedeutet <code>const</code> nicht, dass der komplette Inhalt der Variable konstant bleibt. Bei Objekten oder Arrays kann deren Inhalt auch bei mit <code>const</code> deklarierten Variablen noch verändert werden. Es kann lediglich das Referenzobjekt auf welche die Variable zeigt nicht mehr verändert werden.</p>
<h3 id="der-unterschied-zwischen-letconst-und-var">Der Unterschied zwischen <code>let</code>/<code>const</code> und <code>var</code></h3>
<p>Erst einmal zur Demonstration ein kurzes Beispiel wie sich die Variablendeklaration von <code>let</code> und <code>const</code> von denen mit <code>var</code> unterscheiden und was es bedeutet, dass erstere nur in dem Scope sichtbar sind, in dem sie definiert wurden:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {}
<span class="hljs-built_in">console</span>.log(i);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p>10</p>
</div>
<p>Nun einmal dasselbe Beispiel mit <code>let</code></p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) {}
<span class="hljs-built_in">console</span>.log(j);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--danger">
<p>Uncaught ReferenceError: <code>j</code> is not defined</p>
</div>
<p>Während auf die Variable <code>var i</code>, einmal definiert, auch außerhalb der <code>for</code>-Schleife zugegriffen werden kann, existiert die Variable <code>let j</code> nur innerhalb des Scopes in dem sie definiert wurde. Und das ist in diesem Fall innerhalb die <code>for</code>-Schleife, die einen neuen Scope erzeugt.</p>
<p>Dies ist ein kleiner Baustein der uns später dabei helfen wird unsere Komponenten gekapselt und ohne ungewünschte Seiteneffekte zu erstellen.</p>
<h4 id="unterschiede-zwischen-let-und-const">Unterschiede zwischen <code>let</code> und <code>const</code></h4>
<p>Folgender Code ist valide und funktioniert, solange die Variable mittels <code>let</code> (oder <code>var</code>) deklariert wurde:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">let</span> myNumber = <span class="hljs-number">1234</span>;
myNumber = <span class="hljs-number">5678</span>;
<span class="hljs-built_in">console</span>.log(myNumber);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p>5678</p>
</div>
<p>Der gleiche Code nochmal, nun allerdings mit <code>const</code>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> myNumber = <span class="hljs-number">1234</span>;
myNumber = <span class="hljs-number">5678</span>;
<span class="hljs-built_in">console</span>.log(myNumber);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--danger">
<p>Uncaught TypeError: Assignment to constant variable.</p>
</div>
<p>Wir versuchen hier also eine durch <code>const</code> deklarierte Variable direkt zu überschreiben und werden dabei vom JavaScript-Interpreter zurecht in die Schranken gewiesen. Doch was, wenn wir stattdessen nur eine Eigenschaft <em>innerhalb</em> eines mittels <code>const</code> deklarierten Objekts verändern wollen?</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> myObject = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
};
myObject.b = <span class="hljs-number">2</span>;
<span class="hljs-built_in">console</span>.log(myObject);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p><code>{a: 1, b: 2}</code></p>
</div>
<p>In diesem Fall gibt es keinerlei Probleme, da wir nicht die Referenz verändern, auf die die <code>myObject</code> Variable verweisen soll, sondern das Objekt, auf das verwiesen wird. Dies funktioniert ebenso mit Arrays, die verändert werden können, solange nicht der Wert der Variable selbst geändert wird!</p>
<p><strong>Erlaubt:</strong></p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> myArray = [];
myArray.push(<span class="hljs-number">1</span>);
myArray.push(<span class="hljs-number">2</span>);
<span class="hljs-built_in">console</span>.log(myArray);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p><code>[1, 2]</code></p>
</div>
<p><strong>Nicht erlaubt, da wir die Variable direkt überschreiben würden:</strong></p>
<pre><code class="hljs text language-text"><span class="hljs-attribute">const myArray</span> = [];
<span class="hljs-attribute">myArray</span> = Array.concat(1, 2);</code></pre>
<div class="hint hint--danger">
<p>Uncaught TypeError: Assignment to constant variable.</p>
</div>
<p>Möchten wir <code>myArray</code> also überschreibbar halten, müssen wir stattdessen <code>let</code> verwenden oder uns damit begnügen dass zwar der Inhalt des mittels <code>const</code> deklarierten Arrays veränderbar ist, nicht jedoch die Variable selbst.</p>
<h2 id="arrow-functions">Arrow Functions</h2>
<p><strong>Arrow Functions</strong> sind eine weitere <strong>deutliche</strong> Vereinfachung die uns ES2015 gebracht hat. Bisher funktionierte eine Funktionsdeklaration so: man schrieb das Keyword <code>function</code>, optional gefolgt von einem Funktionsnamen, Klammern, in der die Funktionsargumente beschrieben wurden, sowie dem <strong>Function Body</strong>, also dem eigentlichen Inhalt der Funktion:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) </span>{}</code></pre>
<p><strong>Arrow Functions</strong> vereinfachen uns das ungemein, indem sie erst einmal das <code>function</code> Keyword überflüssig machen:</p>
<pre><code class="hljs javascript language-javascript">(arg1, arg2) =&gt; {};</code></pre>
<p>Haben wir zudem nur einen Parameter, sind sogar die Klammern bei den Argumenten optional. Aus unserer Funktion</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg</span>) </span>{}</code></pre>
<p>Würde also die folgende <strong>Arrow Function</strong> werden:</p>
<pre><code class="hljs javascript language-javascript">(arg) =&gt; {};</code></pre>
<p>Jap, das ist eine gültige Funktion in ES2015!</p>
<p>Und es wird noch wilder. Soll unsere Funktion lediglich einen Ausdruck zurückzugeben als <code>return</code>-Wert, sind auch noch die Klammern optional. Vergleichen wir einmal eine Funktion die eine Zahl als einziges Argument entgegennimmt, diese verdoppelt und als <code>return</code>-Wert wieder aus der Funktion zurück gibt. Einmal in ES5:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">double</span>(<span class="hljs-params">number</span>) </span>{
  <span class="hljs-keyword">return</span> number * <span class="hljs-number">2</span>;
}</code></pre>
<p>… und als ES2015 <strong>Arrow Function</strong>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> double = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number * <span class="hljs-number">2</span>;</code></pre>
<p>In beiden Fällen liefert uns die eben deklarierte Funktion beim Aufruf von bspw. <code>double(5)</code> als Ergebnis <code>10</code> zurück!</p>
<p>Aber es gibt noch einen weiteren gewichtigen Vorteil, der bei der Arbeit mit React sehr nützlich sein wird: Arrow Functions haben keinen eigenen Constructor, können also nicht als Instanz in der Form <code>new MyArrowFunction()</code> erstellt werden, und binden auch kein eigenes <code>this</code> sondern erben <code>this</code> aus ihrem <strong>Parent Scope</strong>. Insbesondere Letzteres wird noch sehr hilfreich werden.</p>
<p>Auch das klingt fürchterlich kompliziert, lässt sich aber anhand eines einfachen Beispiels auch recht schnell erklären. Nehmen wir an wir definieren einen Button der die aktuelle Zeit in ein <code>div</code> schreiben soll, sobald ich ihn anklicke. Eine typische Funktion in ES5 könnte wie folgt aussehen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TimeButton</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> button = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn'</span>);
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">this</span>.showTime = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'time'</span>).innerHTML = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  };
  button.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    self.showTime();
  });
}</code></pre>
<p>Da die als <strong>Event Listener</strong> angegebene Funktion keinen Zugriff auf ihren <strong>Parent Scope</strong>, also den <strong>TimeButton</strong> hat, speichern wir hier hilfsweise <code>this</code> in der Variable <code>self</code>. Kein unübliches Muster in ES5. Alternativ könnte man auch den Scope der Funktion explizit an <code>this</code> binden und dem <strong>Event Listener</strong> beibringen in welchem Scope sein Code ausgeführt werden soll:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TimeButton</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> button = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn'</span>);
  <span class="hljs-keyword">this</span>.showTime = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'time'</span>).innerHTML = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  };
  button.addEventListener(
    <span class="hljs-string">'click'</span>,
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.showTime();
    }.bind(<span class="hljs-keyword">this</span>)
  );
}</code></pre>
<p>Hier spart man sich zumindest die zusätzliche Variable <code>self</code>. Auch das ist möglich, aber nicht besonders elegant.</p>
<p>An dieser Stelle kommt nun die <strong>Arrow Function</strong> ins Spiel, die, wie eben erwähnt, <code>this</code> aus ihrem <strong>Parent Scope</strong> erhält, also in diesem Fall aus unserer <code>TimeButton</code>-Instanz:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TimeButton</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> button = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn'</span>);
  <span class="hljs-keyword">this</span>.showTime = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'time'</span>).innerHTML = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  }
  button.addEventListener(<span class="hljs-string">'click'</span>, () {
    <span class="hljs-keyword">this</span>.showTime();
  });
}</code></pre>
<p>Und schon haben wir im <strong>Event Listener</strong> Zugriff auf <code>this</code> des überliegenden Scopes!</p>
<p>Keine <code>var self = this</code> Akrobatik mehr und auch kein <code>.bind(this)</code>. Wir können innerhalb des Event Listeners so arbeiten als befänden wir uns noch immer im <code>TimeButton</code> Scope! Das ist später insbesondere bei der Arbeit mit umfangreichen React-Komponenten mit vielen eigenen Class Properties und Methods hilfreich, da es Verwirrungen vorbeugt und nicht immer wieder einen neuen Scope erzeugt.</p>
<h2 id="neue-methoden-bei-strings-arrays-und-objekten">Neue Methoden bei Strings, Arrays und Objekten</h2>
<p>Mit ES2015 erhielten auch eine ganze Reihe neue statische und prototype-Methoden Einzug in JavaScript. Auch wenn die meisten davon nicht direkt relevant sind für die Arbeit mit React, erleichtern sie die Arbeit aber gelegentlich doch ungemein, weshalb ich hier ganz kurz auf die wichtigsten eingehen möchte.</p>
<h3 id="string-methoden">String-Methoden</h3>
<p>Hat man in der Vergangenheit auf <code>indexOf()</code> oder reguläre Ausdrücke gesetzt um zu prüfen ob ein String einen bestimmten Wert enthält, mit einem bestimmten Wert anfängt oder aufhört, bekommt der String Datentyp nun seine eigenen Methoden dafür.</p>
<p>Dies sind:</p>
<pre><code class="hljs javascript language-javascript">string.includes(value);
string.startsWith(value);
string.endsWith(value);</code></pre>
<p>Zurückgegeben wird jeweils ein Boolean, also <code>true</code> oder <code>false.</code> Möchte ich wissen ob mein String <code>Beispiel</code>ein <code>eis</code> enthält, prüfe ich ganz einfach auf</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-string">'Beispiel'</span>.includes(<span class="hljs-string">'eis'</span>);</code></pre>
<p>Analog verhält es sich mit <code>startsWith</code>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-string">'Beispiel'</span>.startsWith(<span class="hljs-string">'Bei'</span>);</code></pre>
<p>… wie auch mit <code>endsWith</code>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-string">'Beispiel'</span>.endsWith(<span class="hljs-string">'spiel'</span>);</code></pre>
<p>Die Methode arbeitet dabei case-sensitive, also unterscheidet zwischen Groß- und Kleinschreibung.</p>
<p>Zwei weitere hilfreiche Methoden die mit ES2015 Einzug in JavaScript erhalten haben sind <code>String.prototype.padStart()</code> und <code>String.prototype.padEnd()</code>. Diese Methoden könnt ihr nutzen um einen String auf eine gewisse Länge zu bringen indem ihr am Anfang (<code>.padStart()</code>) oder am Ende (<code>.padEnd()</code>) Zeichen hinzufügt bis die angegebene Länge erreicht ist. Dabei gibt der erste Parameter die gewünschte Länge an, der optionale zweite Parameter das Zeichen mit dem ihr den String bis zu dieser Stelle auffüllen wollt. Gebt ihr keinen zweiten Parameter an, wird standardmäßig ein Leerzeichen benutzt.</p>
<p>Hilfreich ist das bspw. wenn ihr Zahlen auffüllen wollt, so dass diese immer einheitlich dreistellig sind:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-string">'7'</span>.padStart(<span class="hljs-number">3</span>, <span class="hljs-string">'0'</span>); <span class="hljs-comment">// 007</span>
<span class="hljs-string">'72'</span>.padStart(<span class="hljs-number">3</span>, <span class="hljs-string">'0'</span>); <span class="hljs-comment">// 072</span>
<span class="hljs-string">'132'</span>.padStart(<span class="hljs-number">3</span>, <span class="hljs-string">'0'</span>); <span class="hljs-comment">// 132</span></code></pre>
<p><code>String.prototype.padEnd()</code> funktioniert nach dem gleichen Muster, mit dem Unterschied, dass es euren String am Ende auffüllt, nicht am Anfang.</p>
<h3 id="arrays">Arrays</h3>
<p>Bei den Array-Methoden gibt es sowohl neue statische Methoden als auch Methoden auf dem Array-Prototype. Was bedeutet dies? Prototype-Methoden arbeiten „mit dem Array“ als solches, also mit einer bestehenden <strong>Array-Instanz</strong>, statische Methoden sind im weiteren Sinne Helper-Methoden, die gewisse Dinge tun, die „mit Arrays zu tun haben“.</p>
<h4 id="statische-array-methoden">Statische Array-Methoden</h4>
<p>Fangen wir mit den statischen Methoden an:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-built_in">Array</span>.of(<span class="hljs-number">3</span>); <span class="hljs-comment">// [3]</span>
<span class="hljs-built_in">Array</span>.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [1, 2 ,3]</span>
<span class="hljs-built_in">Array</span>.from(<span class="hljs-string">'Example'</span>); <span class="hljs-comment">// ['E', 'x', 'a', 'm', 'p', 'l', 'e']</span></code></pre>
<p><code>Array.of()</code> erstellt eine neue Array-Instanz aus einer beliebigen Anzahl an Parametern, unabhängig von deren Typen. <code>Array.from()</code> erstellt ebenfalls eine Array-Instanz, allerdings aus einem „Array-ähnlichen“ iterierbaren Objekt. Das wohl griffigste Beispiel für ein solches Objekt ist eine <code>HTMLCollection</code> oder eine <code>NodeList</code>. Solche erhält man bspw. bei der Verwendung von DOM-Methoden wie <code>getElementsByClassName()</code> oder dem moderneren <code>querySelectorAll()</code>. Diese besitzen selbst keine Methoden wie <code>.map()</code> oder <code>.filter()</code>. Möchte man über eine solche also iterieren, muss man sie erst einmal in einen Array konvertieren. Dies geht mit ES2015 nun ganz einfach durch die Verwendung von <code>Array.from()</code>.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> links = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'a'</span>));
<span class="hljs-built_in">Array</span>.isArray(links); <span class="hljs-comment">// true</span></code></pre>
<h4 id="methoden-auf-dem-array-prototypen">Methoden auf dem Array-Prototypen</h4>
<p>Die Methoden auf dem Array-Prototypen können <strong>direkt auf eine Array-Instanz</strong> angewendet werden. Die gängigsten während der Arbeit mit React und insbesondere später mit Redux sind:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-built_in">Array</span>.find(<span class="hljs-function"><span class="hljs-keyword">function</span>);
<span class="hljs-title">Array</span>.<span class="hljs-title">findIndex</span>(<span class="hljs-params">function</span>);
<span class="hljs-title">Array</span>.<span class="hljs-title">includes</span>(<span class="hljs-params">value</span>);</span></code></pre>
<p>Die <code>Array.find()</code>-Methode dient, wie der Name es erahnen lässt dazu, das <strong>erste</strong> element eines Arrays zu finden, das bestimmte Kriterien erfüllt, die mittels der als ersten Parameter übergebenen Funktion geprüft werden.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">13</span>, <span class="hljs-number">24</span>, <span class="hljs-number">27</span>, <span class="hljs-number">39</span>, <span class="hljs-number">50</span>];
<span class="hljs-keyword">const</span> biggerThan10 = numbers.find(<span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number &gt; <span class="hljs-number">10</span>); <span class="hljs-comment">// 13</span>

<span class="hljs-keyword">const</span> users = [
  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Bianca'</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Steve'</span> },
];
<span class="hljs-keyword">const</span> userWithId2 = users.find(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> user.id === <span class="hljs-number">2</span>); <span class="hljs-comment">// { id: 2, name: 'Bianca'}</span></code></pre>
<p>Die <code>Array.findIndex()</code>-Methode folgt der gleichen Signatur, liefert aber anders als die <code>Array.find()</code>-Methode nicht das gefundene Element selbst zurück, sondern nur dessen Index im Array. In den obigen Beispielen wären dies also <code>3</code> sowie <code>1</code>.</p>
<p>Die in ES2016 neu dazu gekommene Methode <code>Array.includes()</code> prüft ob ein Wert innerhalb eines Array existiert und gibt uns <strong>endlich</strong> einen Boolean zurück. Wer selbiges in der Vergangenheit mal mit <code>Array.indexOf()</code> realisiert hat wird sich erinnern wie umständlich es war. Nun also ein simples <code>Array.includes()</code>:</p>
<pre><code class="hljs javascript language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].includes(<span class="hljs-number">4</span>); <span class="hljs-comment">// true</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].includes(<span class="hljs-number">6</span>); <span class="hljs-comment">// false</span></code></pre>
<p>Aufgepasst: die Methode ist case-sensitive. <code>['a', 'b'].includes('A')</code> gibt also <code>false</code> zurück.</p>
<h3 id="objekte">Objekte</h3>
<h4 id="statische-objekt-methoden">Statische Objekt-Methoden</h4>
<p>Natürlich haben auch Objekte eine Reihe neuer Methoden und anderer schöner Möglichkeiten spendiert bekommen. Die wichtigsten im Überblick:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-built_in">Object</span>.assign(target, source[, source[,...]]);
<span class="hljs-built_in">Object</span>.entries(<span class="hljs-built_in">Object</span>)
<span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">Object</span>)
<span class="hljs-built_in">Object</span>.values(<span class="hljs-built_in">Object</span>)
<span class="hljs-built_in">Object</span>.freeze(<span class="hljs-built_in">Object</span>)</code></pre>
<p>Wieder der Reihe nach. Die wohl nützlichste ist aus meiner Sicht <code>Object.assign()</code>. Damit ist es möglich die Eigenschaften eines Objekts oder auch mehrerer Objekte zu einem bestehenden Objekt hinzuzufügen (sozusagen ein Merge). Die Methode gibt dabei das Ergebnis als Objekt zurück. Allerdings findet dabei auch eine Mutation des <strong>Ziel-Objekts</strong> statt, weswegen die Methode mit Bedacht benutzt werden sollte. Beispiele sagen mehr also Worte, bitteschön:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> user = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span> };
<span class="hljs-keyword">const</span> modifiedUser = <span class="hljs-built_in">Object</span>.assign(user, { <span class="hljs-attr">role</span>: <span class="hljs-string">'Admin'</span> });
<span class="hljs-built_in">console</span>.log(user);
<span class="hljs-comment">// -&gt; { id: 1, name: 'Manuel', role: 'Admin' }</span>
<span class="hljs-built_in">console</span>.log(modifiedUser);
<span class="hljs-comment">// -&gt; { id: 1, name: 'Manuel', role: 'Admin' }</span>
<span class="hljs-built_in">console</span>.log(user === modifiedUser);
<span class="hljs-comment">// -&gt; true</span></code></pre>
<p>Hier fügen wir also die Eigenschaft <code>role</code> aus dem Objekt im zweiten Parameter der <code>Object.assign()</code>-Methode zum bestehenden <strong>Ziel-Objekt</strong> hinzu.</p>
<p>Da React dem Prinzip von <strong>Pure Functions</strong> folgt, das sind Funktionen die in sich geschlossen sind und ihre Eingabeparameter nicht modifizieren, sollten deartige Mutationen möglichst vermieden werden. Dies können wir umgehen indem wir als ersten Parameter einfach ein Object-Literal übergeben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> user = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span> };
<span class="hljs-keyword">const</span> modifiedUser = <span class="hljs-built_in">Object</span>.assign({}, user, { <span class="hljs-attr">role</span>: <span class="hljs-string">'Admin'</span> });
<span class="hljs-built_in">console</span>.log(user);
<span class="hljs-comment">// -&gt; { id: 1, name: 'Manuel' }</span>
<span class="hljs-built_in">console</span>.log(modifiedUser);
<span class="hljs-comment">// -&gt; { id: 1, name: 'Manuel', role: 'Admin' }</span>
<span class="hljs-built_in">console</span>.log(user === modifiedUser);
<span class="hljs-comment">// -&gt; false</span></code></pre>
<p>Durch die Verwendung eines neu erstellten Objekts als Ziel-Objekt bekommen wir hier eben auch als Rückgabewert ein anderes Objekt als im ersten Beispiel. In einigen Fällen kann es gewünscht sein das <strong>Ziel-Objekt</strong> zu mutieren statt ein neues Objekt zu erstellen, während der Arbeit mit React ist dies jedoch in den deutlich überwiegenden Fällen nicht so.</p>
<p>Die Methode verarbeitet dabei auch beliebig viele Objekte als Parameter. Gibt es gleichnamige Eigenschaften in einem Objekt, haben spätere Eigenschaften Vorrang:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> user = { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span> };
<span class="hljs-keyword">const</span> modifiedUser = <span class="hljs-built_in">Object</span>.assign(
  {},
  user,
  { <span class="hljs-attr">role</span>: <span class="hljs-string">'Admin'</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Nicht Manuel'</span>, <span class="hljs-attr">job</span>: <span class="hljs-string">'Developer'</span> }
);
<span class="hljs-built_in">console</span>.log(modifiedUser);
<span class="hljs-comment">// -&gt; { id: 1, name: 'Nicht Manuel', role: 'Admin', job: 'Developer' }</span></code></pre>
<p>Die drei statischen Objekt-Methoden <code>Object.entries()</code>, <code>Object.keys()</code> und <code>Object.values()</code> funktionieren im Grunde sehr ähnlich, sie liefern zu einem übergebenen Objekt die Eigenschaften (<code>keys</code>), die Werte (<code>values</code>) oder die Einträge (<code>entries</code>) ala <strong>Array</strong> zurück, wobei die <strong>Entries</strong> ein verschachteltes Array sind in der Form <code>[[key, value], [key2, values2], …]</code>.</p>
<p>Angewendet auf unser obiges Beispiel hat dies also folgende Return-Values zum Ergebnis:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-built_in">Object</span>.keys({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span> });
<span class="hljs-comment">// -&gt; ['id', 'name']</span>
<span class="hljs-built_in">Object</span>.values({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span> });
<span class="hljs-comment">// -&gt; [1, 'Manuel']</span>
<span class="hljs-built_in">Object</span>.entries({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span> });
<span class="hljs-comment">// -&gt; [['id', 1], ['name', 'Manuel']]</span></code></pre>
<p>Zuletzt schauen wir uns <code>Object.freeze()</code> an. Auch diese Methode ist ziemlich selbsterklärend und tut genau was der Name vermuten lässt: sie friert ein Objekt ein, untersagt es dem Entwickler also neue Eigenschaften hinzuzfügen oder alte Eigenschaften zu löschen oder auch nur zu verändern. Auch dies ist im Umgang mit den Objekten, die in React in den meisten Fällen unveränderlich sind (oder zumindest sein sollten) unglaublich praktisch.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> user = <span class="hljs-built_in">Object</span>.freeze({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span> });
user.id = <span class="hljs-number">2</span>;
<span class="hljs-keyword">delete</span> user.name;
user.role = <span class="hljs-string">'Admin'</span>;
<span class="hljs-built_in">console</span>.log(user);
<span class="hljs-comment">// -&gt; { id: 1, name: 'Manuel' }</span></code></pre>
<p>Ein mittels <code>Object.freeze()</code> erstelltes Objekt bietet auch guten Schutz vor versehentlicher Mutation mittels der oben beschriebenen, ebenfalls neuen <code>Object.assign()</code>-Methode. Wird versucht ein mittels <code>Object.freeze()</code> erstelltes Objekt per <code>Object.assign()</code> zu modifizieren, führt dies unweigerlich zu seinem <code>TypeError</code>.</p>
<h4 id="syntax-erweiterungen-und-vereinfachungen">Syntax-Erweiterungen und Vereinfachungen</h4>
<p>Die letzte Änderungen an der funktionsweise von Objekten sind keine Methode sondern Syntax-Erweiterungen.</p>
<p>Die erste sind die <strong>Computed Properties</strong> (also etwa <em>berechnete Eigenschaften</em>). Dahinter verbirbt sich die Möglichkeit Ausdrücke (bzw. deren Werte) als Objekt-Eigenschaften zu verwenden. Wollte man bspw. früher eine Eigenschaft in einem Objekt setzen, lief das meist so, dass man das Objekt erstellte (bspw. als <strong>Object-Literal</strong> <code>{}</code> oder per <code>Object.create()</code>), dieses einer Variablen zuwies und anschließend die neue Eigenschaft zum Objekt hinzufügte:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> nationality = <span class="hljs-string">'german'</span>;
<span class="hljs-keyword">const</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span>,
};
user[nationality] = <span class="hljs-literal">true</span>;
<span class="hljs-built_in">console</span>.log(user);
<span class="hljs-comment">// -&gt; { name: 'Manuel', german: true };</span></code></pre>
<p><strong>ES2015</strong> erlaubt uns nun, Ausdrücke direkt als Objekt-Eigenschaft zu nutzen, indem wir sie in eckige Klammern <code>[]</code> setzen. Dadurch sparen wir uns den Umweg nachträglich noch Eigenschaften zum Bereits erstellten Objekt hinzuzufügen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> nationality = <span class="hljs-string">'german'</span>;
<span class="hljs-keyword">const</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel'</span>,
};
<span class="hljs-built_in">console</span>.log(user);
<span class="hljs-comment">// -&gt; { name: 'Manuel', german: true };</span></code></pre>
<p>Das Beispiel ist aus Gründen der einfacheren Verständlichkeit ein simples, doch die Verwendungsmöglichkeiten werden später mitunter noch deutlich komplexer und schaffen uns viele Möglichkeiten um sauberen und gut verständlichen Code zu schreiben, insbesondere wenn es um <strong>JSX</strong> geht.</p>
<p>Die letzte nennenswerte Neuerung bei Objekten sind die sogenannten <strong>Shorthand Property Names</strong>. Diese ersparen uns eine Menge unnötige Schreibarbeit. Nicht erst seit React kennt man es, dass man auf Code wie den folgenden stößt:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">'Manuel'</span>;
<span class="hljs-keyword">const</span> job = <span class="hljs-string">'Developer'</span>;
<span class="hljs-keyword">const</span> role = <span class="hljs-string">'Author'</span>;

<span class="hljs-keyword">const</span> user = {
  <span class="hljs-attr">name</span>: name,
  <span class="hljs-attr">job</span>: job,
  <span class="hljs-attr">role</span>: role,
};</code></pre>
<p>Ziemlich viele unnötige Dopplungen wenn man sich das mal genau anschaut, oder? Genau diese nimmt uns die <strong>Shorthand Property Name Syntax</strong> in <strong>ES2015</strong> endlich ab. Und so reicht es nur noch die Variable zu schreiben wenn diese den Namen der entsprechenden Objekt-Eigenschaft trägt. Im obigen Fall also:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">'Manuel'</span>;
<span class="hljs-keyword">const</span> job = <span class="hljs-string">'Developer'</span>;
<span class="hljs-keyword">const</span> role = <span class="hljs-string">'Author'</span>;

<span class="hljs-keyword">const</span> user = {
  name,
  job,
  role,
};</code></pre>
<p>Jep. Seit <strong>ES2015</strong> führen beide Schreibweisen tatsächlich zum identischen Objekt! Dabei kann die Shorthand Syntax auch problemlos mit der herkömmlichen Syntax kombiniert werden:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">'Manuel'</span>;
<span class="hljs-keyword">const</span> job = <span class="hljs-string">'Developer'</span>;

<span class="hljs-keyword">const</span> user = {
  name,
  job,
  <span class="hljs-attr">role</span>: <span class="hljs-string">'Author'</span>,
};</code></pre>
<h2 id="classes">Classes</h2>
<p>Mit <strong>ES2015</strong> fanden auch <strong>Klassen</strong> Einzug in JavaScript. <strong>Klassen</strong> kennt man eher aus objektorientierten Sprachen wie Java, in JavaScript gab es sie so explizit bisher allerdings noch nicht. Zwar war es auch schon vorher möglich durch die Verwendung von Funktionsinstanzen objektorientiert zu arbeiten und durch die <code>prototype</code>-Eigenschaft einer Funktion eigene Methoden und Eigenschaften zu definieren, dies war verglichen mit echten objektorientierten Sprachen jedoch sehr mühsam und schreiblastig.</p>
<p>Dies ändert sich mit <strong>ES2015</strong>, wo es nun erstmals auch Klassen gibt, die mittels <code>class</code> Keyword definiert werden. Das ist für uns insofern interessant, da React, obwohl es viele Prinzipien der funktionalen Programmierung (<strong>Functional Programming</strong>) verfolgt, gleichzeitig auch in einem wesentlichen Punkt auf ES2015 Klassen setzt, nämlich bei der Erstellung von Komponenten, in diesem Fall speziell von <strong>Class Components</strong>. Auch vor der Einführung von ES2015 Klassen war es natürlich möglich Komponenten in React zu definieren, dazu gab es eine eigene <code>createClass()</code>-Methode. Diese ist aber mittlerweile nicht mehr Teil des React Cores und sollte möglichst auch nicht mehr verwendet werden.</p>
<p>Eine Klasse besteht aus einem Namen, kann (optional) einen <strong>Constructor</strong> haben der bei der Erstellung einer Klassen-Instanz aufgerufen wird und beliebig viele Klassen-Methoden besitzen.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>{
  <span class="hljs-keyword">constructor</span>(firstName, lastName) {
    <span class="hljs-keyword">this</span>.firstName = firstName;
    <span class="hljs-keyword">this</span>.lastName = lastName;
  }

  getFullName() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.lastName;
  }
}

<span class="hljs-keyword">const</span> firstCustomer = <span class="hljs-keyword">new</span> Customer(<span class="hljs-string">'Max'</span>, <span class="hljs-string">'Mustermann'</span>);
<span class="hljs-built_in">console</span>.log(firstCustomer.getFullName());</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p>Max Mustermann</p>
</div>
<p>Auch das Erweitern bestehender Klassen mittels <code>extends</code> ist dabei möglich:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>{}</code></pre>
<p>Oder eben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{}</code></pre>
<p>Auch eine <code>super()</code>-Funktion kennt die neu eingeführte <strong>ES2015</strong>-Klasse, um damit den <strong>Constructor</strong> ihrer Elternklasse aufzurufen. Im Falle von React ist dies immer notwendig wenn ich in meiner eigenen Klasse eine <code>constructor</code>-Methode definiere. Diese muss dann dann <code>super()</code> aufrufen und ihre <code>props</code> an den Constructor der <code>React.Component</code> Klasse weiterzugeben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props);
  }
}</code></pre>
<p>Tätet ihr das nicht, wäre <code>this.props</code> innerhalb eurer Komponente <code>undefined</code> und ihr könntet nicht auf die Props eurer Komponente zugreifen. Grundsätzlich sollte die Verwendung eines Constructors aber in den allermeisten Fällen nicht nötig sein, denn React stellt eigene sog. <strong>Lifecycle-Methoden</strong> bereit, die der Verwendung des Constructors vorzuziehen sind.</p>
<h2 id="rest-und-spread-operators-und-destrukturierung">Rest und Spread Operators und Destrukturierung</h2>
<p>Eine weitere deutliche Vereinfachung ist die Einführung der der sog. Rest und Spread Operators für Objekte und Arrays. Streng genommen handelt es sich dabei bei der Verwendung in Kombination mit Objekten noch gar nicht um ES2015 Features, da diese sich noch in der Diskussion befinden und noch gar nicht endgültig in die ECMAScript Spezifikation aufgenommen wurden. Dies ändert sich erst mit ES2018. Eingeführt wurden Rest und Spread in ES2015 erstmals für Arrays. Durch die Verwendung von Babel ist die Nutzung auch mit Objekten aber heute bereits möglich und für gewöhnlich wird davon in React basierten Projekten auch rege Gebrauch gemacht.</p>
<p>Aber was ist das jetzt überhaupt? Fangen wir mit dem Spread Operator an.</p>
<h3 id="spread-operator">Spread Operator</h3>
<p>Der Spread Operator sorgt dafür Werte sozusagen „auszupacken“. Wollte man in ES5 mehrere Argumente aus einem Array an eine Funktion übergeben, geschah das bisher meist über <code>Function.prototype.apply()</code>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumAll</span>(<span class="hljs-params">number1, number2, number3</span>) </span>{
  <span class="hljs-keyword">return</span> number1, number2, number3;
}
<span class="hljs-keyword">var</span> myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
sumAll.apply(<span class="hljs-literal">null</span>, myArray);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p>6</p>
</div>
<p>Mit dem Spread Operator, der aus drei Punkten (…) besteht, kann ich diese Argumente nun auspacken oder eben „spreaden“:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumAll</span>(<span class="hljs-params">number1, number2, number3</span>) </span>{
  <span class="hljs-keyword">return</span> number1, number2, number3;
}
<span class="hljs-keyword">var</span> myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
sumAll(...myArray);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p>6</p>
</div>
<p>Ich muss also nicht mehr den Umweg über <code>apply()</code> gehen. Aber nicht nur bei Funktionsargumenten ist das hilfreich. Ich kann ihn auch nutzen um bspw. auf einfache Art und Weise zwei Arrays zu einem einzigen zu kombinieren:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> greenFruits = [<span class="hljs-string">'kiwi'</span>, <span class="hljs-string">'apple'</span>, <span class="hljs-string">'pear'</span>];
<span class="hljs-keyword">const</span> redFruits = [<span class="hljs-string">'strawberry'</span>, <span class="hljs-string">'cherry'</span>, <span class="hljs-string">'raspberry'</span>];
<span class="hljs-keyword">const</span> allFruits = [...greenFruits, ...redFruits];</code></pre>
<p><strong>Ergebnis:</strong></p>
<div class="hint hint--info">
<p><code>['kiwi', 'apple', 'pear', 'strawberry', 'cherry', 'raspberry']</code></p>
</div>
<p>Dabei wird ein neues Array erstellt, welches alle Werte sowohl aus dem <code>greenFruits</code> als auch aus dem <code>redFruits</code> Array enthält. Doch nicht nur das: dabei wird auch ein gänzlich neues Array erstellt und nicht bloß eine Referenz der beiden alten. Dies wird im weiteren Verlauf wenn wir an die <strong>readonly</strong>-Anforderung unserer Props noch sehr nützlich sein. Und so kann man den Spread Operator auch verwenden um eine einfache Kopie eines Arrays zu erstellen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> users = [<span class="hljs-string">'Manuel'</span>, <span class="hljs-string">'Chris'</span>, <span class="hljs-string">'Ben'</span>];
<span class="hljs-keyword">const</span> selectedUsers = [...users];</code></pre>
<p><code>selectedUsers</code> ist in diesem Fall eine Kopie unseres <code>users</code> Arrays mit all seinen Werten. Verändern wir nun das Users Array, hat dies auf unser <code>selectedUsers</code> Array keinerlei Auswirkungen.</p>
<p>Bei Objekten verhält sich der Spread Operator sehr ähnlich. Hier werden statt der einzelnen Werte alle Eigenschaften eines Objekts die „enumerable“ (aufzählbar) sind, also ganz grob gesagt bei der Verwendung in einer <code>for(… in …)</code> Schleife angezeigt werden würden.</p>
<p>Hier eignet sich der Spread Operator hervorragend um neue Objekte zu erstellen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> globalSettings = { <span class="hljs-attr">language</span>: <span class="hljs-string">'en-US'</span>, <span class="hljs-attr">timezone</span>: <span class="hljs-string">'Berlin/Germany'</span> };
<span class="hljs-keyword">const</span> userSettings = { <span class="hljs-attr">mutedUsers</span>: [<span class="hljs-string">'Manuel'</span>] };
<span class="hljs-keyword">const</span> allSettings = { ...globalSettings, ...userSettings };
<span class="hljs-built_in">console</span>.log(allSettings);</code></pre>
<p><strong>Ausgabe:</strong></p>
<pre><code class="hljs javascript language-javascript">{
  <span class="hljs-attr">language</span>: <span class="hljs-string">'en-US'</span>,
  <span class="hljs-attr">timezone</span>: <span class="hljs-string">'Berlin/Germany'</span>,
  <span class="hljs-attr">mutedUsers</span>: [<span class="hljs-string">'Manuel'</span>],
}</code></pre>
<p>Die Eigenschaften beider Objekte finden sich dabei im neu erstellten, kombinierten <code>allSettings</code> Objekt wieder. Dabei ist der <strong>Spread Operator</strong> hier nicht auf zwei Objekte beschränkt sondern kann beliebige weitere Objekte zu einem einzelnen neuen Objekt kombinieren. Auch die Kombination mit einzelnen Eigenschaften ist möglich:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> settings = {
  ...userSettings,
  <span class="hljs-attr">showWarnings</span>: <span class="hljs-literal">true</span>,
};</code></pre>
<p>Befinden sich in beiden Objekten Eigenschaften mit dem gleichen Namen, hat das letztgenannte Objekt Vorrang:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> globalSettings = { <span class="hljs-attr">language</span>: <span class="hljs-string">'en-US'</span>, <span class="hljs-attr">timezone</span>: <span class="hljs-string">'Berlin/Germany'</span> };
<span class="hljs-keyword">const</span> userSettings = { <span class="hljs-attr">language</span>: <span class="hljs-string">'de-DE'</span> };
<span class="hljs-keyword">const</span> allSettings = { ...globalSettings, ...userSettings };
<span class="hljs-built_in">console</span>.log(allSettings);</code></pre>
<p><strong>Ausgabe:</strong></p>
<pre><code class="hljs text language-text">{
  <span class="hljs-attribute">language</span>: <span class="hljs-string">'de-DE'</span>,
  timezone: <span class="hljs-string">'Berlin/Germany'</span>,
}</code></pre>
<p>Das zuletzt genannte <code>userSettings</code> Objekt überschreibt hier die gleichnamige Eigenschaft <code>language</code>, die sich auch im <code>globalSettings</code> Objekt befindet. Der Spread Operator funktioniert hier ganz ähnlich wie die in ES2015 neu eingeführte Objekt-Methode <code>Object.assign()</code>. Auch diese wird in ES2015+ basierten Anwendungen gelegentlich genutzt.</p>
<p>Allerdings gibt es hier den nennenswerten Unterschied, dass sie ein bestehendes Objekt mutiert und nicht per se ein neues Objekt generiert, wie das die Object Spread Variante tut. Und Mutation ist bezogen auf React-Komponenten und ihre Props eben das, was wir ja nicht wollen. Dennoch der Vollständigkeit halber ein kurzes Beispiel.</p>
<h4 id="objekte-kombinieren-mittels-objectassign">Objekte kombinieren mittels Object.assign()</h4>
<p><code>Object.assign()</code> nimmt beliebig viele Objekte entgegen und kombiniert diese zu einem einzigen Objekt:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> a = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };
<span class="hljs-keyword">const</span> b = { <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">const</span> c = { <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> };
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.assign(a, b, c));</code></pre>
<p><strong>Ausgabe:</strong></p>
<pre><code class="hljs javascript language-javascript">{<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>}</code></pre>
<p>Die Funktion gibt uns also ein neues Objekt zurück, in dem alle 3 übergebenen Objekte zu einem einzigen kombiniert wurden. Aber ist das wirklich ein neues Objekt? <strong>Nein!</strong> Lassen wir uns doch anschließend mal <code>a</code>, <code>b</code> und <code>c</code> in der Console ausgeben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-built_in">console</span>.log(a);
<span class="hljs-built_in">console</span>.log(b);
<span class="hljs-built_in">console</span>.log(c);</code></pre>
<p><strong>Ausgabe:</strong></p>
<pre><code class="hljs javascript language-javascript">{<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>}
{<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>}
{<span class="hljs-attr">c</span>: <span class="hljs-number">3</span>}</code></pre>
<p>Wir stellen also fest: <code>Object.assign()</code> hat uns nicht wirklich ein komplett neues Objekt aus den 3 übergebenen Objekten erstellt sondern lediglich die Eigenschaften des zweiten und dritten Objekts zum ersten übergebenen Objekt hinzugefügt. Und das ist, im Bezug auf <strong>Pure Functions</strong> und <strong>Immutable Objects</strong>, äußerst schlecht und in jedem Fall zu vermeiden!</p>
<p>Hier gibt es aber einen einfachen Trick um Objekte mittels <code>Object.assign()</code> zu kombinieren und dabei gleichzeitig ein neues Objekt zu erstellen. Dazu übergebt ihr der Funktion als erstes Argument ein leeres Object-Literal <code>{}</code>:</p>
<pre><code class="hljs text language-text"><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.assign</span>({}, <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, <span class="hljs-selector-tag">c</span>);</code></pre>
<p>… und schon werden dem neu erstellten <code>{}</code> Objekt die Eigenschaften unserer Objekte <code>a</code>, <code>b</code> und <code>c</code> übertragen, die bestehenden Objekte <code>a</code>, <code>b</code> und <code>c</code> bleiben dabei unangetastet!</p>
<h3 id="destructuring-assignment--destrukturierende-zuweisung">Destructuring Assignment / destrukturierende Zuweisung</h3>
<p>Bevor ich zum <strong>Rest Operator</strong> komme, der logisch sehr eng mit dem <strong>Spread Operator</strong> in Verbindung steht und meist mit diesem in einem Atemzug genannt wird, möchte ich auf das <strong>Destructuring Assignment</strong> (kurz: <strong>Destructuring</strong>) oder eben die <strong>destrukturierende Zuweisung</strong> (kurz: <strong>Destrukturierung</strong>), wie der schöne Begriff auf Deutsch heißt, eingehen. Ich werde hier wie so oft beim englischen Begriff bleiben, da ich den deutschen Begriff selbst in deutschsprachigen Texten selten bisher gelesen habe.</p>
<p>Mittels <strong>Destructuring</strong> ist es möglich einzelne Elemente aus Objekten oder Arrays zu extrahieren und Variablen zuzuweisen. Eine weitere <strong>deutliche</strong> Syntax-Erweiterung die uns ES2015 hier beschert hat.</p>
<h4 id="destructuring-von-arrays">Destructuring von Arrays</h4>
<p>Stellen wir uns vor wir möchten aus einem geordneten Array mit den Olympia-Teilnehmern im 100m Lauf jeweils den Gewinner der Gold-, Silber- und Bronzemedaille in eine eigene Variable schreiben. Auf herkömmlichen (also ES5) Weg funktionierte das bisher folgendermaßen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> athletes = [
  <span class="hljs-string">'Usain Bolt'</span>,
  <span class="hljs-string">'Andre De Grasse '</span>,
  <span class="hljs-string">'Christophe Lemaitre '</span>,
  <span class="hljs-string">'Adam Gemili'</span>,
  <span class="hljs-string">'Churandy Martina'</span>,
  <span class="hljs-string">'LaShawn Merritt'</span>,
  <span class="hljs-string">'Alonso Edward'</span>,
  <span class="hljs-string">'Ramil Guliyev'</span>,
];

<span class="hljs-keyword">const</span> gold = athletes[<span class="hljs-number">0</span>];
<span class="hljs-keyword">const</span> silver = athletes[<span class="hljs-number">1</span>];
<span class="hljs-keyword">const</span> bronze = athletes[<span class="hljs-number">2</span>];</code></pre>
<p>Dank <strong>Destructuring</strong> können wir dies auf ein einzelnes Statement verkürzen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> [gold, silver, bronze] = athletes;</code></pre>
<p>Die Werte der Array-Elemente <code>0</code>, <code>1</code> und <code>2</code> befinden sich dann der Reihe nach in den Variablen <code>gold</code>, <code>silver</code> und <code>bronze</code>, wie auch im ersten Beispiel, jedoch mit deutlich weniger Schreibarbeit!</p>
<p>Dies funktioniert überall wo wir mit einem Array auf der rechten Seite (also hinter dem <code>=</code> Zeichen) einer Zuweisung arbeiten, also auch wenn wir diesen als <code>return</code>-Wert aus einer Funktion erhalten:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> getAllAthletes = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> [
    <span class="hljs-string">'Usain Bolt'</span>,
    <span class="hljs-string">'Andre De Grasse '</span>,
    <span class="hljs-string">'Christophe Lemaitre '</span>,
    <span class="hljs-string">'Adam Gemili'</span>,
    <span class="hljs-string">'Churandy Martina'</span>,
    <span class="hljs-string">'LaShawn Merritt'</span>,
    <span class="hljs-string">'Alonso Edward'</span>,
    <span class="hljs-string">'Ramil Guliyev'</span>,
  ];
};

<span class="hljs-keyword">const</span> [gold, silver, bronze] = getAllAthletes();</code></pre>
<p>Die Arrow Function hier gibt uns ein Array mit allen Athleten zurück, dementsprechend können wir hier direkt beim Aufruf bereits das Destructuring nutzen und müssen den <code>return</code>-Wert bspw. nicht erst eigens in einer temporären Variable speichern.</p>
<p>Möchten wir auf diese Weise einzelne Elemente des Arrays auslassen, ist das buchstäblich durch Auslassen des entsprechenden Wertes möglich:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> [, silber, bronze] = athletes;</code></pre>
<p>Hier würden wir auf das Deklarieren einer <code>gold</code> Variable verzichten und nur die Gewinner der Silber- und Bronze-Medaille in entsprechenden Variablen speichern.</p>
<p>Doch nicht nur bei der offensichtlichen Variablenzuweisung mittels <code>let</code> oder <code>const</code> kann <strong>Array Destructuring</strong> verwendet werden. Auch bei weniger offensichtlichen Zuweisungen, wie bei der Übergabe von Funktionsargumenten in Form eines Arrays.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> logWinners = <span class="hljs-function">(<span class="hljs-params">athletes</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> gold = athletes[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">const</span> silver = athletes[<span class="hljs-number">1</span>];
  <span class="hljs-keyword">const</span> bronze = athletes[<span class="hljs-number">2</span>];
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Winners of Gold, Silver and Bronze are'</span>, gold, silver, bronze);
};</code></pre>
<p>Das geht einfacher:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> logWinners = <span class="hljs-function">(<span class="hljs-params">[gold, silver, bronze]</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Winners of Gold, Silver and Bronze are'</span>, gold, silver, bronze);
};</code></pre>
<p>Hier reichen wir das Array in unsere <code>logWinners()</code> Funktion herein und statt für jeden Medaillengewinner eine Variable pro Zeile zu deklarieren, nutzen wir auch in diesem Fall ganz einfach wieder die Destructuring Methode von oben.</p>
<h4 id="destructuring-von-objekten">Destructuring von Objekten</h4>
<p>Das Prinzip des <strong>Destructurings</strong> ist nicht allein auf Arrays beschränkt. Auch Objekte können auf diese Art Variablen zugeordnet werden, die standardmäßig mit dem Namen einer Eigenschaft übereinstimmen.</p>
<p>Die Schreibweise ist dabei ähnlich zu der bei Arrays, mit dem Unterschied das wir die Werte nicht anhand ihrer Position im Objekt zuweisen sondern anhand ihres Eigenschafts-Namens. Außerdem setzen wir die Zuweisung in die für Objekte typischen geschweiften Klammern, statt in eckige Klammern.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> user = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Manuel'</span>,
  <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Bieh'</span>,
  <span class="hljs-attr">job</span>: <span class="hljs-string">'JavaScript Developer'</span>,
  <span class="hljs-attr">image</span>: <span class="hljs-string">'manuel.jpg'</span>,
};
<span class="hljs-keyword">const</span> { firstName } = user;</code></pre>
<p>Die Variable <code>firstName</code> enthält nun den Wert aus <code>user.firstName</code>!</p>
<p>Das Object Destructuring ist eins der wohl meist verwendeten Features, das man in den meisten React-Komponenten findet. Es erlaubt uns einzelne Props in Variablen zu schreiben und an entsprechenden Stellen im JSX auf unkomplizierte Weise zu verwenden.</p>
<p>Nehmen wir an dieser Stelle einmal die folgende Stateless Functional Component als Beispiel:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> UserPersona = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;img src={props.image} alt="User Image" /&gt;
      {props.firstName} {props.lastName}&lt;br /&gt;
      &lt;strong&gt;{props.job}
    &lt;/div&gt;
  );
};</code></pre>
<p>Die ständige Wiederholung von <code>props</code> vor jeder Eigenschaft erschwert die Lesbarkeit der Komponente unnötig. Hier können wir uns Object Destructuring zu Nutze machen um einmalig eine Variable für jede Eigenschaft unserer <code>props</code> zu deklarieren.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> UserPersona = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { firstName, lastName, image, job } = props;
  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;img src={image} alt="User Image" /&gt;
      {firstName} {lastName}&lt;br /&gt;
      &lt;strong&gt;{job}
    &lt;/div&gt;
  );
};</code></pre>
<p>Damit wirkt unsere Komponente schon deutlich aufgeräumter uns lesbarer. Doch es geht noch einfacher. Wie auch bei Arrays ist es auch möglich Objekte direkt bei der Übergabe als Funktionsargument zu destrukturieren. Statt des <code>props</code> Arguments nutzen wir dafür das <strong>Destructuring Assignment</strong> direkt:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> UserPersona = <span class="hljs-function">(<span class="hljs-params">{ firstName, lastName, image, job }</span>) =&gt;</span> (
  &lt;div&gt;
    &lt;img src={image} alt="User Image" /&gt;
    {firstName} {lastName}&lt;br /&gt;
    &lt;strong&gt;{job}
  &lt;/div&gt;
);</code></pre>
<p>Als Bonus nutzen wir hier sogar die direkte Rückgabe aus der Funktion ohne geschweifte Klammern und explizites <code>return</code> Statement aus dem Kapitel über Arrow Functions, da wir ja nun mit unserem auf 5 Zeilen reduzierten <strong>JSX</strong> einen Ausdruck haben, den wir direkt aus der <strong>Arrow Function</strong> zurückgeben können.</p>
<p>Während der Arbeit mit React trifft man ständig auf derartige Syntax in <strong>SFCs</strong>, auch bei <strong>Class Components</strong> findet man sehr häufig zu Beginn der <code>render()</code>-Methode einer Komponente ein ähnliches Destructuring Assignment in der Form:</p>
<pre><code class="hljs javascript language-javascript">render() {
  <span class="hljs-keyword">const</span> { firstName, lastName, image, job } = <span class="hljs-keyword">this</span>.props;
  <span class="hljs-comment">// weiterer Code</span>
}</code></pre>
<p>Auch wenn das euch natürlich hinterher freigestellt ist ob ihr das so macht oder innerhalb der Funktion einfach weiterhin direkt auf <code>this.props.firstName</code> zugreift. Dieses Muster hat sich aber mittlerweile zu einer Art Best Practice entwickelt und wurde in den meisten Projekten so gehandhabt, da es den Code am Ende in den meisten Fällen lesbarer werden lässt und auch leichter verständlich ist.</p>
<p><strong>Umbenennung von Eigenschaften beim Destructuring</strong></p>
<p>Manchmal ist es notwendig Eigenschaften umzubenennen, entweder weil es bereits Variablen mit dem selben Namen gibt oder die Eigenschaften kein gültiger Variablenname wäre. All das ist denkbar und möglich. Und ES2015 bietet uns auch eine Lösung dafür.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> passenger = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Manuel Bieh'</span>,
  <span class="hljs-attr">class</span>: <span class="hljs-string">'economy'</span>,
};</code></pre>
<p>Das obige <code>passenger</code> Objekt enthält die Eigenschaft class, die als Name für eine Eigenschaft gültig ist, als Name für eine Variable jedoch nicht. Ein direktes Destructuring wäre hier also nicht möglich und würde zu einem Fehler führen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> { name, <span class="hljs-class"><span class="hljs-keyword">class</span> } </span>= passenger;</code></pre>
<div class="hint hint--danger">
<p>Uncaught SyntaxError: Unexpected token }</p>
</div>
<p>Um hier den Namen der Variable umzubenennen muss der Eigenschaft der neue Namen getrennt durch einen Doppelpunkt <code>:</code> übergeben werden. Ein korrektes <strong>Destructuring Assignment</strong> wäre also in diesem Fall in etwa folgendes:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> { name, <span class="hljs-attr">class</span>: ticketClass } = passenger;</code></pre>
<p>Hier schreiben wir den Wert der <code>class</code> Eigenschaft in eine Variable <code>ticketClass</code>, was anders als <code>class</code> ein gültiger Name für eine Variable ist. Der Name des Passagiers landet dabei ganz gewöhnlich in einer Variable mit dem Namen <code>name</code>.</p>
<p><strong>Standardwerte beim Destructuring vergeben</strong></p>
<p>Auch die Vergabe von Standardwerten beim <strong>Destructuring</strong> ist möglich! Ist im Objekt welches destrukturiert wird eine Eigenschaft nicht definiert, wird stattdessen der Default verwendet. Ähnlich wie bei der Umbenennung wird dabei die jeweilige Eigenschaft wie gehabt vorangestellt, jedoch gefolgt von einem Gleich-Zeichen und dem entsprechenden Standardwert:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> { name = <span class="hljs-string">'Unknown passenger'</span> } = passenger;</code></pre>
<p>Der Wert von <code>name</code> wäre nun <code>Unknown passenger</code> wenn im <code>passenger</code> Objekt keine Eigenschaft <code>name</code> existiert oder deren Wert <code>undefined</code> ist. Existiert diese hingegen, ist aber leer (also bspw. ein leerer String oder <code>null</code>) wird der Standardwert <strong>nicht</strong> an dessen Stelle verwendet!</p>
<p><strong>Kombination von Umbenennung und Standardwerten</strong></p>
<p>Jetzt wird es verrückt, denn auch das ist möglich. Die Umbenennung von Eigenschaften in Variablennamen bei gleichzeitiger Verwendung von Standardwerten. Die Syntax dafür ist allerdings etwas, wo man bei der ersten Begegnung sicherlich einen Moment länger hinschauen muss. Wir bleiben wieder bei unserem <code>passenger</code> Objekt aus den Beispielen zuvor. Anforderung ist nun die Zuweisung der <code>name</code> Eigenschaft zu einer Variable mit dem Namen <code>passengerName</code>, die den Wert <code>Unknown Passenger</code> tragen soll, wenn kein Name vorhanden ist. Außerdem möchten wir weiterhin <code>class</code> in <code>ticketClass</code> umbenennen und den Passagier gleichzeitig in <code>Economy</code> einordnen, sollte es im entsprechenden Objekt keine <code>class</code> Eigenschaft geben.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> {
  <span class="hljs-attr">name</span>: passengerName = <span class="hljs-string">'Unknown passenger'</span>,
  <span class="hljs-attr">class</span>: ticketClass = <span class="hljs-string">'economy'</span>,
} = passenger;</code></pre>
<p>Hier besitzen die Variablen <code>passengerName</code> und <code>ticketClass</code> die werte <code>Unknown passenger</code> und <code>economy</code> wenn diese nicht im destrukturierten Objekt existieren. Doch Vorsicht: das Objekt selbst darf nicht null sein, andernfalls bekommen wir vom JavaScript Interpreter einen unschönen Fehler geworfen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> {
  <span class="hljs-attr">name</span>: passengerName = <span class="hljs-string">'Unknown passenger'</span>,
  <span class="hljs-attr">class</span>: ticketClass = <span class="hljs-string">'economy'</span>,
} = <span class="hljs-literal">null</span>;</code></pre>
<div class="hint hint--danger">
<p>Uncaught TypeError: Cannot destructure property `name` of 'undefined' or 'null'.</p>
</div>
<p>Hier gibt es einen unsauberen aber doch oft praktischen Trick um sicherzustellen, dass das Objekt selbst nicht <code>null</code> oder <code>undefined</code> ist. Dazu machen wir uns den <strong>Logical OR Operator</strong> zu nutze und verwenden ein leeres Objekt als Fallback, falls unser eigentliches Objekt eben <code>null</code> oder <code>undefined</code> ist:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> {
  <span class="hljs-attr">name</span>: passengerName = <span class="hljs-string">'Unknown passenger'</span>,
  <span class="hljs-attr">class</span>: ticketClass = <span class="hljs-string">'economy'</span>,
} = passenger || {};</code></pre>
<p>Mit dem angehängten <code>|| {}</code> sagen wir: ist das <code>passenger</code> Objekt <strong>falsy</strong>, nutze stattdessen ein leeres Objekt. Die vermutlich „sauberere“ Variante wäre es vorab zu prüfen ob <code>passenger</code> auch wirklich ein Objekt ist und das Destructuring nur dann auszuführen. Die Variante mit dem <strong>Logical OR</strong> Fallback ist allerdings schön kurz und dürfte in vielen Fällen ausreichen.</p>
<p><strong>Destructuring</strong> kann übrigens auch problemlos mit dem <strong>Spread Operator</strong> zusammen verwendet werden:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> globalSettings = { <span class="hljs-attr">language</span>: <span class="hljs-string">'en-US'</span> };
<span class="hljs-keyword">const</span> userSettings = { <span class="hljs-attr">timezone</span>: <span class="hljs-string">'Berlin/Germany'</span> };
<span class="hljs-keyword">const</span> { language, timezone } = { ...globalSettings, ...userSettings };</code></pre>
<p>Hier wird zuerst der <strong>Spread Operator</strong> aufgelöst, also ein Objekt mit allen Eigenschaften aus den beiden Objekten <code>globalSettings</code> und <code>userSettings</code> erzeugt und anschließend per <strong>Destructuring Assignment</strong> entsprechenden Variablen zugewiesen.</p>
<h3 id="rest-operator">Rest Operator</h3>
<p>Der Rest Operator dient dazu, um sich um die verbliebenen Elemente aus einem <strong>Destructuring</strong> und in <strong>Funktionsargumenten</strong> zu kümmern. Daher der Name: der Operator kümmert sich um den verbliebenen <strong>„Rest“</strong>. Wie auch schon der <strong>Spread Operator</strong> wird auch der <strong>Rest Operator</strong> mit drei Punkten <code>…</code> eingeleitet, jedoch nicht auf der <strong>rechten</strong> Seite einer Zuweisung, sondern auf der <strong>linken</strong>. Anders als beim Spread Operator kann es pro Ausdruck jedoch nur jeweils <strong>einen</strong> Rest Operator geben!</p>
<p>Schauen wir uns zuerst einmal den <strong>Rest Operator</strong> bei Funktionsargumenten an. Sagen wir, wir möchten nun eine Funktion schreiben, die beliebig viele Argumente empfängt. Hier möchten wir natürlich auch auf all diese Argumente zugreifen können, egal ob das 2, 5 oder 25 sind. In ES5 Standardfunktionen gibt es das Keyword <code>arguments</code>mittels dessen auf ein Array aller übergebenen Funktionsargumente zugegriffen werden kann innerhalb der Funktion:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);
}
Example(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p><code>Arguments(5) [1, 2, 3, 4, 5, callee: ƒ]</code></p>
</div>
<p><strong>Arrow Functions</strong> bieten diese Möglichkeit nicht mehr und werfen stattdessen einen Fehler:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> Example = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);
};
Example(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--danger">
<p>Uncaught ReferenceError: arguments is not defined</p>
</div>
<p>Hier kommt nun erstmals der <strong>Rest Operator</strong> ins Spiel. Dieser schreibt uns sämtliche übergebene Funktionsargumente die wir nicht bereits in benannte Variablen geschrieben haben in eine weitere Variable mit einem beliebigen Namen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> Example = <span class="hljs-function">(<span class="hljs-params">...rest</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(rest);
};
Example(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p><code>[1, 2, 3, 4, 5]</code></p>
</div>
<p>Dies funktioniert nicht nur als einzelnes Funktionsargument sondern auch wenn wir vorher bereits benannte Parameter definiert haben. Hier kümmert sich der <strong>Rest Operator</strong> dann buchstäblich um den letzten verbliebenen <strong>Rest:</strong></p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> Example = <span class="hljs-function">(<span class="hljs-params">first, second, third, ...rest</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'first:'</span>, first);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'second:'</span>, second);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'third:'</span>, third);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'rest:'</span>, rest);
};
Example(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p><code>first: 1 second: 2 third: 3 rest: [4, 5]</code></p>
</div>
<p>Der <strong>Rest Operator</strong> sammelt hier also die restlichen, verbliebenen Elemente aus einem <strong>Destructuring</strong> ein und speichert diese in einer Variable mit dem Namen, der hinter den drei Punkten angegeben wird. Dieser muss dabei nicht wie im obigen Beispiel <code>rest</code> heißen sondern kann jeden gültigen JavaScript-Variablennamen annehmen.</p>
<p>Das funktioniert aber nicht nur bei Funktionen sondern ebenso bei <strong>Array Destructuring</strong>:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> athletes = [
  <span class="hljs-string">'Usain Bolt'</span>,
  <span class="hljs-string">'Andre De Grasse'</span>,
  <span class="hljs-string">'Christophe Lemaitre'</span>,
  <span class="hljs-string">'Adam Gemili'</span>,
  <span class="hljs-string">'Churandy Martina'</span>,
  <span class="hljs-string">'LaShawn Merritt'</span>,
  <span class="hljs-string">'Alonso Edward'</span>,
  <span class="hljs-string">'Ramil Guliyev'</span>,
];
<span class="hljs-keyword">const</span> [gold, silver, bronze, ...competitors] = athletes;
<span class="hljs-built_in">console</span>.log(gold);
<span class="hljs-built_in">console</span>.log(silver);
<span class="hljs-built_in">console</span>.log(bronze);
<span class="hljs-built_in">console</span>.log(competitors);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<pre><code class="hljs javascript language-javascript"><span class="hljs-string">'Usain Bolt'</span>
<span class="hljs-string">'Andre De Grasse'</span>
<span class="hljs-string">'Christophe Lemaitre'</span><span class="hljs-string">`
[
'Adam Gemili',
'Churandy Martina',
'LaShawn Merritt',
'Alonso Edward',
'Ramil Guliyev'
]
</span></code></pre>
</div>
<p>… wie auch beim <strong>Object Destructuring:</strong></p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> user = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Manuel'</span>,
  <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Bieh'</span>,
  <span class="hljs-attr">job</span>: <span class="hljs-string">'JavaScript Developer'</span>,
  <span class="hljs-attr">hair</span>: <span class="hljs-string">'Brown'</span>,
};
<span class="hljs-keyword">const</span> { firstName, lastName, ...other } = user;
<span class="hljs-built_in">console</span>.log(firstName);
<span class="hljs-built_in">console</span>.log(lastName);
<span class="hljs-built_in">console</span>.log(other);</code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--info">
<p><code>Manuel</code><br />
<code>Bieh</code><br />
<code>{ job: 'JavaScript Developer', hair: 'Brown' }</code></p>
</div>
<p>All die Werte, die dabei nicht explizit in eine Variable geschrieben wurden während eines <strong>Destructuring Assignments</strong> können dann in der als <strong>Rest</strong> deklarierten Variable abgerufen werden.</p>
<h2 id="template-strings">Template Strings</h2>
<p><strong>Template Strings</strong> in ES2015 sind eine „dritte Schreibweise“ für Strings in JavaScript. Bisher konnten Strings entweder in einfache Anführungszeichen (<code>'Beispiel'</code>) oder in doppelte Anführungszeichen (<code>"Beispiel"</code>) gesetzt werden. Nun kommt auch die Möglichkeit hinzu, diese in Backticks (<code>Beispiel</code>) zu setzen.</p>
<p><strong>Template Strings</strong> können in zwei Varianten auftreten. Als gewöhnliche <strong>Template Strings</strong>, die JavaScript Ausdrücke enthalten können, sowie in erweiterter Form als sog. <strong>Tagged Template Strings</strong>.</p>
<p><strong>Tagged Template Strings</strong> sind eine deutlich mächtigere Form von <strong>Template Strings</strong>. Mit ihnen kann die Ausgabe von <strong>Template Strings</strong> mittels einer speziellen Funktion modifiziert werden. Das ist bei der gewöhnlichen Arbeit mit React erst einmal weniger wichtig. Später im Kapitel über <strong>CSS in React</strong> werde ich ihre Funktionsweise nochmal etwas genauer am Beispiel von <strong>Styled Components</strong> erklären. <strong>Styled Components</strong> sind eine Möglichkeit um Komponenten in React designen und basieren ganz grundlegend auf <strong>Tagged Template Strings</strong>.</p>
<p>Wollte man sie mit JavaScript-Ausdrücken oder Werten mischen, griff man in ES5 meist zu einfacher <strong>String Concatenation:</strong></p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">var</span> age = <span class="hljs-number">7</span>;
<span class="hljs-keyword">var</span> text = <span class="hljs-string">'Meine Tochter ist '</span> + age + <span class="hljs-string">' Jahre alt'</span>;</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">var</span> firstName = <span class="hljs-string">'Manuel'</span>;
<span class="hljs-keyword">var</span> lastName = <span class="hljs-string">'Bieh'</span>;
<span class="hljs-keyword">var</span> fullName = firstName + <span class="hljs-string">' '</span> + lastName;</code></pre>
<p>Mit <strong>Template Strings</strong> wurde nun eine Variante von String eingeführt, die selbst wiederum <strong>JavaScript-Ausdrücke</strong> enthalten kann. Diese werden dazu innerhalb eines <strong>Template Strings</strong> in eine Zeichenkette in der Form <code>${ }</code> gesetzt. Um bei den obigen Beispielen zu bleiben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> age = <span class="hljs-number">7</span>;
<span class="hljs-keyword">const</span> text = <span class="hljs-string">`Meine Tochter ist <span class="hljs-subst">${age}</span> Jahre alt`</span>;</code></pre>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> firstName = <span class="hljs-string">'Manuel'</span>;
<span class="hljs-keyword">const</span> lastName = <span class="hljs-string">'Bieh'</span>;
<span class="hljs-keyword">const</span> fullName = <span class="hljs-string">`<span class="hljs-subst">${firstName}</span> <span class="hljs-subst">${lastName}</span>`</span>;</code></pre>
<p>Dabei können innerhalb der geschweiften Klammern sämtliche JavaScript Ausdrücke verwendet werden. Also auch Funktionsaufrufe:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Das heutige Datum ist <span class="hljs-subst">${<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString()}</span>`</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${firstName.toUpperCase()}</span> <span class="hljs-subst">${lastName.toUpperCase()}</span>`</span>);</code></pre>
<h2 id="promises-und-asyncawait">Promises und async/await</h2>
<p>Promises (dt. <em>Versprechen</em>) sind kein grundsätzlich neues Konzept in JavaScript, in ES2015 haben sie aber erstmals Einzug in den Standard erhalten und können nativ ohne eine andere Library (z.B. q, Bluebird, rsvp.js, …) verwendet werden. Ganz grob erlauben Promises es, die asynchrone Entwicklung durch Callbacks zu <em>linearisieren</em>. Ein Promise bekommt eine <strong>Executor-Funktion</strong> übergeben, die ihrerseits die zwei Argumente <code>resolve</code> und <code>reject</code> übergeben bekommen, und kann einen von insgesamt drei verschiedenen Zuständen annehmen: als Initialwert ist dieser Zustand <code>pending</code> und je nachdem ob eine Operation erfolgreich oder fehlerhaft war, die Executor-Funktion also das erste (<code>resolve</code>) oder das zweite (<code>reject</code>) Argument ausgeführt hat, wechselt dieser Zustand zu <code>fulfilled</code> oder <code>rejected</code>. Auf die beiden Endzustände kann dann mittels der Methoden <code>.then()</code> und <code>.catch()</code> reagiert werden. Wird <code>resolve</code> aufgerufen, wird der ´then()<code>-Teil ausgeführt, wird</code>reject<code>aufgerufen, werden **sämtliche**</code>then()<code>Aufrufe übersprungen und der</code>catch()` Teil wird stattdessen ausgeführt.</p>
<p>Eine Executor-Funktion <strong>muss</strong> dabei zwangsweise eine der beiden übergebenen Methoden ausführen, andernfalls bleibt das Promise dauerhaft <em>unfulfilled</em>, was zu fehlerhaften Verhalten und in bestimmten Fällen sogar zu Memory Leaks innerhalb einer Anwendung führen kann.</p>
<p>Um den Unterschied zwischen Promises und Callbacks einmal zu demonstrieren werfen wir einen Blick auf das folgende fiktive Beispiel:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> errorHandler = <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'An error occured:'</span>, err.message);
};

getUser(
  id,
  (user) =&gt; {
    user.getFriends(<span class="hljs-function">(<span class="hljs-params">friends</span>) =&gt;</span> {
      friends[<span class="hljs-number">0</span>].getSettings(<span class="hljs-function">(<span class="hljs-params">settings</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (settings.notifications === <span class="hljs-literal">true</span>) {
          email.send(
            <span class="hljs-string">'You are my first friend!'</span>,
            (status) =&gt; {
              <span class="hljs-keyword">if</span> (status === <span class="hljs-number">200</span>) {
                alert(<span class="hljs-string">'User has been notified via email!'</span>);
              }
            },
            errorHandler
          );
        }
      }, errorHandler);
    }, errorHandler);
  },
  errorHandler
);</code></pre>
<p>Wir rufen über die asynchrone <code>getUser()</code>-Funktion einen User zu einer entsprechenden <code>id</code> ab. Von diesem User besorgen wir uns mittels der asynchronen <code>getFriends()</code>-Methode eine Liste aller seiner Freunde. Vom ersten Freund (<code>friends[0]</code>) rufen wir mittels der asynchronen <code>getSettings()</code>-Methode die Benutzereinstellungen ab. Erlaubt der Benutzer E-Mail-Benachrichtigungen, schicken wir ihm eine E-Mail und reagieren, ebenfalls wieder asynchron, auf den Response des Mailservers.</p>
<p>Dabei ist das Beispiel noch ein relativ simples, es gibt keinerlei explizite Fehlerbehandlung und es gibt auch keine nennenswerten Ausnahmefälle. Dennoch ist der Code im Beispiel bereits <strong>6 Ebenen</strong> tief verschachtelt. Das Arbeiten mit Callbacks kann daher schnell unübersichtlich werden, insbesondere wenn innerhalb einer Callback-Funktion weitere Callback-Funktionen ausgeführt werden, wie in unserem Beispiel. So kommt es schnell zu der oft auch als <strong>Pyradmid of Doom</strong> bezeichneten Verschachtelung von Callbacks.</p>
<p>Nun schreiben wir das Beispiel einmal um und gehen davon aus, unsere fiktiven API-Methoden geben jeweils ein Promise zurück:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> errorHandler = <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'An error occured:'</span>, err.message);
};

getUser(id)
  .then(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> user.getFriends())
  .then(<span class="hljs-function">(<span class="hljs-params">friends</span>) =&gt;</span> friends[<span class="hljs-number">0</span>].getSettings())
  .then(<span class="hljs-function">(<span class="hljs-params">settings</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (settings.notifications === <span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">return</span> email.send(<span class="hljs-string">'You are my first friend!'</span>);
    }
  })
  .then(<span class="hljs-function">(<span class="hljs-params">status</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (status === <span class="hljs-number">200</span>) {
      alert(<span class="hljs-string">'User has been notified via email'</span>);
    }
  })
  .catch(errorHandler);</code></pre>
<p>Wir reagieren hier nach jedem Schritt mittels <code>then()</code> auf das zurückgegebene Promise, erreichen das gleiche Resultat wie vorher bei der Callback-Version, haben aber an der tiefsten Stelle lediglich eine Verschachtelung die 2 Ebenen tief ist.</p>
<p>Dabei ist es relativ simpel bestehenden, Callback basierenden Code in Promises umzuschreiben. Das möchte ich kurz anhand der Geolocation API und konkret deren <code>getCurrentPosition()</code>-Methode demonstrieren. Wer es nicht kennt: die Methode existiert auf dem <code>navigator.geolocation</code> Objekt, öffnet eine Benachrichtigung im Browser und fragt den Benutzer um Erlabnis ihn orten zu dürfen. Sie erwartet zwei Callbacks als Argument: das erste, der Success-Callback, bekommt ein Objekt mit der Position des Benutzers übergeben, falls dieser der Ortung zustimmt. Der zweite, der Error-Callback, bekommt ein Fehler-Objekt übergeben, falls der Benutzer einer Ortung entweder nicht zugestimmt hat oder eine Ortung aus anderen Gründen nicht möglich ist.</p>
<pre><code class="hljs javascript language-javascript">navigator.geolocation.getCurrentPosition(
  <span class="hljs-function">(<span class="hljs-params">position</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(
      <span class="hljs-string">`User position is at <span class="hljs-subst">${position.coords.latitude}</span>, <span class="hljs-subst">${
        position.coords.longitude
      }</span>`</span>
    );
  },
  () =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Unable to locate user'</span>);
  }
);</code></pre>
<p>Und so wird der Callback in ein Promise umgewandelt:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> getCurrentPositionPromise = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    navigator.geolocation.getCurrentPosition(resolve, reject);
  });
};</code></pre>
<p>Jap. Das war es wirklich schon. Nun können wir statt mittels der Callback-Syntax über folgenden Aufruf auf die Position des Benutzers zugreifen:</p>
<pre><code class="hljs javascript language-javascript">getCurrentPositionPromise()
  .then(<span class="hljs-function">(<span class="hljs-params">position</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(
      <span class="hljs-string">`User position is at <span class="hljs-subst">${position.coords.latitude}</span>, <span class="hljs-subst">${
        position.coords.longitude
      }</span>`</span>
    );
  })
  .catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Unable to locate user'</span>);
  });</code></pre>
<p>Einige neuere JavaScript APIs im Browser sind bereits diesem Ansatz folgend implementiert worden. Wer mehr über Promises und deren Funktionsweise erfahren möchte, dem empfehle ich <a href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Promise">den entsprechenden Artikel bei den MDN Web Docs</a> zu lesen. Die Erklärung zu Promises sollte nur einleitend sein um auf ein deutlich spannenderes neues Feature vorzubereiten, nämlich:</p>
<h3 id="asynchrone-funktionen-mit-async-und-await">Asynchrone Funktionen mit <code>async</code> und <code>await</code></h3>
<p>Asynchrone Funktionen mit den Schlüsselwörtern <code>async</code> und <code>await</code> kann vielleicht ein Bisschen als die „nächste Evolutionsstufe“ in der asynchronen Entwicklung nach Callbacks und Promises gesehen werden. Sie haben Einzug in die JavaScript-Spezifikation in ES2016 erhalten. Unter der Haube nutzen sie zwar noch immer Promises, machen diese aber weitgehend unsichtbar. Sie erlauben es uns asynchronen Code so zu schreiben, dass er nahezu wie synchroner Code aussieht. Keine Callbacks mehr und auch kein <code>then()</code> oder <code>catch()</code> mehr.</p>
<p>Dazu wird einem asynchronen Funktionsaufruf das Schlüsselwort <code>await</code> vorangestellt. Um <code>await</code> nutzen zu können, muss die umgebende Funktion das zweite Schlüsselwort <code>async</code> vorangestellt werden, um dem JavaScript-Interpreter mitzuteilen, dass es sich um eine solche asynchrone Funktion handelt. Bei der Nutzung von <code>await</code> ohne eine Funktion als <code>async</code> zu markieren kommt es zu einer Exception.</p>
<p>Werfen wir also nochmal einen Blick auf das Beispiel unseres Users, der eine E-Mail an seinen ersten Freund schicken möchte. Diesmal mit asynchronen Funktionen:</p>
<pre><code class="hljs javascript language-javascript">(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> getUser(id);
    <span class="hljs-keyword">const</span> friends = <span class="hljs-keyword">await</span> user.getFriends();
    <span class="hljs-keyword">const</span> settings = <span class="hljs-keyword">await</span> friends[<span class="hljs-number">0</span>].getSettings();
    <span class="hljs-keyword">if</span> (settings.notifications === <span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">const</span> status = <span class="hljs-keyword">await</span> email.send(<span class="hljs-string">'You are my first friend!'</span>);
      <span class="hljs-keyword">if</span> (status === <span class="hljs-number">200</span>) {
        alert(<span class="hljs-string">'User has been notified via email'</span>);
      }
    }
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'An error occured:'</span>, err.message);
  }
})();</code></pre>
<p>Asynchrone Funktionen mit <code>async</code> und <code>await</code> sind für mich persönlich eine der nennenswertesten Veränderungen von JavaScript in den vergangenen Jahren, da sie das Arbeiten mit asynchronen Daten fast zum Kinderspiel werden lassen, verglichen mit komplexen und unübersichtlichen Callbacks. Und auch Promises, die bereits eine große Erleichterung ggü. herkömmlichen Callbacks waren, wirken im direkten Vergleich mit asynchronen Funktionen schon beinahe komplex.</p>
<h2 id="import-syntax-und-javascript-module">import-Syntax und Javascript-Module</h2>
<p>Module in JavaScript sind so eine Sache. Offiziell gab es sie bisher nicht, aber es gab immer wieder Versuche, Module in JavaScript einzuführen. Wer schon etwas länger dabei ist wird vielleicht noch <strong>AMD</strong> (Asynchronous Module Definition) kennen, wer mal mit Node.js gearbeitet hat, dem sollten außerdem CommonJS-Module (d.h. <code>module.exports</code> und <code>require('./myModule')</code>) ein Begriff sein. Lange gab es dann ausführliche Diskussionen darüber, auf welchen Modul-Standard man sich einigt, wie die Syntax aussieht und wie letztendlich die Implementierung auf Interpreter-Seite aussieht. Die Wahl fiel auf Modulen, die mittels <code>import</code> und <code>export</code> Keywords untereinander kommunizieren.</p>
<p>Babel ist dann vorangegangen und hat eine Lösung implementiert, die auf dem damaligen Stand der offiziellen Spezifikation basierte. Diese Umsetzung wurde dann zwischendurch mal geändert, weil es Updates am entsprechenden Standard gab, dann kam noch Webpack und implementierte einen eigenen Mechanismus zum Auflösen und Laden von JavaScript-Modulen, der sich am nun verabschiedeten Standard orientiert. Ebenso wie TypeScript.</p>
<p>Mittlerweile ist man sich nach gerade einmal <strong>10</strong> Jahren bei der Spezifikation einig und die Umsetzung auf Seiten der JavaScript-Engines ist im vollen Gange. Klingt kompliziert, ist es zwischendrin auch mal gewesen, inzwischen gibt es aber Konsens und für uns Entwickler herrscht allmählich Klarheit. Aber dennoch gibt es auch noch immer einige Fallstricke, durch die wir auch in Zukunft auf Webpack, Babel oder TypeScript setzen müssen (oder eher: sollten), um komfortabel mit Modulen zu arbeiten. Dazu später mehr.</p>
<p>Soviel zur Historie. Also wie funktionieren jetzt Imports und was sind Module überhaupt?</p>
<h3 id="module-in-javascript">Module in JavaScript</h3>
<p>Das Ziel von Modulen ist es, Scopes in JavaScript auf einer <strong>per Modul-Ebene zu kapseln</strong>. Ein Modul in diesem Sinne ist tatsächlich ein einzelnes <strong>File</strong>. Sofern man sie nicht explizit durch das Erstellen eines neuen Scopes begrenzt, z.B. indem man es in eine <strong>IIFE</strong> (Immediately Invoked Function Expression) einschließt, ist jede Funktion, jede Variable, die in JavaScript definiert wird erst einmal global verfügbar. Module wirken dem entgegen, indem sämtlicher Code erst einmal nur <strong>innerhalb des Moduls</strong> verfügbar ist. Dadurch vermeidet man Komplikationen, bspw. wenn zwei Libraries die gleiche Variable nutzen, außerdem schafft man auf einfache Art wiederverwendbaren Code, ohne auf der anderen Seite Angst haben zu müssen, dass dieser an anderer Stelle bereits existierende Variablen oder Funktionen ungewollt überschreibt.</p>
<p>Module können die in ihnen definierten Funktionen, Klassen oder Variablen <strong>exportieren</strong>, andere Module können diese Exports dann bei Bedarf importieren. Für den Export von Funktionen und Variablen gibt es ein <code>export</code>-Keyword, um diese Exports dann später an anderer Stelle zu importieren gibt es, ihr denkt es euch, das entsprechende <code>import</code>-Keyword. Exports können zwei Formen annehmen, nämlich zum Einen die eines <strong>Named Exports</strong> (dt. <strong>benannte Exporte</strong>) und auf der anderen Seite den, des <strong>Default Export</strong> (dt. <strong>Standard Export</strong>).</p>
<h4 id="named-exports">Named Exports</h4>
<p>Nehmen wir an wir haben ein Modul <code>calc.mjs</code>, das allerhand Funktionen für uns bereitstellt, um Berechnungen verschiedener Art auszuführen. Das Modul könnte bspw. den folgenden Inhalt haben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> double = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number * <span class="hljs-number">2</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> square = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number * number;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> divideBy = <span class="hljs-function">(<span class="hljs-params">number, divisor</span>) =&gt;</span> number / divisor;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> divideBy5 = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> divideBy(number, <span class="hljs-number">5</span>);</code></pre>
<p>Wir kündigen hier also einen <strong>Export</strong> an, definieren direkt danach eine Variable der wir eine Arrow Function zuweisen, die einen Parameter bekommt (oder zwei) und direkt das Ergebnis der Berechnung zurückgibt. Alternativ geht das auch in zwei separaten Schritten:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> double = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number * <span class="hljs-number">2</span>;
<span class="hljs-keyword">export</span> double;</code></pre>
<p>An anderer Stelle innerhalb unserer Anwendung können wir diese Funktionen nun mittels <code>import</code>-Keyword <strong>importieren</strong>. Dazu nutzen wir <code>import</code> gefolgt von den Exports, die wir importieren wollen, in geschweiften Klammern, gefolgt von <code>from</code> und dem Pfad zum Modul.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> { double, square, divideBy5 } <span class="hljs-keyword">from</span> <span class="hljs-string">'./calc.mjs'</span>;

<span class="hljs-keyword">const</span> value = <span class="hljs-number">5</span>;
<span class="hljs-built_in">console</span>.log(double(value)); <span class="hljs-comment">// 10</span>
<span class="hljs-built_in">console</span>.log(square(value)); <span class="hljs-comment">// 25</span>
<span class="hljs-built_in">console</span>.log(divideBy5(value)); <span class="hljs-comment">// 1</span></code></pre>
<p>Ein File kann dabei theoretisch <strong>unbegrenzt viele benannte Exports</strong> haben, sie müssen sich jedoch in ihrem Namen unterscheiden und ein bereits exportierter Name <strong>darf nicht ein weiteres Mal exportiert werden.</strong></p>
<h4 id="default-export">Default Export</h4>
<p>Zusätzlich zu den (Plural) sog. <strong>Named Exports</strong> aus dem obigen Beispiel gibt es noch den (Singular) <code>Default Export</code>. Eine spezielle Form eines Exports, der innerhalb eines jeden Moduls nur <strong>ein einziges Mal</strong> vorkommen darf und der mit dem Keyword <code>default</code> gekennzeichnet wird. Wird eine Variable oder eine Funktion als <code>default</code> gekennzeichnet ist es möglich, diesen Export auch ohne geschweifte Klammern zu importieren. Der <strong>Default Export</strong> kann z.B. dazu dienen, um mehrere benannte Exporte zu bündeln, um diese anschließend nicht einzeln importieren zu müssen.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> double = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number * <span class="hljs-number">2</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> square = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number * number;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> divideBy = <span class="hljs-function">(<span class="hljs-params">number, divisor</span>) =&gt;</span> number / divisor;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> divideBy5 = <span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> divideBy(number, <span class="hljs-number">5</span>);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  double,
  square,
  divideBy,
  divideBy5,
};</code></pre>
<p>Unsere Anwendung müsste dann stattdessen lediglich das Modul selbst importieren, also dessen <strong>Default Export</strong> und einer Variable zuweisen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> Calc <span class="hljs-keyword">from</span> <span class="hljs-string">'./calc.mjs'</span>;

<span class="hljs-built_in">console</span>.log(Calc.double(value)); <span class="hljs-comment">// 10</span>
<span class="hljs-built_in">console</span>.log(Calc.square(value)); <span class="hljs-comment">// 25</span>
<span class="hljs-built_in">console</span>.log(Calc.divideBy5(value)); <span class="hljs-comment">// 1</span></code></pre>
<p>Grundsätzlich ist es in vielen Fällen sinnvoll, dass ein Modul auch einen Default Export hat. Insbesondere bei Komponenten basierten Libraries wie React oder auch Vue.js ist es üblich nur einen Export pro Modul zu haben, dieser sollte dann der <strong>Default Export</strong> sein. Auch wenn dies syntaktisch nicht zwingend notwendig wäre, ist dies inzwischen de-facto Standard bei der Arbeit mit React.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-comment">// ...</span>
}</code></pre>
<h3 id="fallstricke-browser-vs-nodejs">Fallstricke: Browser vs. Node.js</h3>
<p>Wer aufmerksam war und gut aufgepasst hat, dem wird vielleicht aufgefallen sein, dass wir oben aus einem File mit dem Namen <code>calc.mjs</code> importieren, nicht <code>calc.js</code> (<code>.mjs</code> statt <code>.js</code>). Dies ist die Konvention, auf die man sich im langwierigen, oben beschriebenen Standardisierungsprozess geeinigt hat bei der Verwendung von JavaScript-Modulen in Node.js.</p>
<p>Wollt ihr also universelles JavaScript schreiben, also JavaScript das sowohl serverseitig mit Node.js ausgeführt werden kann, als auch clientseitig im Browser funktioniert, und wollt ihr das tun ohne einen Compiler-Zwischenschritt durch bspw. Babel, Webpack oder TypeScript einzulegen, <strong>müsst</strong> ihr zwangsweise die <code>.mjs</code>-Endung für eure Files verwenden.</p>
<p>Das Laden von Modulen funktioniert in Node.js also etwas anders als im Browser. Während es dem Browser egal ist welche Datei-Endung ein Modul hat (solange der Server den Content-Type <code>text/javascript</code> mitsendet), benötigt Node.js zwangsweise die <code>.mjs</code> Datei-Endung um JavaScript-Module als solche zu identifizieren.</p>
<p>Um JavaScript-Module im Browser zu nutzen, muss das <code>type</code>-Attribut auf dem <code>&lt;script&gt;&lt;/script&gt;</code>-Element den Wert <code>module</code> erhalten. Also:</p>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./myApp.mjs"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>Browser die den <code>type="module"</code> unterstützen, unterstützen auch gleichzeitig das <code>nomodule</code>-Attribut zur Auslieferung von Fallbacks für Browser ohne Module-Unterstützung und ignorieren dieses.</p>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./myApp.mjs"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./myApp.bundle.js"</span> <span class="hljs-attr">nomodule</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>Ein Browser mit Module-Support würde hier die <code>myApp.mjs</code> laden, während alle anderen stattdessen ein gebundletes (bspw. durch Webpack) <code>myApp.bundle.js</code> laden würden.</p>
<p>Doch das ist noch nicht alles, denn Node.js besitzt einen sehr eigenen Mechanismus zum Finden und Laden von Dateien. So werden bspw. Module die keinen relativen Pfad haben, also nicht mit <code>./</code> oder <code>../</code> beginnen, z.B. in <code>node_modules</code> oder <code>node_libraries</code> gesucht. Außerdem lädt Node.js standardmäßig eine darin befindliche index.js wenn Node.js einen Ordner mit dem angegebenen Namen findet.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> MyModule <span class="hljs-keyword">from</span> <span class="hljs-string">'myModule'</span>;</code></pre>
<p>Node.js würde also nach diesem Import u.a. im Ordner <code>./node_modules/myModule</code> suchen, dort eine <code>index.js</code> laden oder alternativ im <code>main</code>-Feld der <code>package.json</code> nach dem korrekten File suchen. Der Browser kann hingegen nicht nach belieben verschiedene Pfade ausprobieren um das richtige File zu finden, da dies jedesmal einen teuren Netzwerkrequest und möglicherweise viele 404 Responses verusachen würde.</p>
<p>Hinzu kommt, dass <strong>Import Specifier</strong>, das ist der Part hinter dem <code>from</code>, also das Modul aus dem ihr importieren wollt, im Browser geschützt sind und aus einer gültigen URL oder einem relativen Pfad bestehen müssen.</p>
<p>Imports wie der folgende, sind damit im Browser momentan gar nicht möglich:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;</code></pre>
<p>Abhilfe schaffen sollen hier später einmal die <strong>Package Name Maps</strong>, ein Proposal, also ein Vorschlag, für kommende ECMAScript Versionen, das aber momentan noch ganz am Anfang der Diskussion steht. Darum kommen wir wie eingangs erwähnt in absehbarer Zeit nicht drum herum auch weiterhin einen Module Bundler wie Webpack zu benutzen, um komfortabel mit ES-Modules arbeiten zu können wenn wir JavaScript-Module gleichzeitig sowohl serverseitig als auch clientseitig nutzen wollen.</p>
<h2 id="fazit">Fazit</h2>
<p>{% hint style="success" %}</p>
<p>ES2015 und die nachfolgenden Versionen bieten eine Menge nützliche neue Funktionen die es bisher in JavaScript nicht gab. Viele davon sind bei der Arbeit mit React nahezu nicht wegzudenken. Zu den wichtigsten Neuerungen gehören die hier beschriebenen:</p>
<ul>
<li>Variablendeklarationen mit <code>let</code> und <code>const</code></li>
<li><strong>Arrow Functions</strong>, um Funktionen zu erstellen die kein eigenes <code>this</code> binden</li>
<li><strong>Klassen</strong>. Machen vieles einfacher und sind die Basis von <strong>React Class Components</strong></li>
<li>Die <strong>Rest und Spread Operatoren</strong>, die das Lesen und Schreiben von Daten in Arrays und Objekten deutlich vereinfachen</li>
<li><strong>Template Strings</strong>, um die Arbeit mit JavaScript-Ausdrücken in Strings einfacher zu machen</li>
<li><strong>Promises</strong> und <strong>Asynchrone Funktionen</strong> mittels <code>async</code>/<code>await</code> um die Arbeit mit asynchronen Daten deutlich zu vereinfachen</li>
<li><strong>Import</strong> und <strong>Export</strong> für die Kapselung von wiederverwendbarem JavaScript auf Module-Ebene</li>
</ul>
</div><div class="chapter">
<h1 id="jsx-–-eine-einführung">JSX – eine Einführung</h1>
<h2 id="jsx-als-wichtiger-bestandteil-in-der-react-entwicklung">JSX als wichtiger Bestandteil in der React-Entwicklung</h2>
<p>Bevor wir tiefer in die Entwicklung von Komponenten einsteigen möchte ich zuerst einmal auf <strong>JSX</strong> eingehen, da JSX einen wesentlichen Teil bei der Arbeit mit React darstellt. Wie eingangs schon erwähnt stellt JSX einen ganz grundlegenden Teil der meisten React-Komponenten dar und ist aus meiner Sicht einer der Gründe, warum React so schnell und positiv von so vielen Entwicklern angenommen wurde. Mittlerweile bieten auch andere Frameworks wie Vue.js die Möglichkeit JSX zur Komponenten getriebenen Entwicklung einzusetzen.</p>
<p>JSX sieht auf den ersten Blick erst einmal gar nicht sehr viel anders aus als HTML, oder eher noch XML, da in JSX, eben wie auch in XML und XHTML jedes geöffnete Element ein schließendes Element (<code>&lt;/div&gt;</code>) besitzen oder selbstschließend (<code>&lt;img /&gt;</code>) sein muss. Mit dem grundlegenden Unterschied, dass JSX auf <strong>JavaScript-Ausdrücke</strong> zurückgreifen kann und dadurch sehr mächtig wird.</p>
<p>Unter der Haube werden in JSX verwendete Elemente in einem späteren Build-Prozess in verschachtelte <code>React.createElement()</code>-Aufrufe umgewandelt. Wir erinnern uns zurück an die Einleitung. Dort hatte ich bereits kurz erwähnt das React eine Baumstruktur an Elementen erzeugt, die selbst aus verschachtelten <code>React.createElement()</code>-Aufrufen besteht.</p>
<p>Klingt jetzt alles fürchterlich kompliziert, ist aber ganz einfach. Wirklich. Ein Beispiel: sehen wir uns einmal das folgende kurze HTML-Snippet an:</p>
<pre><code class="hljs jsx language-jsx">&lt;div id="app"&gt;
  &lt;p&gt;Ein Paragraph in JSX&lt;/p&gt;
  &lt;p&gt;Ein weiterer Paragraph&lt;/p&gt;
&lt;/div&gt;</code></pre>
<p>Wird dieses HTML so in dieser Form in <strong>JSX</strong> verwendet, werden diese Elemente werden später durch Babel in das folgende ausführbare JavaScript transpiliert:</p>
<pre><code class="hljs javascript language-javascript">React.createElement(
  <span class="hljs-string">'div'</span>,
  { <span class="hljs-attr">id</span>: <span class="hljs-string">'app'</span> },
  React.createElement(<span class="hljs-string">'p'</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'Ein Paragraph in JSX'</span>),
  React.createElement(<span class="hljs-string">'p'</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'Ein weiterer Paragraph'</span>)
);</code></pre>
<p>Das erste Funktionsargument für <code>createElement()</code> ist dabei jeweils der Tag-Name eines DOM-Elements als String-Repräsentation oder ein anderes JSX-Element, dann allerdings als Funktionsreferenz.</p>
<p>Das zweite Argument repräsentiert die <strong>Props</strong> eines Elements, also in etwa vergleichbar mit HTML-Attributen, wobei die Props in React deutlich flexibler sind und anders als herkömmliche HTML-Attribute nicht auf Strings beschränkt sind, sondern auch Arrays, Objekte oder gar andere React-Komponenten als Wert enthalten können.</p>
<p>Alle weiteren Argumente stellen die Kind-Elemente (<em>„children“</em>) des Elements dar. Im obigen Beispiel hat unser <code>div</code> zwei Paragraphen (<code>&lt;p&gt;</code>) als Kind-Elemente, welche selbst keine eigenen Props haben (<code>null</code>) und lediglich einen Text-String (<code>Ein Paragraph in JSX</code> bzw <code>Ein weiterer Paragraph</code>) als Kind-Element besitzt.</p>
<p>Wem das jetzt zu kompliziert klingt den kann ich beruhigen: das geht in der Praxis hinterher wie von selbst von der Hand. Fast so, als würde man HTML-Markup schreiben. Dennoch halte ich es für wichtig die Hintergründe zumindest einmal gelesen zu haben um spätere Beispiele besser nachvollziehen zu können.</p>
<h2 id="ausdrücke-in-javascript">Ausdrücke in JavaScript</h2>
<p>Was bedeutet dies nun für unsere JavaScript-Ausdrücke, auf die wir ja nun auch in JSX zurückgreifen können?</p>
<p>Zuerst einmal ist ein Ausdruck in JavaScript, kurz gesagt, ein Stück Code, der am Ende einen „Wert“ erzeugt bzw ein „Ergebnis“ zur Folge hat. Vereinfacht gesagt: alles was man bei der Variablenzuweisung auf die <strong>rechte</strong> Seite des Gleich-Zeichens (=) schreiben kann.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-number">1</span> + <span class="hljs-number">5</span>;</code></pre>
<p>… ist ein solcher Ausdruck, dessen Wert <code>6</code> beträgt.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-string">'Hal'</span> + <span class="hljs-string">'lo'</span>;</code></pre>
<p>… ist ein anderer Ausdruck der die zwei Strings <code>Hal</code> und <code>lo</code> per <strong>String Concatenation</strong> zu einem Wert <code>Hallo</code> zusammenfügt.</p>
<p>Stattdessen könnten wir aber auch einfach gleich schreiben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-number">6</span>
<span class="hljs-string">'Hallo'</span>
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
{<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>}
<span class="hljs-literal">true</span>
<span class="hljs-literal">null</span></code></pre>
<p>… da <strong>JavaScript-Datentypen</strong> allesamt auch als Ausdruck verwendet werden können.</p>
<p>Die ES2015 <strong>Template String Syntax</strong>, die Backticks (```) benutzt, ist ebenfalls ein Ausdruck. Klar, sind sie doch letztlich nichts anderes als ein String:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-string">`Hallo <span class="hljs-subst">${name}</span>`</span>;</code></pre>
<p>Was hingegen <strong>kein</strong> Ausdruck ist, ist:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">if</span> (active &amp;&amp; visibility === <span class="hljs-string">'visible'</span>) { … }</code></pre>
<p>… da ich zum Beispiel auch nicht schreiben könnte:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> isVisible = <span class="hljs-keyword">if</span> (active &amp;&amp; visibility === <span class="hljs-string">'visible'</span>) { … }</code></pre>
<p>Das würde mir jeder JavaScript-Interpreter wegen ungültiger Syntax um die Ohren hauen.</p>
<p>Lasse ich das <code>if</code> hier hingegen allerdings weg habe ich einen <strong>Logical AND Operator</strong>, der wiederum ein Ausdruck ist und einen Wert zum Ergebnis hat (in diesem Fall <code>true</code> oder <code>false</code>):</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">const</span> isVisible = active &amp;&amp; visibility === <span class="hljs-string">'visible'</span>;</code></pre>
<p>Ebenso ist der Ternary-Operator ( ? : ) ein Ausdruck:</p>
<pre><code class="hljs javascript language-javascript">Bedingung ? wahr : unwahr;</code></pre>
<p>Ausdrücke sind aber nicht auf boolsche Werte, Nummern, Strings beschränkt sondern können auch Objekte, Arrays, Funktionsaufrufe und sogar Arrow-Functions sein, die ebenfalls neu in ES2015 eingeführt werden und uns hier nicht das letzte mal begegnet sein werden.</p>
<p>Beispiel für eine Arrow-Function:</p>
<pre><code class="hljs javascript language-javascript">(number) =&gt; {
  <span class="hljs-keyword">return</span> number * <span class="hljs-number">2</span>;
};</code></pre>
<p>All das wird später noch wichtig werden. Um dem ganzen jetzt endgültig die Krone aufzusetzen können Ausdrücke selbst wiederum wieder JSX beinhalten und so kann man das Spiel endlos weiterführen. Uff.</p>
<p>Da das später noch wichtig wird, hier nochmal einige Beispiele für JSX, das gültige Ausdrücke beinhaltet:</p>
<h4 id="simple-mathematik">Simple Mathematik</h4>
<pre><code class="hljs jsx language-jsx">&lt;span&gt;<span class="hljs-number">5</span> + <span class="hljs-number">1</span> = {<span class="hljs-number">5</span> + <span class="hljs-number">1</span>}&lt;<span class="hljs-regexp">/span&gt;</span></code></pre>
<h4 id="ternary-operator">Ternary Operator</h4>
<pre><code class="hljs jsx language-jsx">&lt;span&gt;Heute ist {<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getDay() === <span class="hljs-number">1</span> ? <span class="hljs-string">'Montag'</span> : <span class="hljs-string">'nicht Montag'</span>}&lt;<span class="hljs-regexp">/span&gt;</span></code></pre>
<h4 id="ternary-operator-als-wert-einer-prop">Ternary Operator als Wert einer Prop</h4>
<pre><code class="hljs jsx language-jsx">&lt;div className={user.isAdmin ? <span class="hljs-string">'is-admin'</span> : <span class="hljs-literal">null</span>}&gt;…&lt;<span class="hljs-regexp">/div&gt;</span></code></pre>
<h4 id="arraymap-mit-jsx-als-rückgabewert-das-wiederum-einen-ausdruck-enthält">Array.map() mit JSX als Rückgabewert das wiederum einen Ausdruck enthält</h4>
<pre><code class="hljs jsx language-jsx">&lt;ul&gt;
  {[<span class="hljs-string">'Tim'</span>, <span class="hljs-string">'Struppi'</span>].map(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>{name})<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
  ))}
&lt;<span class="hljs-regexp">/ul&gt;</span></code></pre>
<h4 id="zahlenwerte-in-props">Zahlenwerte in Props</h4>
<pre><code class="hljs jsx language-jsx">&lt;input type=<span class="hljs-string">"range"</span> min={<span class="hljs-number">0</span>} max={<span class="hljs-number">100</span>} /&gt;</code></pre>
<p>All dies sind erste Beispiele wie Ausdrücke dafür verwendet werden können um aus JSX mehr als nur simples HTML zu machen.</p>
<h2 id="was-man-außerdem-wissen-sollte"><strong>Was man außerdem wissen sollte</strong></h2>
<p>Wer die Beispiele aufmerksam studiert hat, dem werden je nach JavaScript-Kenntnissen vielleicht einige Dinge aufgefallen sein. Zuerst einmal tauchen in den Beispielen scheinbar willkürlich Klammern auf. Dies hat den Hintergrund, dass JSX stets in Klammern, also „<code>(</code>“ und „<code>)</code>“ geschrieben werden muss wenn sich das JSX sich über mehr als eine Zeile erstreckt (also doch nicht willkürlich.)</p>
<p>Prinzipiell schadet es nicht sein komplettes JSX immer in Klammern zu schreiben, auch wenn es sich nur um eine einzige Zeile handelt, Viele Leute bevorzugen das sogar aus Gründen der Einheitlichkeit, wirklich zwingend notwendig ist das aber nur bei mehrzeiligem JSX.</p>
<p>Möchten wir statt eines <strong>Strings</strong> einen <strong>Ausdruck</strong> innerhalb der Props nutzen wie im Beispiel <em>„Ternary Operator als Wert einer Prop“</em>, so nutzen wir dafür statt einfacher oder doppelter Attribut-Anführungszeichens auch hier die geschweiften Klammern um React mitzuteilen: hier drin befindet sich ein Ausdruck.</p>
<div class="hint hint--warning">
<p>Bei Objekten als Wert müssen jeweils <strong>zwei</strong> öffnende und schließende Klammern geschrieben werden. Die äußeren Klammern leiten den Ausdruck ein (bzw. beenden diesen) und die inneren sind die, des eigentlichen Objekts:</p>
<p><code>&lt;User data={{ name: 'Manuel', location: 'Berlin' }} /&gt;</code></p>
<p>Das gilt in ähnlicher Form auch für Array-Literals, natürlich mit dem Unterschied, dass die inneren Klammern die eckigen sind, die das Array-Literal kennzeichnen:</p>
<p><code>&lt;List items={[1, 2, 3, 4, 5]} /&gt;</code></p>
</div>
<p>Weiter könnte manch einem aufgefallen sein, dass im gleichen Beispiel die Prop <code>className</code> verwendet wird. Wer jemals mit der DOM Element im Browser gearbeitet hat dem wird vielleicht im Gedächtnis geblieben sein, dass mittels <code>Element.className</code> auf das <code>class</code>-Attribute eines Elements zugegriffen werden kann. Ganz genau so ist das auch in React, das sich an den Eigenschaften der DOM <code>Element</code> Klasse bedient.</p>
<p>Möchte man gewisse HTML-Attribute in JSX setzen, ist dafür also die JavaScript-Entsprechung zu verwenden. <code>class</code> ist ein geschütztes Keyword in JavaScript um eine Klasse zu kennzeichnen, also verwenden wir an dieser Stelle stattdessen <code>className</code>. Gleiches gilt für <code>for</code>, was in JavaScript als Keyword benutzt wird um Schleifen einzuleiten, in HTML aber hingegen um <code>&lt;label&gt;</code> Elementen mitzuteilen, welches Eingabefeld sie beschreiben. Statt <code>for</code> schreiben wir in JSX also angelehnt an das DOM <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/htmlFor">HTMLLabelElement Interface</a> <code>htmlFor</code>:</p>
<pre><code class="hljs jsx language-jsx">&lt;fieldset&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"name"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">htmlFor</span>=<span class="hljs-string">"name"</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span></span></code></pre>
<p>Dieses Muster zieht sich konsequent durch alle bekannten HTML-Attribute. Möchtest du ein HTML-Attribut in JSX setzen, musst du dafür die Schreibweise der entsprechenden JavaScript DOM Element-Eigenschaft verwenden. So wird aus <code>tabindex</code> eben <code>tabIndex</code>, <code>readonly</code> wird zu <code>readOnly</code>, <code>maxlength</code> wird zu <code>maxLength</code>, usw.</p>
<p>Aber: Keine Angst! Im Development-Modus gibt React eine entsprechende Warnung aus, so dass es dir selten passieren sollte, dass du entsprechenden fehlerhaften Code nicht bemerkst:</p>
<p class="has-image"><span><img src="https://lh6.googleusercontent.com/cgdej1K-RlV-97RDzKO2X_yQFhNNknM1rBge0--1I8ID59-IQTHWK9nfGNM0PdN44WTRKe4hPE-r3zZpgnQUstLHR-vCbegZn440oLLGCU7chWa6gkbfcMhQbwBB6swb1lL83jTM" alt="Warnung in der Browser Console bei der Verwendung illegaler Props" /><span class="caption">Warnung in der Browser Console bei der Verwendung illegaler Props</span></span></p>
<p>Wer es genau wissen will, hier die vollständige Liste unterstützter HTML-Attribute wie sie in der offiziellen React-Doku steht (festhalten, wird lang):</p>
<blockquote>
  <p><code>accept acceptCharset accessKey action allowFullScreen alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge charSet checked cite classID className colSpan cols content contentEditable contextMenu controls controlsList coords crossOrigin data dateTime default defer dir disabled download draggable encType form formAction formEncType formMethod formNoValidate formTarget frameBorder headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media mediaGroup method min minLength multiple muted name noValidate nonce open optimum pattern placeholder poster preload profile radioGroup readOnly rel required reversed role rowSpan rows sandbox scope scoped scrolling seamless selected shape size sizes span spellCheck src srcDoc srcLang srcSet start step style summary tabIndex target title type useMap value width wmode wrap</code></p>
</blockquote>
<p>Das gleiche gilt übrigens auch für SVG-Elemente, die man ebenfalls innerhalb von JSX verwenden kann, da SVG valides XML ist! Die Liste der unterstützten SVG-Attribute ist aber gut und gerne 3 mal so lang und längst nicht so relevant im Alltag, weswegen ich dich in diesem Fall aber nun wirklich an die entsprechende Stelle in der offiziellen Doku verweisen muss: <a href="https://reactjs.org/docs/dom-elements.html#all-supported-html-attributes">https://reactjs.org/docs/dom-elements.html#all-supported-html-attributes</a></p>
<h2 id="sonderfall-inline-styles">Sonderfall Inline-Styles</h2>
<p>Natürlich gibt es auch Sonderfälle. Das style-Attribut ist ein solcher. Während Inline-Styles in HTML mit den originalen CSS-Eigenschaftsnamen und als String geschrieben werden, benutzt React, du ahnst es: JavaScript-Eigenschaften und außerdem ein Objekt statt eines einfachen Strings.</p>
<p>Schreibst du in herkömmlichem HTML:</p>
<pre><code class="hljs markup language-markup">&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">"margin-left: 12px; border-color: red; padding: 8px"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre>
<p>Sieht das Gegenstück in JSX so aus:</p>
<pre><code class="hljs jsx language-jsx">&lt;div style={{ <span class="hljs-attr">marginLeft</span>: <span class="hljs-string">'12px'</span>, <span class="hljs-attr">borderColor</span>: <span class="hljs-string">'red'</span>, <span class="hljs-attr">padding</span>: <span class="hljs-string">'8px'</span> }} /&gt;</code></pre>
<p>Ein weiterer Sonderfall sind Events. Da diese sehr umfangreich sind, widmen wir uns dem Thema später in einem eigenen Kapitel nochmal.</p>
<h2 id="kommentare-in-jsx">Kommentare in JSX</h2>
<p>Auch Kommentare sind möglich in JSX, funktionieren aber nicht wie in HTML in der Form:</p>
<pre><code class="hljs markup language-markup"><span class="hljs-comment">&lt;!-- Dies ist ein Beispiel für einen Kommentar --&gt;</span></code></pre>
<p>… sondern werden ebenfalls wie Ausdrücke in geschweifte Klammern gefasst, und dann in Form eines JavaScript Mehrzeilenkommentars geschrieben:</p>
<pre><code class="hljs jsx language-jsx">{
  <span class="hljs-comment">/* So sieht ein Kommentar in JSX aus */</span>
}</code></pre>
<p>Derartige Kommentare können sich natürlich auch über mehrere Zeilen erstrecken. Einzeilige JavaScript Kommentare die mit einem doppelten Slash (<code>//</code>) eingeleitet werden sind hingegen nicht möglich in JSX. Hier muss also auch bei einem kurzen einzeiligen Kommentar die <code>/* */</code> Syntax für mehrzeilige Kommentare verwendet werden.</p>
<p>Damit solltest du auch schon ausreichend Kenntnisse über JSX erlangt haben, um die nachfolgenden Beispiele und Beschreibungen mit weiteren Verlauf immer besser verstehen und nachvollziehen zu können</p>
<h2 id="fazit">Fazit</h2>
<div class="hint hint--success">
<ul>
<li>Mehrzeiliges JSX muss stets in Klammern gesetzt werden</li>
<li>JSX kann JavaScript-Ausdrücke verarbeiten. Diese müssen in geschweifte Klammern gesetzt werden und können dann auch in Props verwendet werden.</li>
<li>Um Attribute für HTML-Elemente zu setzen muss die Schreibweise des DOM Element Interface benutzt werden (<code>htmlFor</code> statt <code>for</code>, <code>className</code> statt <code>class</code>)</li>
<li>CSS Inline-Styles werden als JavaScript Object geschrieben</li>
<li>Kommentare werden ebenfalls in geschweifte Klammern gesetzt und verwenden Multiline-Comment Syntax: <code>/* */</code></li>
</ul>
</div>
</div><div class="chapter">
<h1 id="rendering-von-elementen">Rendering von Elementen</h1>
<p>In einigen der vorherigen Kapitel habe ich sie wie selbstverständlich bereits einige Male erwähnt, doch was genau sind <strong>React Elemente</strong> eigentlich?</p>
<p><strong>React Elemente</strong> sind der kleinstmögliche Baustein in einer <strong>React Anwendung</strong>. Anhand der <strong>Elemente</strong> beschreibt ihr, was der Benutzer später auf dem Bildschirm zu sehen bekommt. Trotz ihres gleichen Namens unterscheiden sie sich von DOM-Elementen in einem wesentlichen Punkt: sie sind lediglich ein einfaches Objekt und damit auch günstig (im Sinne der Performance) zu erstellen. Die bloße Erstellung eines <strong>React Elements</strong> mittels <code>React.createElement()</code> löst noch keine DOM Operation aus!</p>
<div class="hint hint--warning">
<p>React <strong>Elemente</strong> werden oftmals mit React <strong>Komponenten</strong> durcheinander geworfen oder im Sprachgebrauch analog verwendet. Das ist aber nicht korrekt! <strong>Elemente</strong> sind das, aus was <strong>Komponenten</strong> letztendlich bestehen. <strong>Komponenten</strong> werden im nächsten Kapitel noch ausführlich behandelt, bevor es damit weitergeht, solltest du jedoch zuerst dieses Kapitel über <strong>Elemente</strong> gelesen haben.</p>
</div>
<p>Wir wissen bereits wie wir mittels <strong>JSX</strong> ein <strong>React Element</strong> erstellen und das <strong>JSX</strong> nur eine Vereinfachung ist, um uns viel Schreibarbeit und ständige <code>React.createElement()</code>-Aufrufe zu ersparen. Doch wie rendern wir ein erstelltes Element nun, also mit anderen Worten, zeigen wir es im Browser an?</p>
<p>Hier bedienen wir uns an <code>ReactDOM</code>, genauer gesagt dessen eigener <code>render()</code>-Methode. Um ein React Element zu rendern benötigen wir grundsätzlich eine <strong>Root-</strong> oder <strong>Mount-Node</strong>. Dies ist eine DOM-Node die sozusagen als Platzhalter dient und die React mitteilt, wohin ein Element gerendert werden soll. Theoretisch kannst du problemlos mehrere Root-Nodes in deinem HTML-Dokument haben. React kontrolliert diese alle unabhängig voneinander. Statt also nur einer großen React-Anwendung kannst du also auch auch viele kleine (oder auch große) Anwendungen in einem einzigen HTML-Dokument unterbringen. Üblich ist es aber normalerweise nur <strong>eine Root-Node</strong> für deine React-Anwendung zu haben.</p>
<p>Kommen wir also zum Wesentlichen: um ein React <strong>Element</strong> zu rendern übergibst du dieses als erstes Argument der <code>ReactDOM.render()</code>-Methode, zusammen mit der <strong>Root-Node</strong> als zweitem Argument, also der DOM-Node, in das dein <strong>Element</strong> gerendert werden soll.</p>
<p>Stellen wir uns einmal vor du hast ein <code>div</code> mit der ID <code>root</code>in deinem HTML-Dokument, das als <strong>Root-Node</strong> dienen soll:</p>
<pre><code class="hljs markup language-markup"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>Der entsprechende Aufruf ist dann der folgende:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">var</span> myFirstElement = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Mein erstes React Element<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
ReactDOM.render(myFirstElement, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));</code></pre>
<p>Führst du diesen Code nun im Browser aus, siehst du <strong>innerhalb</strong> des <code>root</code>-divs nun dein <code>&lt;div&gt;Mein erstes React Element&lt;/div&gt;</code>.</p>
<p><strong>React Elemente</strong> sind dabei <strong>immutable</strong>, also unveränderlich. Dies bedeutet, ist ein Element einmal erstellt, repräsentiert es immer einen bestimmten Zustand („State“) im User Interface. Die offizielle React Dokumentation spricht hier metaphorisch von einem Einzelbild in einem Film. Möchten wir unser User Interface aktualisieren, müssen wir dazu ein neues <strong>React Element</strong> mit den veränderten Daten erstellen. Keine Angst, das klingt umständlicher als es ist und passiert später einmal ganz intuitiv.</p>
<p>React selbst ist dabei so klug, dass es durch einen Vergleichsalgorithmus nur die Teile einer Anwendung aktualisiert, die sich auch tatsächlich verändert haben. Dabei werden <strong>React Elemente</strong> und ihre Kind-Elemente mit ihren Vorgängerversionen vergleichen und lösen nur eine DOM-Operation aus wenn eine Änderung vorliegt. Dies führt dazu, dass React Anwendungen, richtig gemacht, sehr gute Rendering-Performance aufweisen, da DOM-Operationen in der Regel sehr kostspielig (also Performance lastig) sind, durch React und seinen <strong>Reconciliation</strong> genannten Prozess aber auf ein Minimum verringert werden. Dabei werden nicht immer grundsätzlich ganze DOM-Elemente neu erzeugt anhand der Beschreibung eines <strong>React-Elements</strong>, sondern es werden auch nur einzelne Attribute aktualisiert, sollte sich nur ein solches geändert haben.</p>
<p>Schauen wir uns das mal in der Praxis an:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showTime</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleTimeString();
  <span class="hljs-keyword">var</span> timeElement = (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Es ist jetzt {time} Uhr<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
  ReactDOM.render(timeElement, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));
}
setInterval(showTime, <span class="hljs-number">1000</span>);</code></pre>
<p>Wieder erstellen wir ein <strong>React-Element</strong>, diesmal soll es uns beim Aufruf von <code>ReactDOM.render()</code> die aktuelle Zeit ausgeben. Da wir stets die genaue Uhrzeit wissen wollen, stecken wir das Element und den <code>ReactDOM.render()</code> Aufruf in eine Funktion, die per <code>setInterval</code> alle 1000 ms aufgerufen wird.</p>
<p>Ein Blick in die <strong>Chrome Devtools</strong> offenbart: bei jedem <code>ReactDOM.render()</code>-Aufruf wird stets nur die Uhrzeit selbst aktualisiert, die restlichen Elemente, wie die DOM-Nodes oder auch nicht betroffene Teil des angezeigten Textes bleiben unangetastet:</p>
<p class="has-image"><span><img src="../.gitbook/assets/react-update.png" alt="React aktualisiert nur die Zeit selbst, nichts anderes." /><span class="caption">React aktualisiert nur die Zeit selbst, nichts anderes.</span></span></p>
<p>Und hier lernen wir zugleich auch eins der grundlegenden React Prinzipien in der Praxis kennen: das <strong>deklarative</strong> Vorgehen zur Erstellung von User Interfaces. Statt unserer Mini-App <strong>imperativ</strong> zu sagen, dass sie bitte sekündlich die Uhrzeit aktualisieren soll, definieren wir stattdessen <strong>deklarativ</strong> im <strong>React-Element</strong>, dass wir an einer gewissen Stelle jeweils stets bei jedem Re-Rendering die aktuelle Uhrzeit sehen möchten.</p>
<p>Eine ähnliche Funktionalität ohne React implementiert hätte stattdessen wohl in etwa so ausgesehen:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeTime</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleTimeString();
  <span class="hljs-keyword">var</span> target = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>);
  target.textContent = <span class="hljs-string">'Es ist jetzt '</span> + time  <span class="hljs-string">' Uhr'</span>;
}
setInterval(changeTime, <span class="hljs-number">1000</span>);</code></pre>
<p>Der Vorteil beim deklarativen Vorgehen ist, dass wir nur noch <strong>Zustände beschreiben</strong> und sagen wie etwas angezeigt werden soll und nicht selber jeden Schritt festlegen wie wir diesen Zielzustand erreichen wollen. Das macht insbesondere bei komplexeren Anwendungen viele Dinge einfacher, übersichtlicher und ist dadurch zugleich deutlich weniger fehleranfälliger.</p>
<div class="hint hint--info">
<p>In der Praxis ist es eher üblich, dass <code>ReactDOM.render()</code> nur ein einziges Mal, meist beim Öffnen einer Seite aufgerufen wird. Der wiederholte Aufruf der <code>render()</code>-Methode dient hier nur zur Veranschaulichung wie <strong>ReactDOM</strong> und React <strong>Elemente</strong> zusammenspielen.</p>
<p>Das Re-Rendering übernehmen meist <strong>stateful Components</strong> (also Komponenten, die einen eigenen Zustand speichern). Mit Komponenten geht es im nächsten Kapitel weiter!</p>
</div>
</div><div class="chapter">
<h1 id="komponenten-in-react">Komponenten in React</h1>
<h2 id="die-zwei-erscheinungsformen-von-react-components">Die zwei Erscheinungsformen von React Components</h2>
<p>Eine erste einfache <strong>HelloWorld</strong>-Komponente haben wir schon beim <a href="../einfuehrung/ab-ins-kalte-wasser.md">Sprung ins kalte Wasser</a> implementiert. Jedoch war dies natürlich bewusst eine sehr simple Komponente, die nicht gerade sehr praxisnah war und auch längst nicht alles beinhaltet hat was uns React bietet. Aber sie diente als gute erste Veranschaulichung, um die grundsätzliche Funktionsweise von von <strong>React</strong> und <strong>React-Komponenten</strong> kennenzulernen.</p>
<p>Das Prinzip von <strong>Komponenten</strong> ist einfach erklärt: eine <strong>Komponente</strong> erlaubt es komplexe User Interfaces in einzelne kleine Stücke zu unterteilen. Diese sind im Idealfall wiederverwendbar, isoliert und in sich geschlossen. Sie verarbeiten beliebigen Input von außen in Form von sogenannter <strong>Props</strong> (engl. für „Properties“, also Eigenschaften) und beschreiben letztendlich anhand ihrer <code>render()</code>-Funktion was auf dem Bildschirm erscheint.</p>
<p>Komponenten können grob in zwei verschiedenen Varianten auftreten: in Form einer einfachen Funktion (engl. <strong>Function Component</strong>), sowie <strong>Class Components</strong>, die eine gewöhnliche ES2015-Klasse repräsentieren.<br />
Bis zur Einführung der React Hooks war es in Function Components nicht möglich einen lokalen State zu verwalten, weswegen man hin und wieder noch auf den Begriff <strong>Stateless Functional Component</strong> stößt.</p>
<h3 id="function-components">Function Components</h3>
<p>Die deutlich einfachste Art um in React eine Komponente zu definieren ist sicherlich die funktionale Komponente, die, wie der Name es bereits andeutet, tatsächlich lediglich eine einfache JavaScript-Funktion ist:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Hello</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello {props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}</code></pre>
<p>Diese Funktion erfüllt alle Kriterien einer gültigen <strong>React-Komponente</strong>: sie hat als <code>return</code>-Wert ein explizites <code>null</code> (<code>undefined</code> ist dagegen <strong>nicht</strong> gültig!) oder ein gültiges <code>React.Element</code> (hier in Form von <strong>JSX</strong>) und sie empfängt ein <code>props</code>-Objekt als erstes und Funktionsargument, wobei sogar dieses optional ist und ebenfalls <code>null</code> sein kann.</p>
<h3 id="class-components">Class Components</h3>
<p>Die zweite Möglichkeit wie eine <strong>React-Komponente</strong> erstellt werden kann habe ich im Eingangsbeispiel schon kurz gezeigt: <strong>Class Components</strong>. Diese bestehen aus einer ES2015-Klasse, die von der <code>React.Component</code> oder <code>React.PureComponent</code>(dazu später mehr) Klasse ableitet und hat mindestens eine Methode mit dem Namen <code>render()</code>:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello {this.props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
  }
}</code></pre>
<p>Wichtiger Unterschied hier: während eine <strong>Function Component</strong> ihre <strong>Props</strong> als Funktionsargumente übergeben bekommt, bekommt die <code>render()</code>-Methode einer <strong>Klassen-Komponente</strong> selbst keinerlei Argumente übergeben, sondern es kann einzig über die Instanz-Eigenschaft <code>this.props</code> auf die <strong>Props</strong> zugegriffen!</p>
<p>Die beiden obigen Komponenten resultieren hier in einer komplett identischen Ausgabe!</p>
<div class="hint hint--info">
<p>Ein Kriterium das beide Arten von Komponenten gemeinsam haben ist, dass der <code>displayName</code>, also der Name einer gültigen Komponente stets mit einem <strong>Großbuchstaben</strong> anfängt. Der Rest des Namens kann aus Großbuchstaben oder Kleinbuchstaben bestehen, wichtig ist lediglich, dass der erste Buchstabe stets ein Großbuchstabe ist!</p>
<p>Beginnt der Name einer Komponente mit einem Kleinbuchstaben, behandelt React diese stattdessen als reines DOM-Element. <code>section</code> würde React also als DOM-Element interpretieren, während eine eigene Komponente durchaus den Namen <code>Section</code> haben kann und wegen ihres Großbuchstabens am Anfang von React korrekt vom <code>section</code> DOM-Element unterschieden werden würde.</p>
</div>
<p>Wie wir innerhalb der <strong>Komponenten</strong> jeweils mit dem <strong>State</strong> arbeiten, diesen modifizieren und uns zu eigen machen ist sehr komplex, weswegen dem Thema ein eigenes Kapitel gewidmet ist. Dieses folgt direkt im Anschluss an dieses hier und ich würde empfehlen erst dieses Kapitel zu beenden um die Funktionsweise von Komponenten zu verstehen, bevor wir hier tiefer einsteigen.</p>
<h2 id="component-composition-–-mehrere-komponenten-in-einer">Component Composition – mehrere Komponenten in einer</h2>
<p>Bisher haben unsere Beispiel-Komponenten jeweils nur DOM-Elemente ausgegeben. <strong>React-Komponenten</strong> können aber auch andere React-Komponenten beinhalten. Wichtig hierbei ist nur, dass die Komponente sich im selben Scope befindet, also entweder direkt im gleichen Scope definiert wurde oder bei der Verwendung von CommonJS- oder ES-Modules ins aktuelle File importiert wurden mittels <code>require()</code> oder <code>import</code>.</p>
<p><strong>Ein Beispiel:</strong></p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Hello</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hallo {props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyApp</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;Hello name="Manuel" /&gt;
      &lt;Hello name="Tom" /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(&lt;MyApp /&gt;, document.getElementById('app'));</code></pre>
<p>Die Komponente <code>&lt;MyApp&gt;</code> gibt hier ein <code>&lt;div&gt;</code> zurück, das zweimal die Hello-Komponente aus dem vorherigen Beispiel benutzt um Manuel und Tom zu begrüßen. Das Resultat:</p>
<pre><code class="hljs jsx language-jsx">&lt;div&gt;
  &lt;div&gt;Hallo Manuel&lt;/div&gt;
  &lt;div&gt;Hallo Tom&lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>Wichtig: eine Komponente darf stets nur ein einzelnes Root-Element zurückgeben! Dies kann sein:</p>
<ul>
<li>ein einzelnes React-Element: <code>&lt;Hello name="Manuel" /&gt;</code></li>
<li>Auch in verschachtelter Form, solange es nur ein einzelnes Element auf äußerer Ebene gibt: <code>&lt;Parent&gt;&lt;Child /&gt;&lt;/Parent&gt;</code></li>
<li>ein DOM-Element (auch dieses darf wiederum verschachtelt sein und andere Elemente beinhalten): <code>&lt;div&gt;…&lt;/div&gt;</code></li>
<li>Oder selbstschließend: <code>&lt;img src="logo.jpg" alt="Bild: Logo" /&gt;</code></li>
<li><code>null</code> (aber niemals <code>undefined</code>!)</li>
</ul>
<p>Seit React 16 dürfen das außerdem auch sein:</p>
<ul>
<li>ein Array welches wiederum gültige return-Werte (s.o.) beinhaltet: <code>[&lt;div key="1"&gt;Hallo&lt;/div&gt;, &lt;Hello key="2" name="Manuel" /&gt;]</code></li>
<li>ein String: <code>'Hallo Welt'</code></li>
<li>Ein sogenanntes „Fragment“ – eine Art spezielle „Komponente“, das selbst nicht im gerenderten Output auftaucht und als Container dienen kann, falls man andererseits gegen die Regel verstoßen würde nur ein Root-Element aus der Funktion zurückzugeben oder invalides HTML erzeugen würde: <code>&lt;React.Fragment&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&lt;/React.Fragment&gt;</code></li>
</ul>
<p>Komponenten können dabei beliebig zusammengesetzt (<em>„composed“</em>) werden. So bietet es sich oftmals an große und komplexe Komponenten in einzelne, kleinere und übersichtlichere Komponenten zu unterteilen um diese leichter verständlich und optimalerweise sogar auch wiederverwendbar zu machen. Dies ist oftmals ein lebender Prozess bei dem man ab einem gewissen Punkt bemerkt, dass eine Unterteilung in mehrere einzelne Komponenten möglicherweise sinnvoll wäre.</p>
<h2 id="komponenten-aufteilen-–-übersicht-bewahren">Komponenten aufteilen – Übersicht bewahren</h2>
<p>Werfen wir doch mal einen Blick auf eine beispielhafte Kopfleiste, die ein Logo, eine Navigation und eine Suchleiste enthält. Kein ganz unübliches Muster also schaut man sich Web-Anwendungen an:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Header</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    &lt;header&gt;
      &lt;div className="logo"&gt;
        &lt;img src="logo.jpg" alt="Image: Logo" /&gt;
      &lt;/div&gt;
      &lt;ul className="navigation"&gt;
        &lt;li&gt;
          &lt;a href="/"&gt;Homepage&lt;/a&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;a href="/team"&gt;Team&lt;/a&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;a href="/services"&gt;Services&lt;/a&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;a href="/contact"&gt;Contact&lt;/a&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;div className="searchbar"&gt;
        &lt;form method="post" action="/search"&gt;
          &lt;p&gt;
            &lt;label htmlFor="q"&gt;Suche:&lt;/label&gt;
            &lt;input type="text" id="q" name="q" /&gt;
          &lt;/p&gt;
          &lt;input type="submit" value="Suchen" /&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    &lt;/header&gt;
  );
}</code></pre>
<p>Wir wissen bereits, dass Komponenten in React problemlos auch andere Komponenten beinhalten können und das diese Komponenten-basierte Arbeitsweise auch der Idee und dem Mindset von React entspricht. Was bietet sich hier also an? Richtig: wir teilen unsere doch bereits relativ große, unübersichtliche Komponente in mehrere kleinere Häppchen auf, die jeweils alle nur einen einzigen, ganz bestimmten Zweck erfüllen.</p>
<p>Da wäre das Logo, das wir sicherlich an anderer Stelle nochmal verwenden können. Die Navigation kann möglicherweise neben dem Header auch nochmal in einer Sitemap eingesetzt werden. Auch die Suchleiste soll vielleicht irgendwann mal nicht mehr nur im Header zum Einsatz kommen, sondern vielleicht auch auf der Suchergebnisseite selbst.</p>
<p>In Komponenten gesprochen, landen wir dann bei folgendem Endresultat:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Logo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    &lt;div className="logo"&gt;
      &lt;img src="logo.jpg" alt="Image: Logo" /&gt;
    &lt;/div&gt;
  );
}

function Navigation() {
  return (
    &lt;ul className="navigation"&gt;
      &lt;li&gt;
        &lt;a href="/"&gt;Homepage&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href="/team"&gt;Team&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href="/services"&gt;Services&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href="/contact"&gt;Contact&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  );
}

function Searchbar() {
  return (
    &lt;div className="searchbar"&gt;
      &lt;form method="post" action="/search"&gt;
        &lt;p&gt;
          &lt;label htmlFor="q"&gt;Suche:&lt;/label&gt;
          &lt;input type="text" id="q" name="q" /&gt;
        &lt;/p&gt;
        &lt;input type="submit" value="Suchen" /&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}

function Header() {
  return (
    &lt;header&gt;
      &lt;Logo /&gt;
      &lt;Navigation /&gt;
      &lt;Searchbar /&gt;
    &lt;/header&gt;
  );
}</code></pre>
<p>Auch wenn der Code jetzt erstmal länger geworden ist haben wir uns dadurch dennoch einige große Vorteile geschaffen.</p>
<h3 id="leichtere-kollaboration">Leichtere Kollaboration</h3>
<p>Alle Komponenten können (und sollten!) in einem eigenen File gespeichert werden, was die Arbeit im Team immens erleichtert. So könnte jedes Team-Mitglied oder auch einzelne Teams innerhalb eines großen Projekt-Teams für eine oder mehrere Komponenten hauptverantwortlich sein („Ownership übernehmen“) und Änderungen in diesen vornehmen, während das Risiko die Änderungen eines Kollegen zu überschreiben oder später Git Merge-Konflikte auflösen zu müssen immens sinkt. Teams werden zu <em>Konsumenten</em> von Komponenten anderer Teams, die anhand eventuell verfügbarer Props ein simples Interface für ihre Komponente bereitstellen.</p>
<h3 id="single-responsibility-prinzip">Single Responsibility Prinzip</h3>
<p>Wir haben nun außerdem „sprechende“ Komponenten, von denen jede eine klar definierte Aufgabe hat, die direkt anhand ihres Namens ersichtlich wird. Das Logo zeigt mir überall wo es verwendet wird dasselbe Logo an. Möchte ich später eine Änderung an der Suchleiste vornehmen, suche ich gezielt nach der Searchbar.js und ändere diese entsprechend meinen neuen Anforderungen. Die Header-Komponente dient als übergeordnete Komponente die selbst dafür verantwortlich ist, alle ihre Bestandteile zu beinhalten und diese überall hin mitzubringen, wo sie eingesetzt wird.</p>
<h3 id="wiederverwendbarkeit">Wiederverwendbarkeit</h3>
<p>Und nicht zuletzt haben wir ganz nebenbei noch Wiederverwendbarkeit geschaffen. Möchte ich wie erwähnt das Logo nicht nur im Header sondern auch im Footer verwenden hält mich natürlich nichts davon ab, dieselbe Komponente auch in meiner Footer-Komponente zu verwenden. Habe ich verschiedene Seitenbereiche mit unterschiedlichen Layouts, die jedoch alle denselben Header darstellen, kann ich dazu meine schlanke und übersichtliche Header-Komponente überall dort verwenden, wo ich ich ihn benötige. Der Konsument einer Komponente muss dazu nicht einmal wissen aus welchen einzelnen Komponenten sie besteht. Es reicht, lediglich die gewünschte Komponente zu importieren da diese sich selbst um ihre Abhängigkeiten kümmert.</p>
<h2 id="props-–-die-„datenempfänger“-einer-komponente">Props – die „Datenempfänger“ einer Komponente</h2>
<p>Nun habe ich bereits soviel über <strong>Props</strong> geschrieben. Höchste Zeit also einmal das Geheimnis zu lüften und genauer darauf einzugehen. Was sind also „Props“?</p>
<p>Durch die <strong>Props</strong> nehmen Komponenten beliebige Arten von Daten entgegen und können innerhalb der <strong>Komponente</strong> auf diese Daten zugreifen. Denken wir an unsere <strong>funktionale Komponente</strong> zurück, erinnern wir uns vielleicht, dass in diesem Fall die <strong>Props</strong> tatsächlich als ganz gewöhnliches Argument an die Funktion übergeben wurden. Ähnlich ist das Prinzip bei einer <strong>Class Component</strong>, mit dem Unterschied, dass die <strong>Props</strong> über den Constructor der Klasse in die Komponente hereingereicht werden und über <code>this.props</code> innerhalb der Klassen-Instanz verfügbar sind, statt über ein Funktionsargument, wie das bei funktionalen Komponenten der Fall ist.</p>
<p>Wichtig dabei ist: wann immer eine Komponente von außen neue <strong>Props</strong> hereingereicht bekommt, löst dies ein Re-Rendering der Komponente aus! Dieses Verhalten kann mittels der <code>shouldComponentUpdate()</code> <strong>Lifecycle-Methode</strong> explizit unterbunden werden, doch dazu gibt es im nachfolgenden Kapitel mehr. Wichtig ist erst einmal der allgemeine Grundsatz: empfängt eine <strong>Komponente</strong> von außen neue <strong>Props</strong>, veranlasst dies React dazu eine <strong>Komponente</strong> mitsamt ihrer Kind-Komponenten neu zu rendern.</p>
<h3 id="props-sind-readonly-innerhalb-einer-komponente">Props sind readonly innerhalb einer Komponente</h3>
<p>Unabhängig davon wie die Props in welcher Art von Komponente auch immer landen, eines ist ihnen gemeinsam: sie sind innerhalb der Komponente <strong>immer readonly</strong>, dürfen (und können) also nur gelesen, nicht aber modifiziert werden! Der Profi spricht hier auch von <strong>Immutability</strong> oder <strong>Immutable Objects</strong>. Um mit veränderlichen Daten zu arbeiten kommt später der React <strong>State</strong> ins Spiel. Aber eins nach dem anderen.</p>
<p>Modifiziert eine Funktion ihren Input nicht und hat auch keine Abhängigkeit nach außen, so spricht man in der funktionalen Programmierung von einer puren Funktion (engl.: <strong>Pure Function</strong>) und die Idee dahinter ist recht simpel: so soll sichergestellt werden, dass eine Funktion in sich geschlossen ist, daher davon unbeeindruckt bleibt wenn sich außerhalb der Funktion etwas ändert, die Funktion bekommt alle benötigten Parameter hereingereicht, ist frei von Seiteneffekten (engl.: <strong>Side Effects</strong>) und erzielt somit bei gleichen Eingabewerten auch immer die exakt identische Ausgabe. <strong>Gleicher Input, gleicher Output!</strong></p>
<p>Mit anderen Worten: egal welche Variablen außerhalb der Funktion ihren Wert ändern, egal wie oft andere Funktionen anderswo aufgerufen werden: bekommt eine Pure Function die gleichen Parameter wie zuvor, gibt sie mir auch das gleiche Ergebnis wie zuvor zurück. Immer und ausnahmslos.</p>
<p>Warum ist das wichtig? Nun, React verfolgt bei seinen Komponenten das Prinzip von <strong>Pure Functions</strong>. Erhält eine Komponente die gleichen Props von außen hineingereicht, ist der initiale Output auch immer identisch.</p>
<h3 id="pure-functions-im-detail">Pure Functions im Detail</h3>
<p>Da das Prinzip von <strong>Pure Functions</strong> ein grundlegendes ist bei der Arbeit mit React möchte ich diese Anhand einiger Beispiele etwas näher beleuchten. Hier geht es überwiegend um Theorie, die sich sicherlich komplizierter anhört als das später bei der praktischen Arbeit mit React der Fall sein wird. Dennoch möchte ich diese zum besseren Verständnis nicht unerwähnt lassen.</p>
<h4 id="beispiel-für-eine-simple-pure-function">Beispiel für eine simple Pure Function</h4>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pureDouble</span>(<span class="hljs-params">number</span>) </span>{
  <span class="hljs-keyword">return</span> number * <span class="hljs-number">2</span>;
}</code></pre>
<p>Unsere erste simple Funktion bekommt eine Nummer übergeben, verdoppelt diese und gibt das Ergebnis zurück. Egal ob ich die Funktion 1, 10 oder 250 mal aufrufe: übergebe ich der Funktion bspw. eine <code>5</code> als Wert, erhalte ich eine <code>10</code> zurück. Immer und ausnahmslos. Same input, same output.</p>
<h4 id="beispiel-für-eine-impure-function">Beispiel für eine Impure Function</h4>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">impureCalculation</span>(<span class="hljs-params">number</span>) </span>{
  <span class="hljs-keyword">return</span> number + <span class="hljs-built_in">window</span>.outerWidth;
}</code></pre>
<p>Die zweite Funktion ist nicht mehr pure, weil sie nicht zuverlässig immer den gleichen Output liefert, selbst wenn ihr Input identisch ist. Momentan ist mein Browser-Fenster 1920 Pixel breit. Rufe ich die Funktion mit <code>10</code> als Argument auf, erhalte ich <code>1930</code> zurück (<code>10 + 1920</code>). Verkleinere ich nun das Fenster auf 1280 Pixel und rufe die Funktion erneut, mit exakt der gleichen <code>10</code> als Argument auf bekomme ich dennoch ein anderes Ergebnis (<code>1290</code>) als beim ersten Mal. Es handelt sich also nicht um eine Pure Function.</p>
<p>Eine Möglichkeit diese Funktion „pure“ zu machen wäre, ihr meine Fensterbreite als weiteres Funktionsargument zu übergeben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pureCalculation</span>(<span class="hljs-params">number, outerWidth</span>) </span>{
  <span class="hljs-keyword">return</span> number + outerWidth;
}</code></pre>
<p>So liefert die Funktion beim Aufruf von pureCalculation(10, window.outerWidth) zwar immer noch ein Ergebnis was von meiner Fensterbreite abhängt, die Funktion ist dennoch „pure“ da sie beim gleichen Input weiterhin den gleichen Output liefert. Einfacher kann man das nachvollziehen wenn man die Funktion mal auf ihre wesentlichen Eigenschaften reduziert:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pureSum</span>(<span class="hljs-params">number1, number2</span>) </span>{
  <span class="hljs-keyword">return</span> number1 + number2;
}</code></pre>
<p><strong>Gleicher Input, Gleicher Output.</strong></p>
<h4 id="weiteres-beispiel-für-eine-impure-function">Weiteres Beispiel für eine Impure Function</h4>
<p>Stellen wir uns einmal vor wir möchten eine Funktion implementieren die als Input ein Objekt empfängt mit Parametern zu einem Auto.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">var</span> car = { <span class="hljs-attr">speed</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">seats</span>: <span class="hljs-number">5</span> };
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accelerate</span>(<span class="hljs-params">car</span>) </span>{
  car.speed += <span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> car;
}</code></pre>
<p>Das obige Beispiel ist ebenfalls eine Funktion die nicht „pure“ ist, da sie ihren Eingabewert modifiziert und somit beim zweiten Aufruf bereits ein anderes Ergebnis als Ausgabewert hat als noch beim ersten Aufruf:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-built_in">console</span>.log(accelerate(car)) &gt; { <span class="hljs-attr">speed</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">seats</span>: <span class="hljs-number">5</span> };

<span class="hljs-built_in">console</span>.log(accelerate(car)) &gt; { <span class="hljs-attr">speed</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">seats</span>: <span class="hljs-number">5</span> };</code></pre>
<p>Wie sorgen wir also nun dafür, dass auch unser letztes Beispiel „pure“ wird? Indem wir den Eingabewert nicht mehr modifizieren und stattdessen jedes Mal ein neues Objekt erzeugen, basierend auf dem Eingabewert, und dieses neue Objekt aus der Funktion zurückgebend,</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">var</span> car = { <span class="hljs-attr">speed</span>: <span class="hljs-number">0</span> };
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accelerate</span>(<span class="hljs-params">car</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">speed</span>: car.speed + <span class="hljs-number">1</span>,
  };
}</code></pre>
<p>Neues Ergebnis:</p>
<pre><code class="hljs text language-text"><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">accelerate</span>(<span class="hljs-selector-tag">car</span>))
&gt; {<span class="hljs-attribute">speed</span>: <span class="hljs-number">1</span>}

<span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">accelerate</span>(<span class="hljs-selector-tag">car</span>))
&gt; {<span class="hljs-attribute">speed</span>: <span class="hljs-number">1</span>}</code></pre>
<p><strong>Gleicher Input: gleicher Output:</strong> wir sind „pure“!</p>
<p>Ihr wundert euch jetzt vielleicht warum ich euch das erzähle und hier mit langweiliger Theorie nerve, wo ihr doch eigentlich nur React lernen wollt (jedenfalls würde ich mir das an dieser Stelle denken, wenn ich mir vorstelle dieses Buch auch aus diesem Grund zu lesen).</p>
<p>React ist eine sehr liberale Library, die dem Entwickler sehr viele Freiheiten lässt. Aber eine Sache ist oberstes Gebot und da kennt React auch wirklich keinen Spaß: <strong>Komponenten müssen sich im Hinblick auf ihre Props wie „Pure Functions“ verhalten und bei gleichen Props stets die gleiche Ausgabe erzeugen!</strong></p>
<p>Haltet ihr euch da nicht dran, kann es bei der Arbeit mit React zu sehr eigenartigen Effekten kommen, zu unerwünschten und nicht nachvollziehbaren Ergebnissen führen und euch das Leben beim Bugfixing zur Hölle machen. Und genau aus diesem Grund lernt ihr ja React: weil ihr ein einfaches aber dennoch zugleich unglaublich mächtiges Tool haben wollt, mit denen ihr nach etwas Einarbeitung in unglaublich schneller Zeit wirklich professionelle User Interfaces entwickeln könnt, ohne euch dabei selbst in den Wahnsinn zu treiben. All das bietet euch React, solange ihr euch an diese Regel haltet.</p>
<p>Das hat für uns aber gleichzeitig den sehr angenehmen Nebeneffekt, dass sich Komponenten in der Regel auch sehr einfach testen lassen.</p>
<p>So und was bedeutet jetzt genau das <em>„readonly innerhalb einer Komponente“</em>? Das ist mit unserem neuen Wissen über „Pure Functions“ recht schnell erklärt: egal wie ich in der Komponente auf die Props zugreife, ob direkt über das <code>props</code>-Argument einer SFC (<em>„Stateless Functional Component“</em>), über den <code>constructor()</code> in einer Class-Component oder an beliebiger anderer Stelle innerhalb einer Class-Component mittels <code>this.props</code>: ich kann und darf (und will!) den Wert der hereingereichten Props nicht ändern.</p>
<p>Anders sieht das natürlich <strong>außerhalb</strong> aus. Hier kann ich den Wert problemlos ändern (vorausgesetzt natürlich, wir befinden uns nicht wiederum in einer Komponente, welche die Prop die wir modifizieren wollen selbst nur hereingereicht bekommen hat).</p>
<h4 id="was-nicht-möglich-ist">Was nicht möglich ist</h4>
<pre><code class="hljs jsx language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params">props</span>) </span>{
  props.number = props.number + <span class="hljs-number">1</span>;
  props.fullName = [props.firstName, props.lastName].join(<span class="hljs-string">' '</span>);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      ({props.number}) {props.fullName}{' '}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Example</span> <span class="hljs-attr">number</span>=<span class="hljs-string">{5}</span> <span class="hljs-attr">firstName</span>=<span class="hljs-string">"Manuel"</span> <span class="hljs-attr">lastName</span>=<span class="hljs-string">"Bieh"</span> /&gt;</span>,
  document.getElementById('app')
);</span></code></pre>
<p><strong>Ausgabe:</strong></p>
<div class="hint hint--danger">
<p>TypeError: Cannot add property number, object is not extensible</p>
</div>
<p>Hier versuche ich direkt die <code>number</code> und <code>fullName</code> Props innerhalb meiner Example-Komponente zu ändern, was natürlich nicht funktionieren kann, da wir ja gelernt haben, dass Props grundsätzlich readonly sind.</p>
<h4 id="was-allerdings-möglich-ist">Was allerdings möglich ist</h4>
<p>Manchmal möchte ich aber eben doch einen neuen Wert von einer hereingereichten Prop ableiten. Das ist auch gar kein Problem, React 17 bietet dafür sogar noch eine umfassende Funktion <code>getDerivedStateFromProps()</code>, auf die ich im entsprechenden Kapital nochmal gesondert und sehr detailliert eingehen werde.</p>
<p>Möchte ich aber eben nur mal eben einen Wert anzeigen der sich von der Prop ableitet, die ich als Komponente hereingereicht bekomme, geht das indem nur die Ausgabe auf Basis der Prop anpasse ohne zu probieren den Wert zurück zu schreiben.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">var</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react'</span>);
<span class="hljs-keyword">var</span> ReactDOM = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-dom'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      ({props.number + 1}) {[props.firstName, props.lastName].join(' ')}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Example</span> <span class="hljs-attr">number</span>=<span class="hljs-string">{5}</span> <span class="hljs-attr">firstName</span>=<span class="hljs-string">"Manuel"</span> <span class="hljs-attr">lastName</span>=<span class="hljs-string">"Bieh"</span> /&gt;</span>,
  document.getElementById('app')
);</span></code></pre>
<p><strong>Ausgabe:</strong></p>
<pre><code class="hljs jsx language-jsx">&lt;div&gt;(<span class="hljs-number">6</span>) Manuel Bieh&lt;<span class="hljs-regexp">/div&gt;</span></code></pre>
<p>In diesem Fall modifiziere ich also lediglich die Ausgabe basierend auf den <code>props</code>, nicht jedoch das <code>props</code>-Objekt selbst. Das ist überhaupt kein Problem.</p>
<h4 id="was-ebenfalls-möglich-ist">Was ebenfalls möglich ist</h4>
<p>Jetzt bleibt noch abschließend zu klären wie Props denn nun außerhalb einer Komponente geändert werden können, denn bisher war immer nur die Rede davon, dass Props nur innerhalb einer Komponente nicht verändert werden dürfen.</p>
<p>Auch das lässt sich am Besten anhand eines konkreten, allerdings noch recht abstrakten Beispiels erklären:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">var</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react'</span>);
<span class="hljs-keyword">var</span> ReactDOM = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-dom'</span>);

<span class="hljs-keyword">var</span> renderCounter = <span class="hljs-number">0</span>;
setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  renderCounter++;
  renderApp();
}, <span class="hljs-number">2000</span>);

<span class="hljs-keyword">const</span> App = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{props.renderCounter}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderApp</span>(<span class="hljs-params"></span>) </span>{
  ReactDOM.render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> <span class="hljs-attr">renderCounter</span>=<span class="hljs-string">{renderCounter}</span> /&gt;</span>,
    document.getElementById('app')
  );
}

renderApp();</span></code></pre>
<p>Was passiert hier? Zunächst einmal setzen wir eine Variable <code>renderCounter</code> auf den Anfangswert <code>0</code>. Diese Variable zählt für uns gleich mit wie oft wir unsere <code>App</code>-Komponente rendern oder genauer gesagt, wie oft wir im Endeffekt die <code>ReactDOM.render()</code> Funktion aufrufen, die dann entsprechend bei jedem Aufruf dafür sorgt, dass die <code>App</code>-Komponente erneut gerendert wird.</p>
<p>Anschließend starten wir einen Intervall, der die besagte Funktion regelmäßig alle 2000 Millisekunden ausführt. Dabei führt der Intervall nicht nur im 2 Sekunden-Takt die Funktion aus, sondern zählt auch gleichzeitig unsere <code>renderCounter</code> Variable um 1 hoch. Was hier jetzt passiert ist ganz spannend: wir modifizieren die <code>renderCounter</code> Prop unserer App <strong>„von außen“</strong>.</p>
<p>Die Komponente selbst bleibt dabei komplett „pure“. Wird sie aufgerufen mit:</p>
<pre><code class="hljs jsx language-jsx">&lt;App renderCounter={<span class="hljs-number">5</span>} /&gt;</code></pre>
<p>gibt sie uns als Ergebnis zurück:</p>
<pre><code class="hljs markup language-markup">&lt;<span class="hljs-keyword">div</span>&gt;<span class="hljs-number">5</span>&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre>
<p>Und zwar egal wie oft die Komponente inzwischen tatsächlich gerendert wurde. Gleicher Input, gleicher Output.</p>
<p>Innerhalb unserer Komponente sind und bleiben wir weiterhin „pure“. Wir modifizieren den Eingabewert nicht und wir haben in der Komponente auch keinerlei direkten Abhängigkeiten nach außen, die unser Render-Ergebnis beeinflussen könnten. Der Wert wird lediglich außerhalb unserer Komponente geändert und neu in die Komponente <strong>hereingegeben</strong>, was uns aber an dieser Stelle auch gar nicht weiter interessieren braucht, da es für uns lediglich wichtig ist, dass unsere Komponente mit gleichen Props auch weiterhin das gleiche Ergebnis liefert. Und das ist hier zweifellos gegeben. Wer die Props außerhalb unserer Komponente modifiziert, wie oft und in welcher Form ist uns ganz gleich, solange wir das nicht selber innerhalb unserer Komponente tun. Okay, Prinzip verstanden?</p>
<h4 id="props-sind-ein-abstrahiertes-funktionsargument">Props sind ein abstrahiertes Funktionsargument</h4>
<p>Da Props, reduziert man sie auf das Wesentliche, nichts anderes als ein Funktionsargument sind, können sie auch in dessen diversen Formen auftreten. Alles, was auch Functions oder Constructors in JavaScript als Argument akzeptieren, kann auch als Wert für eine Prop verwendet werden. Vom simplen String, über Objekte, Funktionen oder gar andere React-Elemente (die ja, wie wir bereits wissen, hinter den Kulissen auch nichts anderes als ein Funktionsaufruf sind) kann das nahezu alles sein, solange es eben ein valider Ausdruck ist.</p>
<pre><code class="hljs jsx language-jsx">&lt;MyComponent
  counter={<span class="hljs-number">3</span>}
  text=<span class="hljs-string">"example"</span>
  showStatus={<span class="hljs-literal">true</span>}
  config={{ <span class="hljs-attr">uppercase</span>: <span class="hljs-literal">true</span> }}
  biggerNumber={<span class="hljs-built_in">Math</span>.max(<span class="hljs-number">27</span>, <span class="hljs-number">35</span>)}
  arbitraryNumbers={[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">28</span>, <span class="hljs-number">347</span>, <span class="hljs-number">1538</span>]}
  dateObject={<span class="hljs-built_in">Date</span>}
  dateInstance={<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()}
  icon={
    &lt;svg x=<span class="hljs-string">"0px"</span> y=<span class="hljs-string">"0px"</span> width=<span class="hljs-string">"32px"</span> height=<span class="hljs-string">"32px"</span>&gt;
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"#CC3300"</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"16"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"16"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"16"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></span>
  }
  callMe={() =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Somebody called me'</span>);
  }}
/&gt;</code></pre>
<p>Auch wenn die meisten Props hier inhaltlich wenig Sinn ergeben und nur zur Veranschaulichung dienen, so sind sie dennoch syntaktisch korrektes JSX, demonstrieren wie mächtig sie sind und in welchen verschiedenen Formen sie auftreten können.</p>
<h3 id="props-sind-nicht-auf-eine-verschachtelungsebene-beschränkt">Props sind nicht auf eine Verschachtelungsebene beschränkt</h3>
<p>Eine Komponente die Props empfängt kann diese problemlos auch an Kind-Komponenten weiterreichen. Dies kann einerseits hilfreich sein wenn man große Komponenten in mehrere kleinere Komponenten unterteilt und gewisse Props an Kind-Komponenten weitergegeben werden müssen, kann aber bei komplexen Anwendungen teilweise dazu führen dass es schwer erkenntlich wird wo der genaue Ursprung einer Prop ist und wo ich anfangen muss zu suchen, wenn ich den Wert einer Prop ändern möchte.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;h1&gt;{props.name}&lt;/h1&gt;
      &lt;UserImage image={props.image} /&gt;
      &lt;ListOfPosts items={props.posts} /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(
  &lt;User name={user.name} image={user.image} posts={user.posts} /&gt;,
  document.getElementById('app')
);</code></pre>
<h3 id="die-wichtigsten-punkte-im-überblick">Die wichtigsten Punkte im Überblick</h3>
<div class="hint hint--success">
<p>Komponenten müssen sich hinsichtlich ihrer Props als „Pure Functions“ verhalten und bei gleichen Props stets die gleiche Ausgabe erzeugen.</p>
<ul>
<li>Props sind innerhalb einer Komponente grundsätzlich als <strong>readonly</strong> zu betrachten</li>
<li>Komponenten können eine <strong>beliebige Menge an Props</strong> übergeben bekommen.</li>
<li>In JSX übergibt man Props in ähnlicher Form wie in HTML Attribute</li>
<li>Anders als in HTML, sind in JSX diverse Arten von Werten erlaubt. Werte die nicht vom Typ String sind, werden dabei in <strong>geschweifte Klammern</strong> gefasst</li>
<li>Props können <strong>sämtliche JavaScript-Ausdrücke</strong> („Expressions“) als Wert entgegennehmen</li>
<li>Empfangene Props können beliebig viele Ebenen tief im Komponenten-Baum an Kind-Elemente weitergegeben werden</li>
</ul>
</div>
</div><div class="chapter">
<h1 id="state-und-lifecycle-methods">State und Lifecycle-Methods</h1>
<p>Kommen wir zu dem, was die Arbeit mit React erstmal wirklich effizient macht: <strong>State</strong>, <strong>stateful Components</strong> und die sogenannten <strong>Lifecycle-Methods</strong>.</p>
<p>Wie im Kapitel über Komponenten bereits angesprochen können <strong>stateful Components</strong> einen eigenen Zustand, den <strong>State</strong>, halten, verwalten und verändern. Dabei gilt der Grundsatz: <strong>ändert sich der State einer Komponente, löst dies immer auch ein Re-Rendering der Komponente aus!</strong> Dieses Verhalten kann in <strong>Class Components</strong> auch explizit unterbunden werden, was in einigen Fällen sinnvoll ist. Aber der Grundsatz bleibt unverändert: eine State-Änderung löst ein Re-Rendering einer Komponente und ihrer Kind-Komponenten aus.</p>
<p>Das ist insofern hilfreich, als dass wir nicht mehr manuell <code>ReactDOM.render()</code> aufrufen müssen wann immer wir meinen dass sich etwas an unserem Interface geändert hat, sondern die Komponenten dies stattdessen selbst entscheiden können.</p>
<p>Neben dem State an sich gibt es auch eine handvoll sogenannter <strong>Lifecycle-Methoden</strong>. Dies sind Methoden die <strong>optional</strong> in einer <strong>Class Component</strong> definiert werden können und von React bei bestimmten Anlässen aufgerufen werden. Beispielsweise wenn eine Komponente erstmals gemountet wird, die Komponente neue Props empfangen oder sich der State innerhalb der Komponente geändert hat.</p>
<h2 id="eine-erste-stateful-component">Eine erste stateful Component</h2>
<p>Der <strong>State</strong> innerhalb einer Komponente ist verfügbar über die Instanz-Eigenschaft <code>this.state</code> und ist somit innerhalb einer <strong>Komponente</strong> gekapselt. Weder Eltern- noch Kind-Komponenten können ohne weiteres auf den State einer anderen Komponente zugreifen.</p>
<p>Um in einer Komponente einen initialen Zustand zu definieren gibt es zwei einfache Wege, einen dritten, von der Funktionalität her etwas erweiterten Weg lernen wir später noch mit der <strong>Lifecycle-Methode</strong> <code>getDerivedStateFromProps()</code> kennen.</p>
<p><strong>Initialen State</strong> kann man definieren, indem man im Constructor die Instanz-Eigenschaft <code>this.state</code> setzt:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">this</span>.state = {
      <span class="hljs-attr">counter</span>: props.counter,
    };
  }
}</code></pre>
<p>… oder indem man den State als <strong>ES2017</strong> <strong>Class Property</strong> definiert, was deutlich kürzer ist, jedoch momentan noch das <strong>Babel-Plugin</strong> <code>@babel/plugin-proposal-class-properties</code> (vor Babel 7: <code>babel-plugin-transform-class-properties</code>) benötigt:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">counter</span>: <span class="hljs-keyword">this</span>.props.counter,
  };
}</code></pre>
<p><strong>Create-React-App</strong> unterstützt die <strong>Class Property Syntax</strong> standardmäßig und da viele React-Projekte heute vollständig oder zumindest zu gewissen Teilen auf dem CRA-Setup oder Varianten davon basieren, kommt diese Syntax heute in den meisten Projekten zum Einsatz und kann genutzt werden. Sollte dies mal in einem Projekt nicht der Fall zu sein, empfehle ich dringend die Installation und Nutzung des Babel-Plugins, da es wirklich viele unnötige Zeilen Code bei der täglichen Arbeit mit React einspart, während es gleichzeitig in nur wenigen Minuten eingerichtet ist.</p>
<p>Ist der <strong>State</strong> erst einmal definiert, können wir innerhalb der <strong>Class Component</strong> mittels <code>this.state</code> <strong>lesend</strong> auf ihn zugreifen. <strong>Lesend</strong> ist hier ein entscheidendes Stichwort. Denn auch wenn es prinzipiell möglich ist den State direkt über <code>this.state</code> zu verändern sollte dies aus verschiedenen Gründen vermieden werden.</p>
<h2 id="den-state-verändern-mit-thissetstate">Den State verändern mit this.setState()</h2>
<p>Um State zu verändern stellt React eine eigene Methode innerhalb einer <strong>Class Component</strong> bereit:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">this</span>.setState(updatedState);</code></pre>
<p>Wann immer der State innerhalb einer Komponente verändert werden soll, sollte dafür <code>this.setState()</code> verwendet werden. Der Aufruf von <code>this.setState()</code> führt dann dazu, dass React entsprechende <strong>Lifecycle-Methoden</strong> (wie bspw. <code>componentDidUpdate()</code>) ausführt und eine Komponente <strong>neu rendert!</strong> Würden wir den State stattdessen direkt verändern, also bspw. <code>this.state.counter = 1;</code> schreiben, hätte dies vorerst keinerlei Auswirkungen auf unsere Komponente und alles würde aussehen wie bisher, da der Render-Prozess <strong>nicht</strong> ausgelöst werden würde!</p>
<p>Die Methode ist von der Funktionsweise her allerdings etwas komplexer als es auf den ersten Moment aussehen mag. Und so wird nicht einfach nur der alte State durch den neuen State ersetzt und ein Re-Rendering ausgelöst. Es passieren auch noch allerhand andere Dinge. Der Reihe nach.</p>
<p>Zuerst einmal kann die Funktion <strong>zwei verschiedene Arten von Argumenten</strong> entgegennehmen. Das ist einerseits ein <strong>Objekt</strong> mit neuen oder aktualisierten State-Eigenschaften, sowie andererseits eine <strong>Updater-Funktion,</strong> die wiederum ein Objekt zurückgibt oder <code>null</code>, falls nichts geändert werden soll. Bestehende gleichnamige Eigenschaften innerhalb des State-Objekts werden dabei <strong>überschrieben</strong>, alle anderen bleiben <strong>unangetastet!</strong> Möchten wir eine Eigenschaft im State zurücksetzen, müssen wie diese dazu also explizit auf <code>null</code> oder <code>undefined</code> setzen. Der übergebene State wird also immer mit dem bestehenden State <strong>zusammengefügt</strong>, niemals <strong>ersetzt!</strong></p>
<p>Nehmen wir nochmal unseren oben definierten State mit einer <code>counter</code> Eigenschaft, deren initialer Wert für dieses Beispiel erst einmal <code>0</code> ist. Nun verändern wir den State und möchten diesem zusätzlich eine <code>date</code> Eigenschaft mit dem aktuellen Datum hinzufügen. Übergeben als Objekt wäre unser Aufruf:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">this</span>.setState({
  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
});</code></pre>
<p>Nutzen wir stattdessen eine <strong>Updater-Funktion</strong>, wäre unser Aufruf:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
  };
});</code></pre>
<p>Oder kurz:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
});</code></pre>
<p>Unsere Komponente hat anschließend den neuen State:</p>
<pre><code class="hljs javascript language-javascript">{
  <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
}</code></pre>
<p>Um sicherzustellen stets auf den aktuellen State zuzugreifen, sollte eine <strong>Updater-Funktion</strong> verwendet werden, die den jeweils aktuellen State als ersten Parameter übergeben bekommt. Ein beliebter Fehler der vielen Entwicklern bei der Arbeit mit React schon passiert ist, ist es direkt nach einem <code>setState()</code>-Aufruf auf <code>this.state</code> zuzugreifen und sich zu wundern, dass der State noch immer der alte ist.</p>
<div class="hint hint--danger">
<p>React „sammelt“ schnell aufeinanderfolgende <code>setState()</code>-Aufrufe und <strong>führt diese nicht unmittelbar aus</strong>, um unnötig häufiges und überflüssiges Re-Rendering von Komponenten zu vermeiden. Schnell aufeinanderfolgende <code>setState()</code>-Aufrufe werden später in gesammelter Form als <strong>Batch-Prozess</strong> ausgeführt. Das ist wichtig zu wissen, da wir nicht unmittelbar nach einem <code>setState()</code>-Aufruf mittels <code>this.state</code> auf den neu gesetzten State zugreifen können.</p>
</div>
<p>Stellen wir uns eine Situation vor in der unser <code>counter</code>-State dreimal in schneller Abfolge erhöht werden soll. Intuitiv würde man nun vermutlich folgenden Code schreiben:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">counter</span>: <span class="hljs-keyword">this</span>.state.counter + <span class="hljs-number">1</span> });
<span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">counter</span>: <span class="hljs-keyword">this</span>.state.counter + <span class="hljs-number">1</span> });
<span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">counter</span>: <span class="hljs-keyword">this</span>.state.counter + <span class="hljs-number">1</span> });</code></pre>
<p>Was denkst du, wie ist der neue State wenn der initiale State <code>0</code> war? <code>3</code>? Falsch. Er ist <code>1</code>! Hier kommt der angesprochene <strong>Batching-Mechanismus</strong> von React zum Zug. Um ein sich zu schnell aktualisierendes User Interface zu vermeiden, wartet React hier erst einmal ab. Am Ende kann man den obigen Code simpel ausgedrückt <strong>vom Funktionsprinzip her</strong> in etwa gleichsetzen mit:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">this</span>.state = <span class="hljs-built_in">Object</span>.assign(
  <span class="hljs-keyword">this</span>.state,
  { <span class="hljs-attr">counter</span>: <span class="hljs-keyword">this</span>.state.counter + <span class="hljs-number">1</span> },
  { <span class="hljs-attr">counter</span>: <span class="hljs-keyword">this</span>.state.counter + <span class="hljs-number">1</span> },
  { <span class="hljs-attr">counter</span>: <span class="hljs-keyword">this</span>.state.counter + <span class="hljs-number">1</span> }
);</code></pre>
<p>Die <code>counter</code>-Property überschreibt sich hier während eines Batch-Updates also immer wieder selbst, nimmt aber stets <code>this.state.counter</code> als Basiswert für die Erhöhung um 1. Nachdem alle State-Updates ausgeführt wurden, ruft React dann erneut die <code>render()</code>-Methode der Komponente auf.</p>
<p>Bei der Verwendung einer <strong>Updater-Funktion</strong> wird dieser Funktion dabei der jeweils aktuellste State als Parameter übergeben und wir haben Zugriff auf den zum Zeitpunkt des Funktionsaufrufs gültigen State:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">counter</span>: state.counter + <span class="hljs-number">1</span> });
<span class="hljs-keyword">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">counter</span>: state.counter + <span class="hljs-number">1</span> });
<span class="hljs-keyword">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({ <span class="hljs-attr">counter</span>: state.counter + <span class="hljs-number">1</span> });</code></pre>
<p>In diesem Fall nutzen wir eine solche <strong>Updater-Funktion</strong> und aktualisieren jeweils den aktuellsten Wert. Der Wert von <code>this.state.counter</code> wäre hier also wie erwartet <code>3</code>, da wir über den übergebenen <code>state</code>-Parameter mit jedem Aufruf auf den aktuellen State zugreifen. Grundsätzlich ist es allerdings zu empfehlen sich die benötigten Werte erst einmal zu erzeugen und anschließend gesammelt in einem einzigen <code>setState()</code>-Aufruf zu übergeben. So ist sichergestellt, dass es keine unnötigen zwischenzeitlichen <code>render()</code>-Aufrufe mit im nächsten Moment direkt wieder veraltetem State gibt.</p>
<p>Sollte es doch einmal nötig werden unmittelbar nach einem <code>setState()</code>-Aufruf auf den eben neu gesetzten State zuzugreifen bietet React die Möglichkeit als optionalen zweiten Parameter eine Callback-Funktion zu übergeben. Diese wird aufgerufen <strong>nachdem</strong> der State aktualisiert wurde, so dass in dieser mittels <code>this.state</code> sicher auf den dann neu gesetzten State zugegriffen werden kann.</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">time</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleTimeString() }, () =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Neue Zeit:'</span>, <span class="hljs-keyword">this</span>.state.time);
});</code></pre>
<h2 id="lifecycle-methoden">Lifecycle-Methoden</h2>
<p><strong>Stateful Class Components</strong> bieten gegenüber ihren vereinfachten Kollegen, den <strong>Stateless Functional Components</strong> noch einen weiteren wichtigen Mehrwert: die sogenannten Lifecycle-Methoden (gelegentlich auch als Lifecycle-Hooks bezeichnet). Diese können als Methode einer Class Component implementiert werden und werden zu unterschiedlichen Zeitpunkten während eines Komponenten-Lebenszyklus (daher der Name) ausgeführt.</p>
<p>Der Lifecycle einer Methode beginnt in dem Moment, in der diese <strong>instanziiert</strong> wird, also innerhalb einer <code>render()</code>-Methode einer Eltern-Komponente tatsächlich Teil des zurückgegebenen Element-Baumes ist und endet, wenn die Komponente aus dem Baum der zu rendernden Elemente entfernt wird. Währenddessen gibt es noch Lifecycle-Methoden die auf Updates und auf Fehler reagieren. Oder eben darauf, dass sie nun entfernt („unmounted“) werden.</p>
<h3 id="überblick-über-die-lifecycle-methoden">Überblick über die Lifecycle-Methoden</h3>
<p>Im folgenden die Liste der Lifecycle-Methoden in der Reihenfolge wann und in welcher Phase diese durch React aufgerufen werden, sofern diese in einer Komponente definiert wurden:</p>
<h4 id="mount-phase">Mount-Phase</h4>
<p>Die folgenden Methoden werden <strong>einmalig</strong> aufgerufen wenn die Komponente erstmals gerendert werden, also, vereinfacht gesagt, erstmals zum DOM hinzugefügt werden:</p>
<ul>
<li><code>constructor(props)</code></li>
<li><code>static getDerivedStateFromProps(nextProps, prevState)</code></li>
<li><code>componentWillMount(nextProps, nextState)</code> (deprecated in React 17)</li>
<li><code>render()</code></li>
<li><code>componentDidMount()</code></li>
</ul>
<h4 id="update-phase">Update-Phase</h4>
<p>Die folgenden Methoden werden aufgerufen wenn Komponenten entweder durch die Hereingabe neuer Props von außen oder durch die Veränderung des eigenen States ein Update erhalten oder oder explizit die von React bereitgestellte <code>forceUpdate()</code>-Methode aufgerufen wird:</p>
<ul>
<li><code>componentWillReceiveProps(nextProps)</code> (deprecated in React 17)</li>
<li><code>static getDerivedStateFromProps(nextProps, prevState)</code></li>
<li><code>shouldComponentUpdate(nextProps, nextState)</code></li>
<li><code>componentWillUpdate(nextProps, nextState)</code> (deprecated in React 17)</li>
<li><code>render()</code></li>
<li><code>getSnapshotBeforeUpdate(prevProps, prevState)</code></li>
<li><code>componentDidUpdate(prevProps, prevState, snapshot)</code></li>
</ul>
<h4 id="unmount-phase">Unmount-Phase</h4>
<p>Hier gibt es nur eine Methode, diese wird aufgerufen sobald die Komponente aus dem DOM entfernt wird. Dies ist nützlich um bspw. Event-Listener oder <code>setTimeout()</code>/<code>setInterval()</code>-Aufrufe, die beim Mounting der Komponente hinzugefügt wurden, wieder zu entfernen:</p>
<ul>
<li><code>componentWillUnmount()</code></li>
</ul>
<h4 id="fehlerbehandlung">Fehlerbehandlung</h4>
<p>Zuletzt gibt es noch eine Methode die in React 16 neu hinzukam und immer dann aufgerufen wird wenn während des Renderings, in einer der Lifecycle-Methoden oder im Constructor einer <strong>Kind-Komponente</strong> ein Fehler geworfen wird:</p>
<ul>
<li><code>componentDidCatch()</code></li>
</ul>
<p>Komponenten die eine <code>componentDidCatch()</code>-Methode implementieren werden auch als <strong>Error Boundary</strong> bezeichnet und dienen dazu eine Alternative zum fehlerhaften Elementenbaum darzustellen. Dies kann eine High Level Komponente sein (bezogen auf die Komponenten-Hierarchie), die grundsätzliche eine Fehler-Seite anzeigt und den Nutzer auffordert die Anwendung neu zu laden sollte ein Fehler auftreten, dies kann aber auch eine Low Level Komponente sein die nur einen kurzen Fehlertext neben einem Button ausgibt, sollte die Aktion die der Button ausgelöst hat einen Fehler geworfen haben.</p>
<h3 id="lifecycle-methoden-in-der-praxis">Lifecycle-Methoden in der Praxis</h3>
<p>Werfen wir einmal einen Blick darauf wie sich die <strong>Lifecycle-Methoden</strong> in einer einfachen Komponente verhalten. Zu diesem Zweck implementieren wir beispielhalber eine Komponente die sekündlich ihren eigenen State verändert und jeweils die aktuelle Zeit ausgibt. Dazu wird beim <strong>Mounting</strong> der Komponente, also in der <code>componentDidMount()</code>-Methode, ein Interval gestartet, welches den State der Komponente aktualisiert, wodurch ein Rerendering ausgelöst und wieder die aktuelle Zeit angezeigt wird:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
  };

  componentDidMount() {
    <span class="hljs-keyword">this</span>.intervalId = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
        <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
      }));
    }, <span class="hljs-number">1000</span>);
  }

  componentWillUnmount() {
    clearTimeout(<span class="hljs-keyword">this</span>.intervalId);
  }

  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{this.state.date.toLocaleTimeString()}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
  }
}

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Hier sehen wir die Lifecycle-Methoden <code>componentDidMount()</code> und <code>componentWillUnmount()</code> im Einsatz. Wir definieren einen default <strong>State</strong> mit einer Eigenschaft <code>date</code>, die eine Instanz des Date-Objekts hält. Beim <strong>Mounting</strong> der Komponente (<code>componentDidMount()</code>) wird dann via <code>setInterval()</code> der Intervall gestartet und dessen Intervall ID in der Instanz-Eigenschaft <code>this.intervalId</code> gespeichert. Da der Intervall sekündlich die <code>setState()</code>-Methode aufruft, verursacht die Komponente auch regelmäßig ein Re-Rendering, d.h. die <code>render()</code>-Methode wird erneut aufgerufen und zeigt wieder die aktuelle Zeit an.</p>
<p>Da die Intervall-Funktion grundsätzlich unabhängig von der React-Komponente ist und abgesehen davon, dass sie die <code>setState()</code>-Methode der Komponente aufruft, keinerlei Verbindung zu ihr hat, kümmert sich React auch nicht automatisch darum, dass der Intervall-Aufruf der Funktion gestoppt wird wenn wir die Komponente nicht mehr weiter benötigen. Dafür müssen wir selber sorgen und genau zu diesem Zweck hält React für uns die nächste Lifecycle-Methode bereit: <code>componentWillUnmount()</code>.</p>
<p>Diese Methode wird unmittelbar bevor React die Komponente aus dem DOM entfernt aufgerufen und kann dazu benutzt werden um bspw. noch laufende XHRs abzubrechen, Event Listener zu entfernen oder eben einen laufenden Funktionsintervall zu beenden. Genau das tun wir hier: bevor die Komponente entfernt wird, rufen wir <code>clearTimeout()</code> auf und übergeben der Funktion die Intervall ID, die wir zuvor in der entsprechenden Instanz-Eigenschaft gespeichert haben.</p>
<p>Sollten wir dies einmal vergessen werden wir im Development-Modus von React aber spätestens beim Aufruf von <code>this.setState()</code> in einer bereits entfernten Komponente mit einer Warnung erinnert:</p>
<div class="hint hint--danger">
<p><strong>Warning:</strong> Can't call setState (or forceUpdate) on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.<br />
 in Clock</p>
</div>
<p>Anders als in einigen vorherigen Beispielen rufen wir hier die <code>ReactDOM.render()</code>-Methode nur ein einziges mal auf. Die Komponente kümmert sich ab dann „um sich selbst“ und löst einen Render-Vorgang aus, sobald sich ihr <strong>State</strong> aktualisiert hat. Dies ist die übliche Vorgehensweise bei der Entwicklung von Anwendungen die auf React basieren. Ein einziger <code>ReactDOM.render()</code>-Aufruf und ab dort verwaltet sich die App sozusagen von alleine, erlaubt Interaktion mit dem Benutzer, reagiert auf Zustandsänderungen und rendert regelmäßig das Interface neu.</p>
<h3 id="das-zusammenspiel-von-state-und-props">Das Zusammenspiel von State und Props</h3>
<p>Wir haben jetzt Beispiele gesehen für Komponenten, die Props verarbeiten und für Komponenten, die <strong>stateful</strong> sind, also ihren eigenen State verwalten. Doch es gibt noch eine ganze Menge mehr zu entdecken. Erst die Kombination mehrerer verschiedener Komponenten macht React erst zu dem mächtigen Werkzeug, das es ist. Eine Komponente kann dabei einen eigenen <strong>State</strong> haben und diesen gleichzeitig an Kind-Komponenten über deren <strong>Props</strong> weitergeben. So ist nicht nur die strikte Trennung von Business-Logik und Darstellung/Layout möglich sondern es erlaubt uns auch wunderbar Aufgaben basierte Komponenten zu entwickeln, die jeweils nur einen kleinen Teil der Applikation abbilden.</p>
<p>Bei der Trennung von Business- und Layout-Komponenten ist im React Jargon meist die Rede von <strong>Smart</strong> (Business-Logik) und <strong>Dumb</strong> (Layout) Components. <strong>Smart Components</strong> sollten dabei möglichst wenig bis gar nicht mit der Darstellung des User Interfaces betraut werden, während <strong>Dumb Components</strong> frei von jeglicher Business-Logik oder Seiteneffekten sein sollten, sich also tatsächlich auf die reine Darstellung von statischen Werten konzentrieren.</p>
<p>Schauen wir uns also das Zusammenspiel mehrerer Komponenten in einem weiteren Beispiel an:</p>
<pre><code class="hljs jsx language-jsx">const ShowDate = ({ date }) =&gt; &lt;div&gt;Heute ist {date}&lt;/div&gt;;

const ShowTime = ({ time }) =&gt; &lt;div&gt;Es ist {time} Uhr&lt;/div&gt;;

class DateTime extends React.Component {
  state = {
    date: new Date(),
  };

  componentDidMount() {
    this.intervalId = setInterval(() =&gt; {
      this.setState(() =&gt; ({
        date: new Date(),
      }));
    });
  }

  componentWillUnmount() {
    clearInterval(this.intervalId);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;ShowDate date={this.state.date.toLocaleDateString()} /&gt;
        &lt;ShowTime time={this.state.date.toLocaleTimeString()} /&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(&lt;DateTime /&gt;, document.getElementById('root'));</code></pre>
<p>Zugegeben: das Beispiel ist sehr konstruiert, demonstriert aber leicht verständlich das Zusammenspiel mehrerer Komponenten. Die <code>DateTime</code> Komponente ist in diesem Sinne unsere <strong>Logik-Komponente</strong>: sie kümmert sich darum die Zeit zu "besorgen" und zu aktualisieren, überlässt dann aber den <strong>Darstellungs-Komponenten</strong> deren Ausgabe, indem sie das Datum (<code>ShowDate</code>) bzw. die Zeit (<code>ShowTime</code>) über die Props übergeben bekommt.</p>
<p>Die Darstellungs-Komponenten selbst sind dabei als simple Stateless Functional Components implementiert, da diese selbst keinen eigenen State besitzen und daher kurz und knackig als SFC implementiert werden können.</p>
<h3 id="die-rolle-der-lifecycle-methoden-im-zusammenspiel-der-komponenten">Die Rolle der Lifecycle-Methoden im Zusammenspiel der Komponenten</h3>
<p>Eingangs habe ich neben den bisher in den Beispielen verwendeten <code>componentDidMount()</code> und <code>componentWillMount()</code> noch einige weitere <strong>Lifecycle-Methoden</strong> erwähnt. Auch diese werden, sofern in einer Class Component implementiert, zu den verschiedenen Anlässen von React berücksichtigt.</p>
<p>Zu diesem Zweck wollen wir einmal eine Übungskomponente erstellen, welche die verschiedenen <strong>Lifecycle-Methoden</strong> als Debug-Nachricht in der Browser-Konsole ausgibt. Genau genommen sind es zwei Komponenten, von denen eine als Eltern-Komponente, die andere als Kind-Komponente dient, die von ihrer Eltern-Komponente Props hineingereicht bekommt (und in diesem Fall einfach ignoriert).</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> log = <span class="hljs-function">(<span class="hljs-params">method, component</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[<span class="hljs-subst">${component}</span>]`</span>, method);
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParentComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {};

  <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props);
    log(<span class="hljs-string">'constructor'</span>, <span class="hljs-string">'parent'</span>);
  }

  <span class="hljs-keyword">static</span> getDerivedStateFromProps() {
    log(<span class="hljs-string">'getDerivedStateFromProps'</span>, <span class="hljs-string">'parent'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  componentDidMount() {
    log(<span class="hljs-string">'componentDidMount'</span>, <span class="hljs-string">'parent'</span>);
    <span class="hljs-keyword">this</span>.intervalId = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      log(<span class="hljs-string">'state update'</span>, <span class="hljs-string">'parent'</span>);
      <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
        <span class="hljs-attr">time</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleTimeString(),
      }));
    }, <span class="hljs-number">2000</span>);
  }

  shouldComponentUpdate() {
    log(<span class="hljs-string">'shouldComponentUpdate'</span>, <span class="hljs-string">'parent'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  getSnapshotBeforeUpdate() {
    log(<span class="hljs-string">'getSnapshotBeforeUpdate'</span>, <span class="hljs-string">'parent'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  componentDidUpdate() {
    log(<span class="hljs-string">'componentDidUpdate'</span>, <span class="hljs-string">'parent'</span>);
  }

  componentWillUnmount() {
    log(<span class="hljs-string">'componentWillUnmount'</span>, <span class="hljs-string">'parent'</span>);
    clearInterval(<span class="hljs-keyword">this</span>.intervalId);
  }

  render() {
    log(<span class="hljs-string">'render'</span>, <span class="hljs-string">'parent'</span>);
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">time</span>=<span class="hljs-string">{this.state.time}</span> /&gt;</span>;
  }
}

class ChildComponent extends React.Component {
  state = {};

  constructor(props) {
    super(props);
    log('constructor', 'child');
  }

  static getDerivedStateFromProps() {
    log('getDerivedStateFromProps', 'child');
    return null;
  }

  componentDidMount() {
    log('componentDidMount', 'child');
  }

  shouldComponentUpdate() {
    log('shouldComponentUpdate', 'child');
    return true;
  }

  getSnapshotBeforeUpdate() {
    log('getSnapshotBeforeUpdate', 'child');
    return null;
  }

  componentDidUpdate() {
    log('componentDidUpdate', 'child');
  }

  componentWillUnmount() {
    log('componentWillUnmount', 'child');
  }

  render() {
    log('render', 'child');
    return <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{this.props.time}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>;
  }
}

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">ParentComponent</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Diese beiden Komponenten führen zuverlässig zur folgenden Ausgabe:</p>
<pre><code class="hljs text language-text"><span class="hljs-string">[parent]</span> constructor
<span class="hljs-string">[parent]</span> getDerivedStateFromProps
<span class="hljs-string">[parent]</span> render
<span class="hljs-string">[child]</span> constructor
<span class="hljs-string">[child]</span> getDerivedStateFromProps
<span class="hljs-string">[child]</span> render
<span class="hljs-string">[child]</span> componentDidMount
<span class="hljs-string">[parent]</span> componentDidMount
<span class="hljs-string">[parent]</span> state update
<span class="hljs-string">[parent]</span> shouldComponentUpdate
<span class="hljs-string">[parent]</span> render
<span class="hljs-string">[child]</span> getDerivedStateFromProps
<span class="hljs-string">[child]</span> shouldComponentUpdate
<span class="hljs-string">[child]</span> render
<span class="hljs-string">[child]</span> getSnapshotBeforeUpdate
<span class="hljs-string">[parent]</span> getSnapshotBeforeUpdate
<span class="hljs-string">[child]</span> componentDidUpdate
<span class="hljs-string">[parent]</span> componentDidUpdate
<span class="hljs-string">[parent]</span> componentWillUnmount
<span class="hljs-string">[child]</span> componentWillUnmount</code></pre>
<p>Oh wow. Hier passiert also eine ganze Menge. Gehen wir also Zeile für Zeile durch und starten mit der Mount-Phase.</p>
<h4 id="constructorprops"><code>constructor(props)</code></h4>
<p>Als Erstes wird stets der <code>constructor</code> der <code>ParentComponent</code>-Komponente aufgerufen. React geht hier von „außen nach innen“ vor. Also Komponenten, die weiter oben in der Komponenten-Hierarchie stehen, werden zuerst instanziiert und anschließend deren <code>render()</code>-Methode aufgerufen. Dies ist notwendig, da React ansonsten nicht wüsste welche Kind-Komponenten überhaupt verarbeitet und berücksichtigt werden sollen, da React nur solche Kind-Komponenten berücksichtigt, die auch tatsächlich von der <code>render()</code>-Methode ihrer jeweiligen Eltern-Komponente zurückgegeben werden.</p>
<p>Der Constructor bekommt als Parameter die Props der Komponente übergeben und sollte diese über <code>super(props)</code> an seine Elternklasse (in der Regel ist das die <code>React.Component</code> oder <code>React.PureComponent</code> Klasse) weitergeben, da <code>this.props</code> ansonsten im Constuctor <code>undefined</code> ist, was zu unerwünschtem Verhalten und Bugs führen kann.</p>
<p>In vielen Fällen ist der Constructor heute gar nicht mehr notwendig wenn mit dem Babel-Plugin „Class Properties“ gearbeitet wird und sowohl State als auch Instanz-Methoden als Klassen-Eigenschaft implementiert werden. Ist dies nicht der Fall, ist der Constructor der Ort, um einen initialen State zu setzen (bspw. <code>this.state = { }</code>) und Instanz-Methoden mittels <code>.bind()</code> an die jeweilige Klassen-Instanz zu binden (bspw. <code>this.handleClick = this.handleClick.bind(this)</code>). Letzteres ist notwendig, da Instanz-Methoden bei der Verwendung als Event-Listener innerhalb von JSX sonst ihren Bezug zur Komponente verlieren würden und <code>this</code> nicht auf die Instanz der Komponente verweisen würde.</p>
<h4 id="static-getderivedstatefrompropsnextprops-prevstate"><code>static getDerivedStateFromProps(nextProps, prevState)</code></h4>
<p>Auf den Constructor folgt die statische <code>getDerivedStateFromProps()</code>-Methode. Da dies eine <strong>statische</strong> Methode ist (und als solche wie auch in unserem Beispiel oben mit dem Keyword <code>static</code> ausgezeichnet werden muss) hat sie keinerlei Zugriff auf die Instanz der Komponente mittels <code>this</code>. Die Methode dient dazu, um, basierend auf den in die Komponente hineingereichten Props und ggf. dem letzten State, den <strong>nächsten State</strong> der Komponente zu berechnen. Dieser wird als Objekt aus der Methode zurückgegeben. Sind keine Änderungen am State notwendig, soll <code>null</code> zurückgegeben werden. Dabei ist das Verhalten identisch zu <code>this.setState()</code>, und es wird nur der Teil des States aktualisiert, der sich auch im zurückgegebenen Objekt befindet. Diese Eigenschaften werden mit dem <strong>letzten State</strong> zu einem <strong>neuen State</strong> zusammengeführt.</p>
<p>Die Methode ist innerhalb der Community kontrovers diskutiert worden, da sie die nun als <strong>deprecated</strong> gekennzeichnete <strong>Lifecycle-Methode</strong> <code>componentWillReceiveProps()</code> ablöst, jedoch anders als diese, keinen Zugriff auf die Instanz der Komponente erlaubt. Die React-Entwickler haben diesen Schritt damit begründet dass diese beim überarbeiteten asynchronen Rendering von Komponenten zu unerwünschten Verhalten führen kann und haben die Methode (ebenso wie <code>componentWillMount()</code> und <code>componentWillUpdate()</code>) als „unsicher“ erkärt. Mit dem Begriff ist dabei explizit nicht die Sicherheit (im Sinne von Sicherheitslücken) gemeint sondern lediglich die Tatsache, dass Komponenten, die diese Lifecycle-Methoden verwenden in React 17 Bugs und anderen unerwünschten Effekte hervorrufen können.</p>
<p>Die <code>getDerivedStateFromProps()</code>-Methode sollte außerdem frei von Side Effects bleiben (also bspw. keine XHRequests veranlassen) sondern lediglich den neuen State der Komponenten-Instanz auf Basis der jeweiligen aktuellen Props berechnen bzw. <strong>ableiten</strong> (= derive). Anders als der Constructor wird die Methode nicht nur beim Mounting, also dem „Einhängen“ in den DOM, der Komponente aufgerufen sondern auch wenn die Komponente erneut Props empfängt. Diese müssen sich dabei nicht zwangsweise geändert haben.</p>
<h4 id="render"><code>render()</code></h4>
<p>Ist die Instanz einer Komponente erstellt und ihr State abgeleitet, ruft React bereits die <code>render()</code>-Methode auf. Die <code>render()</code>-Methode beschreibt unser User Interface und somit auch, welche Kind-Komponenten gerendert werden sollen. In unserem obigen Beispiel haben wir nur eine Kind-Komponente: die <code>ChildComponent</code> Komponente.</p>
<p>Und so geht hier das Spiel erneut los: <code>constructor()</code>, <code>getDerivedStateFromProps()</code> und anschließend wird auch die <code>render()</code>-Methode der Kind-Komponente aufgerufen. Also das exakt selbe Verhalten wie auch schon bei der <code>ParentComponent</code> Komponente. Die Kind-Komponente aus dem Beispiel hat hier keine weiteren eigenen Kind-Komponenten. Hätte sie diese, würden auch hier die obigen Lifecycle-Methoden ausgeführt werden, bis React bei diesem Ast irgendwann auf eine Komponente trifft, die keinerlei eigenen React-Komponenten mehr zurückgibt, sondern DOM-Elemente wie <code>div</code>, <code>p</code>, <code>section</code>, <code>span</code>, etc. (natürlich auch Kombinationen dieser) oder <code>null</code> oder eben ein Array der wiederum ebenfalls keine Komponenten enthält.</p>
<h4 id="componentdidmount"><code>componentDidMount()</code></h4>
<p>Ist eine solche Komponente erreicht, ist die <code>componentDidMount()</code>-Methode an der Reihe. Diese Methode wird aufgerufen sobald eine Komponente und all ihre Kind-Komponenten gerendert wurden. Ab diesem Moment kann auf die DOM-Node der Komponente zugegriffen werden falls notwendig. Die Methode ist außerdem der richtige Ort um bspw. Timeouts oder Intervalle zu starten oder Netzwerk-Requests bspw. via XHR/Fetch zu veranlassen.</p>
<p>Die Methode wird „von innen nach außen“ aufgerufen. Also erst sind die Kind-Komponenten an der Reihe sobald diese gerendert wurden, dann kommen die Eltern-Komponenten dran. So können wir in der obigen Log-Ausgabe auch gut sehen, dass dort erst einmal die <code>componentDidMount()</code>-Methode der <code>ChildComponent</code> aufgerufen wird, erst danach die der <code>ParentComponent</code>.</p>
<p>In unserem Beispiel starten wir in der <code>ParentComponent</code> einmalig einen <code>setTimeout()</code> Aufruf, der nach 2000 Millisekunden den State der Komponente ändert, um diejenigen Lifecycle-Methods zu demonstrieren, die beim Update einer Komponente aufgerufen werden. Die Mount-Phase ist damit abgeschlossen und alle weiteren Änderungen am State der gemounteten Komponenten führen dazu, dass React die Lifecycle-Methods aus der Update-Phase aufruft. Dies ist hier eben nach 2000 Millisekunden der Fall, wenn die ParentComponent ihren eigenen State mittels <code>this.setState()</code> modifiziert.</p>
<h4 id="shouldcomponentupdatenextprops-nextstate"><code>shouldComponentUpdate(nextProps, nextState)</code></h4>
<p>Findet ein Update einer Komponente statt, das ist immer der Fall wenn die Komponente ihren State verändert oder von außen Props hereingereicht bekommt, wird <code>shouldComponentUpdate()</code> aufgerufen. Doch Vorsicht, hier gibt es einen Unterschied je nachdem ob sich die Props geändert haben oder der State: bekommt eine Komponente neue Props von außen, wird zuvor <code>getDerivedStateFromProps()</code> aufgerufen.</p>
<p>Die <code>shouldComponentUpdate()</code>-Methode dient als „Hilfe“ mit der React mitgeteilt werden kann ob ein kostspieliges Re-Rendering überhaupt nötig ist. Die Methode bekommt die <strong>nächsten Props</strong> und den <strong>nächsten State</strong> als Parameter übergeben und kann auf deren Basis eine Entscheidung treffen ob ein Rendering ausgeführt werden soll. Die Methode muss dabei entweder <code>true</code> zurückgeben, damit wird ein Re-Rendering ausgelöst wird oder <code>false</code>, wodurch der Aufruf von sowohl <code>componentDidUpdate()</code> , <code>getSnapshotBeforeUpdate()</code> als auch <code>render()</code> in dieser Komponente unterbunden wird.</p>
<p>In komplexen Anwendungen ist es oftmals der Fall, dass der Update-Zyklus nur ausgelöst wird weil sich in einem anderen Teil der Anwendung, in einer Eltern-Komponente etwas geändert hat, diese Änderung aber für Kind-Komponenten irrelevant ist. Die <code>shouldComponentUpdate()</code>-Methode ist dann sehr hilfreich wenn es um die Optimierung der Rendering-Performance geht, da so unnötige Re-Renderings verhindert werden.</p>
<p>Würden wir in unserer obigen <code>ParentComponent</code> aus der <code>shouldComponentUpdate()</code>-Methode prinzipiell <code>false</code> zurückgeben wäre unsere Log-Ausgabe um einiges kürzer: die Zeilen 14-18 würden fehlen. Die Komponente würde nicht neu gerendert werden, ein Aufruf der render()-Methode fände nicht statt, damit würde auch die <code>ChildComponent</code> nicht neu gerendert werden und folglich auch deren Update-Hooks nicht aufgerufen werden.</p>
<p>Im Code-Beispiel geben wir aber <code>true</code> zurück. Dadurch wird folglich auch die <code>render()</code>-Methode der <code>ParentComponent</code> aufgerufen. Diese rendert wiederum erneut die <code>ChildComponent</code> die den aktualisierten <strong>State</strong> der <code>ParentComponent</code> in ihren <strong>Props</strong> übergeben bekommt und schon befinden wir uns im Update-Zyklus der <code>ChildComponent</code>.</p>
<p>Hier wird wie schon beim Mount-Zyklus <code>getDerivedStateFromProps()</code> aufgerufen um einen neuen State basierend auf den neuen Props abzuleiten. Anschließend wird auch hier <code>shouldComponentUpdate()</code> aufgerufen. Hier könnten wir bspw. prüfen ob sich die für diese Komponente relevanten Props überhaupt geändert haben und könnten dann im Fall, dass sie das nicht getan haben, ein Re-Rendering der Komponente sparen, indem wir ganz einfach <code>false</code> zurückgeben. Tun wir nicht, also folgt als nächstes der obligatorische Aufruf der <code>render()</code>-Funktion. Direkt darauf folgend wird nun die nächste Lifecycle-Methode aufgerufen.</p>
<h4 id="getsnapshotbeforeupdateprevprops-prevstate"><code>getSnapshotBeforeUpdate(prevProps, prevState)</code></h4>
<p>Diese Methode ist noch recht neu und wurde in React 16.3 zusammen mit <code>getDerivedStateFromProps()</code> neu eingeführt, um den Anforderungen für das neue asynchrone Rendering in React gerecht zu werden. Sie bekommt die <strong>letzten Props</strong> und den <strong>letzten State</strong> übergeben und hat letztmals Zugriff auf den aktuellen Zustand des HTML Dokuments, genauer gesagt dem DOM, bevor React die möglichen Änderungen aus dem letzten <code>render()</code>-Aufruf anwendet.</p>
<p>Dies kann nützlich sein wenn man sich bspw. die aktuelle Scrollposition in einer langen Tabelle oder Liste merken möchte um bei einem Update der Liste wieder zur entsprechenden Zeile springen zu können. Die Methode kann hier einen beliebigen Wert oder <code>null</code> zurückgeben. Das, was <code>getSnapshotBeforeUpdate()</code> zurückgibt, wird dann als dritter Parameter an die nächste Lifecycle-Methode, <code>componentDidUpdate()</code> übergeben.</p>
<p>Aus meiner Erfahrung wird diese Methode nur sehr selten verwendet, wahrscheinlich am seltensten von allen Lifecycle-Methoden, da bei der Arbeit mit React auch nur sehr selten direkt auf DOM-Elemente zugegriffen werden muss. Viele Dinge bei denen man bei einer imperativen Vorgehensweise auf die DOM API zurückgegriffen hätte, lassen sich hier direkt im abstrakten Virtual DOM, also über JSX lösen.</p>
<h4 id="componentdidupdateprevprops-prevstate-snapshot"><code>componentDidUpdate(prevProps, prevState, snapshot)</code></h4>
<p>Als letzte Methode aus dem Update-Zyklus ist dann <code>componentDidUpdate()</code> an der Reihe. Diese wird aufgerufen nachdem <code>getDerivedStateFromProps()</code> den neuen State abgeleitet hat, nachdem <code>shouldComponentUpdate()</code>, sofern implementiert, <code>true</code> zurückgegeben hat und nachdem <code>getSnapshotBeforeUpdate()</code> einen Snapshot des letzten Stands des DOM erstellt hat.</p>
<p>Die Methode bekommt als Parameter die <strong>letzten Props</strong> und den <strong>letzten State</strong> übergeben, d.h. die jeweiligen Props und den jeweiligen State bevor die Komponente aktualisiert wurde, und, sollte die Komponente eine <code>getSnapshotBeforeUpdate()</code>-Methode besitzen, deren Rückgabewert als dritten Parameter.</p>
<p>Ähnlich wie bereits <code>componentDidMount()</code> wird auch <code>componentDidUpdate()</code> „von innen nach außen“ aufgelöst, also werden erst die <code>componentDidMount()</code>-Methoden der Kind-Komponente(n) aufgerufen, danach die der Eltern-Komponente(n). Diese Methode ist der ideale Ort um Side Effects auszulösen, also bspw. XHRs zu starten, wenn sich gewisse Eigenschaften der Komponente geändert haben. Dies lässt sich durch einen simplem Vergleich der aktuellen Props mit den als Parameter übergebenen letzten Props bzw. dem aktuellen State mit den letzten State festgestellt werden kann.</p>
<p>Auch ist es in dieser Komponente sicher auf den <strong>aktuellen DOM</strong> zuzugreifen, sollte dies doch einmal notwendig sein. Zu dem Zeitpunkt an dem diese Methode aufgerufen wird, hat React die notwendigen Änderungen, die sich aus dem möglicherweise geänderten JSX aus der <code>render()</code>-Methode ergeben, bereits durchgeführt und in den DOM übertragen.</p>
<p>Und damit ist neben dem <strong>Mount-Zyklus</strong> auch der <strong>Update-Zyklus</strong> abgeschlossen. Während der Mount-Zyklus <strong>immer nur einmal</strong> durchlaufen wird, nämlich dann wenn eine Komponente <strong>erstmals</strong> gerendert wird, kann der Update-Zyklus, solange die Komponente gemountet ist, beliebig häufig angestoßen werden und wird immer durchlaufen, sobald eine Komponente ihren State ändert oder neue Props bezieht.</p>
<h4 id="componentwillunmount"><code>componentWillUnmount()</code></h4>
<p>Zugegeben, im obigen Log habe ich etwas geschummelt, denn die <code>componentWillUnmount()</code>-Methode wird immer dann (und nur dann) ausgeführt wenn eine Komponente komplett aus dem DOM entfernt wird. Das wird sie im dazugehörigen Code-Beispiel allerdings nie. Eine Komponente gilt dann als unmounted, wenn sie über den Aufruf von <code>ReactDOM.unmountComponentAtNode()</code> explizit entfernt wird (das gilt insbesondere für Mount-Nodes) oder wenn sie implizit nicht mehr aus der render()-Methode einer Eltern-Komponente zurückgegeben wird.</p>
<p>Immer dann wird die <code>componentWillUnmount()</code>-Methode einer Komponente aufgerufen. Natürlich wie bei allen Methoden, abgesehen von <code>render()</code>, nur dann wenn sie auch implementiert wurde. Diese Lifecycle-Methode ist essentiell wenn es um das „Aufräumen“ geht. Hier können und <strong>sollten</strong> all die Funktionen aufgerufen werden die benötigt sind, damit die Komponente keine „Spuren hinterlässt“. Das können noch ausstehende Timeouts (<code>setTimeout</code>) oder fortlaufende Intervalle (<code>setInterval</code>) sein aber auch DOM-Modifikationen die außerhalb des eigenen Komponenten-JSX vorgenommen wurden, noch laufende Netzwerkverbindungen bzw. XHR/Fetch-Aufrufe oder auch eigene Event Listener, die mittels der DOM API Methode <code>Element.addEventListener()</code> hinzugefügt wurden.</p>
<p>Event Listener. Gutes Stichwort. Darum kümmern wir uns im nächsten Kapitel, denn in den meisten Fällen ist der Einsatz von <code>addEventListener()</code> in React nicht mehr nötig, da React ein eigenes Event-System mitbringt um für bessere Übersicht zu sorgen.</p>
<h3 id="diagram">Diagram</h3>
<p class="has-image"><span><img src="../.gitbook/assets/lifecycle-methods-2.png" alt="Diagram der verschiedenen Lifecycle-Methods in ihren jeweiligen Phasen (CC0 Dan Abramov)" /><span class="caption">Diagram der verschiedenen Lifecycle-Methods in ihren jeweiligen Phasen (CC0 Dan Abramov)</span></span></p>
</div><div class="chapter">
<h1 id="event-handling">Event-Handling</h1>
<p>Ein wesentlicher Teil bei der Entwicklung von Anwendungen mit einem komplexen User Interfaces ist natürlich die Interaktion zwischen Benutzer und dem Interface an sich. Insbesondere in Form von <strong>Events</strong>.</p>
<p>Ich drücke einen Knopf und es passiert etwas. Ich schreibe einen Text in ein Feld und es passiert etwas. Ich wähle ein Element aus einer Liste und es passiert etwas. In einfachem JavaScript stellt uns der Browser dafür die Methoden <code>addEventListener()</code> und <code>removeEventListener()</code> bereit. Auf diese beiden Event-Methoden kann in React in den meisten Fällen nahezu komplett verzichtet werden, da React ein eigenes System zum Definieren von Benutzerinteraktion gleich mitbringt. Und zwar, nicht erschrecken: über <strong>Inline-Events</strong>.</p>
<p>Diese <strong>Inline-Events</strong> haben rein äußerlich sehr große Ähnlichkeit zu den HTML Event-Attributen (also bspw. <code>&lt;button onclick="myFunction" /&gt;</code>) und doch ist ihre Funktionsweise grundlegend anders.</p>
<p>Da wurde uns Web-Entwicklern über Jahre immer wieder beigebracht, dass man seine Event-Listener sauber von seinem Markup trennen sollte, <strong>Separation of Concerns</strong>, dann kommt React daher und macht wieder einfach alles anders.</p>
<p>Und das ist in diesem Fall auch gut so, denn durch die Verwendung eines eigenen Systems zur Verwaltung von Events, nimmt uns React hier wieder eine ganze Menge Arbeit ab und ermöglicht es uns außerdem sehr leicht im Komponenten-Kontext zu bleiben, indem wir alle Event-Handler als <strong>Klassen-Methoden</strong> implementieren können und so sowohl Darstellungslogik als auch Verhaltenslogik in einer einzigen Komponente kapseln können. Kein mühsames und unübersichtliches hin- und herspringen zwischen Controllern und Views!</p>
<h3 id="unterschiede-zur-nativen-event-api">Unterschiede zur nativen Event API</h3>
<p>Events in React und JSX werden wie erwähnt sehr ähnlich definiert wie HTML Event-Attribute. Doch es gibt einige Unterschiede. So werden Events in React in <strong>CamelCase</strong>-Form definiert, statt in <strong>Lowercase</strong>. Somit wird aus <code>onclick</code> in React <code>onClick</code>, aus <code>onmouseover</code> wird <code>onMouseOver</code>, <code>ontouchstart</code> wird zu <code>onTouchStart</code> usw.</p>
<p>Der dem Event-Handler übergebene erste Parameter ist auch kein Objekt vom Typ <code>Event</code>, sondern ein sogenannter <code>SyntheticEvent</code>, ein React eigener Wrapper um das native Event-Objekt. Dieser Wrapper ist Teil des React Event Systems und dient als eine Art Normalisierungsschicht, um Cross-Browser-Kompatibilität zu gewährleisten. Dabei hält diese sich, anders als so mancher Browser, strikt an die <a href="https://www.w3.org/TR/DOM-Level-3-Events/">Event-Spezifikation des W3C</a>.</p>
<p>Ein weiterer Unterschied zur nativen Browser-Event API ist der, dass explizit <code>preventDefault()</code> aufgerufen werden muss um das Standardverhalten des Browsers bei einem Event zu unterdrücken statt lediglich <code>false</code> aus dem Event-Handler zurückzugeben.</p>
<p>Und nicht zuletzt, ist der im Event-Attribut (bzw. Event-<strong>Prop</strong> in JSX) angegebene Wert eine <strong>Referenz zu einer Funktion</strong> statt wie in HTML ein String. Folglich benötigen wir hier die geschweiften Klammern um JSX mitzuteilen, dass es sich um einen JavaScript-Ausdruck handelt.</p>
<p>Wie das aussieht? So:</p>
<pre><code class="hljs jsx language-jsx">&lt;button onClick={validateInput}&gt;Validate&lt;<span class="hljs-regexp">/button&gt;</span></code></pre>
<p>Wohingegen ein vergleichbarer Event in HTML wie folgt aussähe:</p>
<pre><code class="hljs markup language-markup">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">"validateInput"</span>&gt;Validate&lt;/<span class="hljs-keyword">button</span>&gt;</code></pre>
<p>Dieses Vorgehen, das auf den ersten Blick auf einige vielleicht erst einmal etwas eigenartig anmuten könnte bringt aber einige großartige Vorteile mit sich. Und so bekommen wir, wie eingangs bereits angesprochen, Cross-Browser-Kompatibilität „for free“. React registriert dabei im Hintergrund die Events sauber mittels <code>addEventListener()</code> und entfernt diese auch automatisch wieder für uns, sobald die Komponente entfernt (<em>unmounted</em>) wird. Praktisch!</p>
<h3 id="scopes-in-event-handlern">Scopes in Event-Handlern</h3>
<p>Bei der Verwendung von ES2015-Klassen in React ist für gewöhnlich so, dass Event-Handler als Methoden der Klassen-Komponente implementiert werden. Hierbei muss jedoch beachtet werden, dass <strong>Klassen-Methoden nicht automatisch an die Instanz gebunden werden</strong>. Klingt kompliziert, bedeutet aber lediglich, dass <code>this</code> in eurem Event-Handler grundsätzlich erstmal <code>undefined</code> ist.</p>
<p>Hierzu ein kurzes Beispiel:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span>,
  };

  increase() {
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({
      <span class="hljs-attr">counter</span>: state.counter + <span class="hljs-number">1</span>,
    }));
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{this.state.counter}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.increase}</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}</code></pre>
<p>Hier definieren wir also einen <code>onClick</code>-Event um den Zähler jeweils um <code>1</code> zu erhöhen, sobald der Benutzer auf den Button <code>+1</code> klickt. Beim Klick auf den Button sieht unser Benutzer aber stattdessen:</p>
<div class="hint hint--danger">
<p><strong>TypeError</strong></p>
<p>Cannot read property 'setState' of undefined</p>
</div>
<p>Und warum? <strong>Scoping!</strong> Da wir uns beim Klick auf den Button im Event-Handler <code>increase()</code> außerhalb der Komponenten-Instanz bewegen, können wir eben auch nicht auf <code>this.setState()</code> zugreifen. Dies ist kein fehlerhaftes Verhalten von React sondern das Standardverhalten von ES2015-Klassen. Um dieses Problem zu lösen gibt es nun verschiedene Möglichkeiten.</p>
<h4 id="method-binding-in-der-render-methode">Method-Binding in der render()-Methode</h4>
<p>Die trivialste Methode ist das Binden der Methode innerhalb der <code>render()</code>-Methode. Dazu fügen wir ein <code>.bind(this)</code> an die Referenz zur Klassen-Methode:</p>
<pre><code class="hljs jsx language-jsx">&lt;button onClick={<span class="hljs-keyword">this</span>.increase.bind(<span class="hljs-keyword">this</span>)}&gt;+<span class="hljs-number">1</span>&lt;<span class="hljs-regexp">/button&gt;</span></code></pre>
<p>Die Methode wird nun <strong>im Scope der Komponenten-Instanz</strong> aufgerufen und unser Counter zählt problemlos hoch. Dieses Muster sieht man relativ häufig, da es einfach implementiert ist, hat jedoch einen grundlegenden Nachteil. Denn es wird bei jedem Aufruf der Methode „on-the-fly“ eine neue Funktion erzeugt, die nicht mehr mit der vorherigen identisch ist. Ein simpler Check in einer <code>shouldComponentUpdate()</code>-Methode, der auf Gleichheit von <code>this.props.increase === prevProps.increase</code> prüft, würde somit stets <code>false</code> ergeben und ggf. ein Re-Rendering einer Komponente veranlassen, auch wenn sich die Funktion an sich nicht geändert hat. Dies ist ein potentielles <strong>Performance-Bottleneck</strong> und sollte daher möglichst vermieden werden!</p>
<h4 id="method-binding-im-constructor">Method-Binding im Constructor</h4>
<p>Eine andere, sauberere Möglichkeit eine Methode an eine Klassen-Instanz zu binden ist, dies im Constructor bei der Instanziierung einer Klasse zu tun.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props);
    <span class="hljs-keyword">this</span>.increase = <span class="hljs-keyword">this</span>.increase.bind(<span class="hljs-keyword">this</span>);
  }
  <span class="hljs-comment">// […]</span>
}</code></pre>
<p>Auf diesem Weg wird die Methode nur <strong>einmal</strong> an die Instanz gebunden. Ein eventueller Check auf Gleichheit von Methoden würde also <code>true</code> ergeben und unnötige Re-Renderings könnten bei der Verwendung sinnvoller <code>shouldComponentUpdate()</code>-Checks vermieden werden. Allerdings bringt dieser Weg auch eine ganze Menge Overhead mit sich. Vorausgesetzt wir nutzen nicht ohnehin bereits einen Constructor, müssen wir diesen nun implementieren. Dazu sollten wir die <code>super(props);</code> Methode aufrufen um die <strong>Props</strong> der Komponente an die <code>React.Component</code> Eltern-Klasse zu übergeben. Letztendlich schreiben wir noch zweimal den Namen der Methode die wir binden wollen indem wir sie sozusagen mit der an <code>this</code> gebundenen Version von sich selbst überschreiben.</p>
<p>Das ist dennoch schon mal besser als die erste Methode, auch wenn es mehr Schreibarbeit ist, da wir uns potentielle Performance-Bottlenecks ersparen. Aber es gibt noch eine weitere, einfache Möglichkeit um mit minimalem Mehraufwand eine Methode an eine Instanz zu binden.</p>
<h4 id="benutzung-von-class-properties">Benutzung von Class Properties</h4>
<p><strong>Achtung:</strong> dieser Weg setzt die Verwendung des Babel-Plugins <code>@babel/plugin-proposal-class-properties</code> voraus. Da dies jedoch wie bereits in der Einleitung beschrieben in den meisten React-Setups zum Standard gehört, gehe ich also davon aus, dass <strong>Class Properties</strong> genutzt werden können. ist dies nicht der Fall, sollten Event-Handler-Methoden immer im Constructor gebunden werden!</p>
<p>Aber wie binden wir jetzt unsere Methode indem wir <strong>Class Properties</strong> nutzen? Streng genommen: indem wir schummeln! Statt eine echte Klassen-Methode zu implementieren wie im Eingangsbeispiel, definieren wir eine <strong>Public Class Property</strong> die als Wert eine per <strong>Arrow Function</strong> an die jeweilige Klasse gebundene Function zugewiesen bekommt. Das sieht dann wie folgt aus:</p>
<pre><code class="hljs jsx language-jsx">increase = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({
    <span class="hljs-attr">counter</span>: state.counter + <span class="hljs-number">1</span>,
  }));
};</code></pre>
<p>Der entscheidende Faktor liegt hier in der ersten Zeile. Statt:</p>
<pre><code class="hljs jsx language-jsx">increase() { … }</code></pre>
<p>Schreiben wir:</p>
<pre><code class="hljs jsx language-jsx">increase = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { … }</code></pre>
<p><strong>Problem gelöst!</strong></p>
<p>Der Unterschied liegt hier wie erwähnt darin, dass wir im ersten Beispiel eine <strong>echte Klassen-Methode</strong> implementieren und im zweiten Fall stattdessen einer gleichnamigen Eigenschaft dieser Klasse eine <strong>Arrow Function als Wert</strong> zuweisen. Da diese kein eigenes <code>this</code> bindet, greifen wir in dieser auf das <code>this</code> der Klassen-Instanz zu.</p>
<h3 id="events-außerhalb-des-komponenten-kontexts">Events außerhalb des Komponenten-Kontexts</h3>
<p>Die Verwendung von React schließt auch die Implementierung von nativen Browser-Events nicht aus. Allerdings sollte nach Möglichkeit immer das React eigene Event-System verwendet werden, da dieses Cross-Browser-Kompatibilität mitbringt, nach dem W3C Standard für Browser-Events arbeitet und zahlreiche Optimierungen vornimmt.</p>
<p>Gelegentlich ist es jedoch notwendig Events außerhalb des Komponenten-Kontexts zu definieren. Ein Klassisches Beispiel sind <code>window.onresize</code> oder <code>window.onscroll</code> Events. Hier bietet React keine Möglichkeit von Haus aus um globale Events außerhalb des Komponenten spezifischen JSX zu definieren. Hier ist dann die <code>componentDidMount()</code>-Methode der richtige Ort um diese zu definieren. Dabei sollte allerdings auch stets darauf geachtet werden, dass Events die mittels <code>addEventListener()</code> definiert werden <strong>immer auch entfernt werden!</strong></p>
<p>Der richtige Ort <strong>dafür</strong> ist dann die <code>componentWillUnmount()</code>-Methode. Werden eigene definierte globale Events nicht entfernt, werden diese mit jedem Mounting einer Komponente <strong>erneut</strong> hinzugefügt und auch erneut <strong>mehrmals</strong> aufgerufen, was letztendlich ebenfalls zu <strong>Performance-Bottlenecks</strong> und sogar zu <strong>Memory-Leaks</strong> führen kann.</p>
<h3 id="arbeiten-mit-dem-syntheticevent-objekt">Arbeiten mit dem <code>SyntheticEvent</code> Objekt</h3>
<p><strong>React übergibt Event-Handlern kein natives Event-Objekt</strong> sondern ein eigenes Objekt vom Typ <code>SyntheticEvent</code>. Dies dient insbesondere dazu, Cross-Browser-Kompatibles Verhalten zu gewährleisten. React hält den originalen Event aber in der Objekt-Eigenschaft <code>nativeEvent</code> bereit. Sollte also jemals der Bedarf bestehen auf den Original-Event zuzugreifen (ist mir bisher noch nie passiert): ihr findet ihn in der <code>e.nativeEvent</code> Eigenschaft.</p>
<p>Das <code>SyntheticEvent</code>-Objekt hat aber noch eine weitere Besonderheit im Vergleich mit dem nativen Event-Objekt, denn es ist <strong>kurzlebig</strong>. Aus Performance-Gründen wird das Objekt <strong>nullified</strong> nach dem Aufruf des Event-Callbacks, also kurz gesagt: es wird zurückgesetzt auf den Ausgangszustand. Ein Zugriff auf Eigenschaften des Event-Objekts außerhalb des originalen Event-Handlers ist daher nicht ohne Weiteres möglich.</p>
<p>Was bedeutet das? Nun, folgendes Beispiel:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextRepeater</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {};

  handleChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> ({
      <span class="hljs-attr">value</span>: e.target.value,
    }));
  };

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{this.handleChange}</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{this.state.value}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    );
  }
}</span></code></pre>
<p>Wir registrieren einen <code>onChange</code>-Event, der bei einer Änderung im Textfeld den eingegebenen Wert in einem Paragraphen unter dem Textfeld wieder ausgibt. Um im Event-Handler auf den eingegebenen Wert zuzugreifen, das kennt ihr möglicherweise bereits aus nativem JavaScript oder von jQuery-Events, Stelle das <code>Event</code>-Objekt die Eigenschaft <code>target</code> bereit. Damit bekommen wir das Element, auf dem der Event stattgefunden hat, in unserem Beispiel also das Textfeld. Dieses wiederum besitzt eine <code>value</code> Eigenschaft mittels der wir dann auf den aktuellen Wert des Textfelds zugreifen, um diesen in unseren State zu schreiben.</p>
<p>Hier haben wir aber nun mit einem Fallstrick zu tun: der <code>this.setState()</code>-Aufruf nutzt eine <strong>Updater-Funktion</strong>, also einen Callback. Dieser findet außerhalb des eigentlichen Event-Handler Scopes statt. Das bedeutet der <code>SyntheticEvent</code> wurde zu diesem Zeitpunkt bereits wieder zurückgesetzt und <code>e.target</code> existiert zum Zeitpunkt des Aufrufs der Updater-Funktion schon gar nicht mehr:</p>
<div class="hint hint--danger">
<p><strong>TypeError</strong></p>
<p>Cannot read property 'value' of null</p>
</div>
<p>Die einfachste Lösung wäre hier statt der Updater-Funktion ein Object-Literal zu verwenden:</p>
<pre><code class="hljs jsx language-jsx">handleChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">this</span>.setState({
    <span class="hljs-attr">value</span>: e.target.value,
  });
};</code></pre>
<p>Damit wäre unser Problem in dem Fall zwar gelöst, das hilft uns aber trotzdem nicht sonderlich weiter. Denn auf das gleiche Problem stoßen wir auch, wenn wir auf Eigenschaften des <code>SyntheticEvent</code>-Objekts bspw. in einem <code>setTimeout()</code>-Callback zugreifen wollen. Wir müssen uns also etwas anderes einfallen lassen.</p>
<h4 id="werte-in-variablen-schreiben">Werte in Variablen schreiben</h4>
<p>In den meisten Fällen sollte es ausreichen wenn einzelne Werte, auf die später im Callback zugegriffen werden, soll in eine Variable geschrieben werden. Im Callback wird dann nicht mehr auf den <code>SyntheticEvent</code> zugegriffen sondern lediglich auf die Variable, die einen Wert aus dem <code>SyntheticEvent</code> zugewiesen bekommen hat.</p>
<pre><code class="hljs jsx language-jsx">handleChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> value = e.target.value;
  <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
    <span class="hljs-attr">value</span>: value,
  }));
};</code></pre>
<p>Klappt. Bonuspunkte für Eleganz gibt es bei der Verwendung von <strong>Object Destructuring</strong> und dem <strong>Object Property Shorthand</strong>:</p>
<pre><code class="hljs jsx language-jsx">handleChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { value } = e.target;
  <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({ value }));
};</code></pre>
<h4 id="persistieren-von-syntheticevents-mittels-epersist">Persistieren von <code>SyntheticEvents</code> mittels <code>e.persist()</code></h4>
<p>Theoretisch möglich, in der Praxis aus meiner Erfahrung eher irrelevant: das <code>SyntheticEvent</code>-Objekt stellt eine eigene Methode <code>persist()</code> bereit, mit der eine Referenz zum entsprechenden Event beibehalten (also persistiert) werden kann. Ein möglicher Anwendungsfall wäre hier, das gesamte <code>SyntheticEvent</code>-Objekt an eine Callback-Funktion <strong>außerhalb</strong> des Event-Handlers weiterzugeben.</p>
<p>Sollte das jedoch notwendig sein, lohnt es sich aber womöglich darüber nachzudenken ob der Code der externen Callback-Funktion nicht besser im Event-Handler selbst besser aufgehoben wäre. Unsere Beispielfunktion von oben sieht in diesem Fall so aus:</p>
<pre><code class="hljs jsx language-jsx">handleChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  e.persist();
  <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
    <span class="hljs-attr">value</span>: e.target.value,
  }));
};</code></pre>
<p>Zuerst rufen wir besagte <code>e.persist()</code>-Methode auf. Anschließend können wir auch in der <strong>Updater-Funktion</strong> sorglos auf <code>e.target</code> und dessen <code>value</code>-Eigenschaft zugreifen.</p>
<h3 id="fazit">Fazit</h3>
<div class="hint hint--info">
<ul>
<li>Zum Definieren von Events möglichst <strong>immer</strong> die Event-Props im JSX verwenden: <code>onChange</code>, <code>onMouseOver</code>, <code>onTouchStart</code>, <code>onKeyDown</code>, <code>onAnimationStart</code> usw.</li>
<li>Event-Handler müssen an die Klassen-Instanz gebunden werden. Der eleganteste Weg hierfür sind <strong>Public Class Properties</strong> und <strong>Arrow Functions</strong></li>
<li>Eigene Events über die <code>addEventListener()</code>-API zu definieren sollte möglichst vermieden werden. Lässt es sich einmal nicht vermeiden, unbedingt daran denken diese Events beim Unmounting der Komponente mittels <code>removeEventListener()</code> zu entfernen!</li>
<li><code>SyntheticEvent</code>-Objekte werden nullified. Vorsicht bei der Verwendung in Callback-Funktionen außerhalb des jeweiligen Event-Handlers!</li>
</ul>
</div>
</div><div class="chapter">
<h1 id="formulare">Formulare</h1>
<p>Formulare besitzen in React eine kleine Sonderstellung und funktionieren etwas anders als andere DOM-Elemente, da Formulare eine Art <strong>eigenen State</strong> besitzen, der erst einmal nichts mit dem React-State gemein hat.</p>
<p>Der State von Textfeldern besteht bspw. aus dem eingegebenen Wert, der State von Checkboxen oder Radio-Buttons resultiert aus der Tatsache ob diese ausgewählt sind oder nicht, Auswahllisten (<code>&lt;select&gt;&lt;/select&gt;</code>) halten als State den ausgewählten Wert bzw. bei Mehrfachauswahl die ausgewählten Werte. React ändert an diesem Verhalten grundsätzlich erstmal nichts. Wer möchte, kann das so beibehalten und muss sich um nichts weiter kümmern.</p>
<p>Im React-Jargon ist dann die Rede von <strong>Uncontrolled Components</strong>, also <strong>unkontrollierten Komponenten</strong>. Unkontrolliert deshalb, weil React sich nicht um das State-Management dieser Komponenten kümmert. Das State-Handling ist entweder vollständig unabhängig von React oder funktioniert nur aus Richtung der DOM Formular-Elemente hin zum React State, jedoch <strong>nicht in die entgegengesetzte Richtung</strong>. Von einem Update am React-State bekommt ein Formular-Element also nichts mit und zeigt weiter den gleichen Wert (oder Status bei Checkboxen, Selects und Radiobuttons) wie zuvor.</p>
<p>Demgegenüber stehen die <strong>Controlled Components</strong>, also <strong>kontrollierte Komponenten</strong>. Hier aktualisiert ein Update am React-State den Wert (oder Status) des Formular-Elements und ebenso aktualisiert ein Update am jeweiligen Formular-Element den React-State. <strong>Controlled Components</strong> sind etwas aufwändiger in der Implementierung, sind zugleich jedoch auch die „sicherere“ Variante, da wir nicht Gefahr laufen, dass beide States voneinander abweichen.</p>
<h2 id="uncontrolled-components--unkontrollierte-komponenten">Uncontrolled Components / unkontrollierte Komponenten</h2>
<p><strong>Unkontrollierte Komponenten</strong> können dabei im Wesentlichen in zwei verschiedenen Formen auftreten. Bei der ersten Variante werden einfach nur Formular-Elemente gerendert, die beim Abschicken bspw. rein serverseitig verarbeitet werden und in keiner Weise mit React interagieren. Ein komplett statisches Formular wenn man so will. React kümmert sich dabei <strong>nicht von alleine</strong> um die Anbindung an den React-State sondern <strong>lässt dem Entwickler hier sämtliche Freiheiten</strong>!</p>
<p>Bei der zweiten Variante werden Änderungen an einem Formular-Element <strong>in den React-State</strong> geschrieben um bspw. im Hintergrund eine Validierung der Daten vorzunehmen oder die eingegebenen Daten an anderer Stelle auszugeben. Eine Änderung am React-State an anderer Stelle der Anwendung hat dabei keinerlei direkten Einfluss auf die Formularfelder.</p>
<p>Ein Beispiel für eine solche unkontrollierte Komponente:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Uncontrolled</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">username</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">isValid</span>: <span class="hljs-literal">false</span>,
  };

  changeUsername = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> { value } = e.target;
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      <span class="hljs-attr">username</span>: value,
      <span class="hljs-attr">isValid</span>: value.length &gt; <span class="hljs-number">3</span>,
    }));
  };

  submitForm = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    e.preventDefault();
    alert(<span class="hljs-string">`Hallo <span class="hljs-subst">${<span class="hljs-keyword">this</span>.state.username}</span>`</span>);
  };

  render() {
    <span class="hljs-keyword">return</span> (
      &lt;form method="post" onSubmit={this.submitForm}&gt;
        &lt;p&gt;Dein Benutzername: {this.state.username}&lt;/p&gt;
        &lt;p&gt;
          &lt;input type="text" name="username" onChange={this.changeUsername} /&gt;
          &lt;input type="submit" disabled={!this.state.isValid} /&gt;
        &lt;/p&gt;
      &lt;/form&gt;
    );
  }
}</code></pre>
<p>Hier sehen wir ein einfaches Textfeld in das der Benutzer einen gewünschten Benutzernamen eintragen kann. Die <code>Uncontrolled</code> Komponente wird mittels <code>onChange</code>-Event von jeder Änderung in Kenntnis gesetzt und kann den Benutzernamen weiterverarbeiten. Da React hier nur <strong>passiv</strong> agiert, also bei einer Änderung am Textfeld über den neuen Wert in Kenntnis gesetzt wird, bewegen wir uns immer noch im Bereich der <strong>Uncontrolled Components</strong>.</p>
<p>Dies ist in einigen Fällen ausreichend, insbesondere wenn die Formulare noch nicht all zu komplex sind. Allerdings ist der React-State hier vom DOM State <strong>entkoppelt</strong> bzw. funktioniert nur <strong>in eine Richtung</strong>. Der React State wird aktualisiert sobald der <code>onChange</code>-Event des Textfelds ausgelöst wird. Allerdings bedeutet dies, dass nicht gleichzeitig auch unser Textfeld aktualisiert wird wenn der Wert im React State an anderer Stelle verändert wurde, bspw. weil der Response eines asynchronen Requests nach einiger Zeit eintrifft.</p>
<p>Ein Formularfeld gilt als <strong>kontrolliert</strong>, sobald ein <code>value</code>-Attribut gesetzt wird. Ab diesem Moment erwartet React, dass wir uns als Entwickler selbst darum kümmern den React-State mit dem Formularfeld zu synchronisieren. Möchten wir allerdings nur einmalig einen initialen Wert setzen ohne gleich die ganze Komponente zu einer <strong>Controlled Component</strong> zu machen, haben wir die Möglichkeit statt des <code>value</code>-Attributs das React eigene <code>defaultValue</code>-Attribut zu setzen (<code>defaultChecked</code> bei Checkboxen und Radiobuttons). Das Element bleibt dann weiterhin <strong>unkontrolliert</strong>, zeigt aber dennoch einen vorausgefüllten Wert (bzw. Status) an.</p>
<h2 id="controlled-components--kontrollierte-komponenten">Controlled Components / kontrollierte Komponenten</h2>
<p>Um sowohl State-Updates in Formularfeldern zu abzubilden als auch auf der anderen Seite benutzerseitige Änderungen an Formularfeldern in den React-State zu übertragen, benötigen wir eine <strong>Controlled Component</strong>. Hier überlassen wir das State-Handling eines Formular-Elements vollständig React. Dies bedeutet, dass wir das <code>value</code>-Attribut mit einem Wert befüllen den wir aus dem React-State beziehen und gleichzeitig auch einen geänderten Wert wieder zurück in den React-State überführen.</p>
<p>Das Ziel bei diesem Ansatz ist es, den React-State (oder einen anderen State-Container wie z.B. Redux) als <strong>Single Source of Truth</strong> zu betrachten, also als die <em>einzige Quelle der Wahrheit</em>. Relevant ist der Wert der im von React verwalteten State steht, das jeweilige Eingabefeld reflektiert dann zu jedem Zeitpunkt den Wert aus diesem State.</p>
<p>Schauen wir uns auch hierzu mal ein Beispiel an:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Controlled</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">username</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">isValid</span>: <span class="hljs-literal">false</span>,
  };

  changeUsername = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> { value } = e.target;
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      <span class="hljs-attr">username</span>: value,
      <span class="hljs-attr">isValid</span>: value.length &gt; <span class="hljs-number">3</span>,
    }));
  };

  submitForm = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    e.preventDefault();
    alert(<span class="hljs-string">`Hallo <span class="hljs-subst">${<span class="hljs-keyword">this</span>.state.username}</span>`</span>);
  };

  render() {
    <span class="hljs-keyword">return</span> (
      &lt;form method="post" onSubmit={this.submitForm}&gt;
        &lt;p&gt;{username}&lt;/p&gt;
        &lt;p&gt;
          &lt;input
            type="text"
            name="username"
            onChange={this.changeUsername}
            value={this.state.username}
          /&gt;
          &lt;input type="submit" disabled={!this.state.isValid} /&gt;
        &lt;/p&gt;
      &lt;/form&gt;
    );
  }
}</code></pre>
<p>Auf den ersten Blick unterscheidet sich die <code>Controlled</code> Komponente gar nicht sonderlich von der <code>Uncontrolled</code> Komponente im Absatz oben. Und tatsächlich ist der entscheidende Faktor der die unkontrollierte Komponente zu einer kontrollierten werden lässt einzig und allein das <code>value</code>-Attribut des <code>&lt;input /&gt;</code>-Elements. Ist ein solches vorhanden <strong>kontrolliert</strong> React das Formular-Element und erwartet, dass sich Änderungen am Eingabefeld entsprechend im State widerspiegeln. Wichtig ist außerdem der <code>onChange</code>-Handler, um den Wert bei einer Änderung jeweils in den React-State zu übertragen. Ein gern gemachter Fehler wenn das erste Mal mit Formularen in React gearbeitet wird ist, entsprechende Eingabefelder nicht mit dem React-State zu synchronisieren indem der neue Wert in den State geschrieben wird. Das Eingabefeld verändert sich dann nicht und zeigt weiterhin den alten Wert aus <code>this.state</code> an.</p>
<p>Hier gibt es noch einige weitere Dinge zu beachten. So darf der Wert des <code>value</code>-Attributes immer nur ein <strong>String</strong> sein, niemals <code>undefined</code> oder <code>null</code>.</p>
<p class="has-image"><span><img src="../.gitbook/assets/react-uncontrolled-null.png" alt="Warnung bei einem kontrollierten Textfeld mit dem value &quot;null&quot;" /><span class="caption">Warnung bei einem kontrollierten Textfeld mit dem value &quot;null&quot;</span></span></p>
<p>Eine Ausnahme sind hier <code>select</code>-Elemente die ein <code>multiple</code>-Attribut besitzen. Hier <strong>muss</strong> das <code>value</code>-Attribut ein <strong>Array</strong> sein.</p>
<p>Moment mal, denkt ihr euch jetzt vielleicht. Welches <code>value</code>-Attribut beim <code>&lt;select&gt;</code>? Optionen selektiere ich doch, indem ich das <code>selected</code>-Attribut bei der jeweiligen <code>&lt;option&gt;</code> setze! Und ja, das ist korrekt in HTML, in React funktioniert das ein klein wenig anders. Hier wird der kontrollierte Wert ebenfalls über das <code>value</code>-Attribut gesetzt. Dasselbe gilt übrigens auch für das <code>&lt;textarea&gt;</code>-Element, dessen Initialwert für gewöhnlich durch seinen <code>textContent</code> bestimmt wird. Nicht so in React.</p>
<p>React vereinheitlicht hier den Mechanismus zum ändern von Werten etwas und erfordert für die drei Elemente <code>input</code> (alle Typen mit Ausnahme <code>checkbox</code> und <code>radio</code>), <code>textarea</code> und <code>select</code> ein <code>value</code>-Attribut! Bei einfachen Werten muss dies <strong>immer ein String</strong> sein, bei einer Auswahlliste mit dem <code>multiple</code>-Attribut wie eben erwähnt ein <strong>Array bestehend aus Strings</strong>!</p>
<p>Darüber hinaus muss eine Änderung eines Formular-Elements <strong>immer auch zurück in den React-State übertragen werden</strong>. Dies kann mitunter etwas mühsam werden, insbesondere bei Checkboxen und Radiobuttons, bei denen nicht lediglich ein Wert geändert wird sondern der Status (<code>checked</code>) zu einem Wert.</p>
<p>Im folgenden möchte ich eine vollständig kontrollierte Komponente zeigen, die alle Grundtypen von Formular-Elementen die HTML beinhaltet (andere <code>input</code>-Elemente vom vom Typ <code>email</code>, <code>date</code>, <code>range</code>, etc. funktionieren identisch wie Eingabefelder vom Typ <code>text</code>).</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FullyControlledComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">text</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">textarea</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">checkbox</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">singleSelect</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">multipleSelect</span>: [],
  };

  changeValue = <span class="hljs-function">(<span class="hljs-params">{ target: { name, value } }</span>) =&gt;</span> {
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      [name]: value,
    }));
  };

  changeCheckbox = <span class="hljs-function">(<span class="hljs-params">{ target: { name, checked } }</span>) =&gt;</span> {
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      [name]: checked,
    }));
  };

  changeSelect = <span class="hljs-function">(<span class="hljs-params">{ target: { name, value, selectedOptions, multiple } }</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (multiple) {
      value = <span class="hljs-built_in">Array</span>.from(selectedOptions).map(<span class="hljs-function">(<span class="hljs-params">option</span>) =&gt;</span> option.value);
    }

    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      [name]: value,
    }));
  };

  render() {
    <span class="hljs-keyword">return</span> (
      &lt;form&gt;
        &lt;input
          type="text"
          name="text"
          value={this.state.text}
          onChange={this.changeValue}
        /&gt;

        &lt;textarea
          name="textarea"
          value={this.state.textarea}
          onChange={this.changeValue}
        /&gt;

        &lt;input
          type="checkbox"
          name="checkbox"
          checked={this.state.checkbox}
          onChange={this.changeCheckbox}
        /&gt;

        &lt;input
          type="radio"
          name="radio"
          value="1"
          checked={this.state.radio === '1'}
          onChange={this.changeValue}
        /&gt;
        &lt;input
          type="radio"
          name="radio"
          value="2"
          checked={this.state.radio === '2'}
          onChange={this.changeValue}
        /&gt;

        &lt;select
          name="singleSelect"
          value={this.state.singleSelect}
          onChange={this.changeValue}
        &gt;
          &lt;option value=""&gt;Bitte auswählen&lt;/option&gt;
          &lt;option value="1"&gt;One&lt;/option&gt;
          &lt;option value="2"&gt;Two&lt;/option&gt;
        &lt;/select&gt;

        &lt;select
          name="multipleSelect"
          value={this.state.multipleSelect}
          onChange={this.changeSelect}
          multiple
        &gt;
          &lt;option value="1"&gt;One&lt;/option&gt;
          &lt;option value="2"&gt;Two&lt;/option&gt;
        &lt;/select&gt;

        &lt;pre&gt;{JSON.stringify(this.state, null, 2)}&lt;/pre&gt;
      &lt;/form&gt;
    );
  }
}</code></pre>
<p>Kern des Formulars sind erst einmal die drei Event-Handler Methoden für die verschiedenen Formular-Element Typen: <code>changeValue</code>, <code>changeCheckbox</code> und <code>changeSelect</code>.</p>
<p>Sie werden jeweils beim onChange-Event der jeweiligen Formular-Elemente aufgerufen und bekommen ein Objekt vom Typ <code>SyntheticEvent</code> übergeben. Aus dessen <code>target</code>-Eigenschaft picken wir uns mittels <strong>ES2015 Object Destructuring</strong> wiederum einzelne Eigenschaften heraus um damit anschließend den State entsprechend zu aktualisieren.</p>
<p>Bei Elementen vom Typ <code>&lt;input type="text" /&gt;</code>, <code>&lt;input type="radio" /&gt;</code> und <code>&lt;textarea /&gt;</code> sind das <code>name</code>und <code>value</code>, bei <code>&lt;input type="checkbox" /&gt;</code> interessiert uns der <code>name</code> und die <code>checked</code>-Eigenschaft, bei <code>select</code>-Elementen interessiert uns in jedem Fall auch der <code>name</code> und dann, abhängig davon ob es eine einfache Auswahlliste ist oder eine Auswahlliste mit Mehrfachauswahl, wieder der <code>value</code>oder die <code>selectedOptions</code>. Ob wir eine es mit einer einfachen oder mehrfachen Auswahlliste zu tun haben finden wir mittels der <code>multiple</code>-Eigenschaft heraus, die wir uns ebenfalls aus der <code>e.target</code>-Eigenschaft herauspicken.</p>
<h3 id="veränderung-von-werten">Veränderung von Werten</h3>
<p>Wird ein Wert verändert, wie es bei Text-Eingabe oder Radiobuttons der Fall ist, setzen wir eine gleichnamige State-Eigenschaft auf den jeweiligen Wert, den der Benutzer eingegeben hat und mit dem er den <code>onChange</code>-Event getriggert hat. Da wir uns in einer kontrollierten Komponente befinden, funktioniert nun folgendes:</p>
<ol>
<li>Der Benutzer ändert mittels Texteingabe den Wert</li>
<li>Ein <code>onChange</code>-Event wird ausgelöst und im Event-Handler verarbeitet</li>
<li>Der Event-Handler setzt die State-Eigenschaft auf den neuen Wert</li>
<li>React re-rendert das User Interface und setzt die <code>value</code>-Eigenschaft des Eingabefelds auf den neuen Wert aus <code>this.state</code>.</li>
<li>Der Benutzer sieht seinen neu eingegebenen Wert.</li>
</ol>
<p>Für den Benutzer ist dies erstmal <strong>Business as Usual</strong>. Er bemerkt nicht, dass das Formular anders funktioniert als er das aus dem Browser kennt. Und doch hat sich hier React um die Logik im Hintergrund gekümmert und einen neuen „Frame“ im User Interface gezeichnet.</p>
<h3 id="veränderung-von-zuständen-bei-checkboxen-und-radiobuttons">Veränderung von Zuständen bei Checkboxen und Radiobuttons</h3>
<p>Checkboxen (<code>&lt;input type="checkbox" /&gt;</code>) funktionieren hier vom Ablauf im Hintergrund genauso, allerdings mit dem Unterschied das ihr Wert grundsätzlich gleich bleibt. Bei Checkboxen ändert sich statt des Werts der Zustand ihrer <code>checked</code>-Eigenschaft von <code>true</code> auf <code>false</code> oder andersherum. Sie gelten daher dann als kontrolliert, wenn ihre <code>checked</code>-Eigenschaft durch React gesteuert wird. Der <code>onChange</code>-Event bei Checkboxen teilt uns mittels <code>e.target.checked</code> mit, ob die eben geänderte Checkbox nun aktiviert (<code>true</code>) oder nicht aktiviert (<code>false</code>) ist. Diesen Status geben wir unverändert an den React-State weiter, React kümmert sich dann im Re-Rendering darum, dass der neue Status der Checkbox angezeigt wird.</p>
<p>Radiobuttons sind eine Art Hybrid-Element. Sie gelten wie Checkboxen ebenfalls als kontrolliert wenn ihr <code>checked</code>-Attribut durch React verwaltet wird. Allerdings gibt es für gewöhnlich mehrere Radiobuttons mit dem selben Namen, allerdings mit unterschiedlichen Werten in einem Dokument. Hier würde es also keinen Sinn machen den Wert zu einem Namen auf <code>true</code> oder <code>false</code> zu setzen, da uns der tatsächliche Wert des ausgewählten Radiobuttons interessiert. Hier schreiben wir also wie bei Text-Elementen den Wert des Radiobuttons in den State und prüfen dann beim Rendering des jeweiligen Radiobuttons selbst, ob der ausgewählte Wert aus dem State dem eigenen Wert entspricht: <code>checked={this.state.radio === "1"}</code>. Also in diesem Beispiel: setze <code>checked</code> auf <code>true</code> wenn der Wert eines Radiobuttons mit dem Namen <code>radio</code> gleich <code>1</code> ist.</p>
<h3 id="veränderung-des-status-bei-einfachen-oder-mehrfachen-auswahllisten">Veränderung des Status bei einfachen oder mehrfachen Auswahllisten</h3>
<p>Fangen wir mit dem einfachen Fall an: einfache <code>&lt;select&gt;</code>-Auswahllisten ändern ebenfalls wie Textfelder ihren Wert, lösen damit ein Re-Rendering aus und zeigen den ausgewählten Wert im neu gezeichneten User Interface an. Eine Ausnahme stellen hier mehrfache Auswahllisten dar.</p>
<p>Mehrfache Auswahllisten erwarten anders als Textfelder oder einfache Auswahllisten keinen String als Wert, sondern ein <strong>Array aus Strings</strong>. Diesen müssen wir uns allerdings selbst zusammenbasteln, da <code>e.target.value</code> bei Mehrfach-Auswahllisten nur einen einzigen Wert enthält, selbst bei der Auswahl mehrerer Optionen. Hier hilft uns <code>e.target.selectedOptions</code> weiter. Diese Eigenschaft ist ein Objekt vom Typ <code>HTMLCollection</code>, mit den <code>&lt;option&gt;</code>-Elementen die momentan ausgewählt sind. Dieses Objekt können wir mit der statischen Array-Methode <code>Array.from()</code> aus ES2015 ziemlich einfach in ein Array umwandeln. Indem wir mittels <code>Array.map()</code> über dieses iterieren, können wir außerdem ein neues Array erzeugen, das alle für uns relevanten Werte enthält: <code>Array.from(selectedOptions).map((option) =&gt; option.value);</code></p>
<p>Das so erzeugte, neue Array schreiben wir dann als neuen Wert in unseren State. Zuvor schauen wir jedoch erst einmal mittels e.target.multiple ob es sich überhaupt um ein <code>&lt;select&gt;</code> mit Mehrfachauswahl handelt, da nur dieses ein Array als <code>value</code> erwartet.</p>
<p>Alternativ wäre es natürlich auch möglich einfachen Auswahllisten die <code>changeValue</code>-Methode als Event-Handler zu übergeben und nur Mehrfach-Auswahllisten die <code>changeSelect</code>-Methode. Dann könnten wir uns in selbiger den Check sparen ob es sich um ein <code>multiple</code> Select handelt. Es auf die obigen Weise zu lösen hat aber den Vorteil, dass später der Typ von mehrfach auf einfach geändert werden könnte ohne dass man zusätzlich noch den Event-Handler ändern muss. Aber das bleibt am Ende natürlich euch selbst überlassen.</p>
<h3 id="besonderheiten-bei-kontrollierten-komponenten">Besonderheiten bei kontrollierten Komponenten</h3>
<p>Ich habe in den obigen Beispielen jeweils das <code>name</code>-Attribut der jeweiligen Elemente als Schlüssel benutzt um deren Wert im State zu speichern. Das ist insbesondere dann praktisch wenn man mit serverseitigem React arbeitet und bspw. Formulare auf Basis eines Datenbankschemas automatisch generiert und wieder verarbeitet. Voraussetzung für eine funktionierende kontrollierte Komponente ist das aber nicht. Es wird theoretisch weder ein <code>name</code>-Attribut benötigt noch muss schlussendlich der Name der State-Eigenschaft mit dem <code>name</code>-Attribut übereinstimmen.</p>
<p>Ihr könnt die gespeicherten Werte auch verschachteln, was sich anbietet wenn ihr in einer Komponente mehrere Formulare haben solltet (<strong>Achtung:</strong> React Antipattern!). Darüber hinaus muss nicht einmal zwingend der React-State verwendet werden um <strong>Controlled Components</strong> abzubilden. Im Gegenteil, in der Praxis wird stattdessen oftmals auch auf einen externen State-Container wie <strong>Redux</strong>, <strong>Unstated</strong> oder <strong>MobX</strong> zurückgegriffen.</p>
<h2 id="fazit">Fazit</h2>
<div class="hint hint--success">
<p>Formulare in React können in (von React) kontrollierter oder unkontrollierter Form auftreten.</p>
<p><strong>Unkontrollierte Komponenten</strong> reichen für simple Formulare oftmals aus, allerdings empfiehlt es sich, Formular-Komponenten von React kontrollieren zu lassen um eine <strong>Single Source of Truth</strong> zu haben. Dazu muss das <code>value</code> bzw. <code>checked</code>-Attribut von React verwaltet werden. Auf Entwicklerseite muss dann manuell auf Änderungen reagiert werden.</p>
<p>Anders als in herkömmlichem HTML erwartet React den Wert von Textareas, Selects und Inputfeldern mit Texteingabe im <code>value</code>-Attribut.</p>
</div>
</div><div class="chapter">
<h1 id="listen-refs-fragments-und-conditional-rendering">Listen, Refs, Fragments und Conditional Rendering</h1>
<p>Bis hier her habt ihr schon eine ganze Menge über React erfahren. Ihr wisst wofür die <strong>Props</strong> sind, was der <strong>State</strong> ist und wie er sich von den <strong>Props</strong> unterscheidet, ihr wisst wie eine React-Komponente implementiert wird, was der Unterschied einer React-<strong>Komponente</strong> und einem React-<strong>Element</strong> ist und wie ihr mit <strong>JSX</strong> einen Elementenbaum beschreibt, der später in eurer Anwendung gerendert wird. <strong>Lifecycle-Methoden</strong> helfen euch auf Änderungen eurer Daten zu reagieren. Damit habt ihr auch schon alles beisammen um eine simple React-Anwendung zu entwickeln.</p>
<p>Allerdings gibt es noch einige Details, die in den vorherigen Kapiteln bisher gar keine Erwähnung fanden oder ohne weitere Erklärung in Beispielen benutzt wurden, die aber, gerade wenn eure Anwendung anfängt komplexer zu werden zunehmend relevanter werden.</p>
<p>Im Speziellen betrifft das die Arbeit mit <strong>Listen</strong>, also Arrays mit Daten, sogenannte <strong>Refs</strong>, damit sind Referenzen zu DOM-Repräsentationen von React-Elementen gemeint, <strong>Fragments</strong>, eine spezielle Art Komponente, die keine Spuren im gerenderten Output hinterlässt und <strong>Conditional Rendering</strong>, also Unterscheidungsmöglichkeiten, wann ihr was rendert, basierend auf <strong>Props</strong> und <strong>State</strong>.</p>
<p>Die Themen haben eins gemeinsam: sie sind zu wichtig um sie nicht im Grundlagenteil dieses Buchs zu erwähnen aber gleichzeitig zu kurz um ihnen jeweils ein komplettes eigenes Kapitel zu widmen.</p>
<h2 id="listen">Listen</h2>
<p>Mit Listen sind hier tatsächlich stumpfe JavaScript-Arrays gemeint, also einfache <strong>Daten</strong>, durch die iteriert werden kann. Sie sind bei der Arbeit nicht nur mit React alltäglich und keine Anwendung kommt ohne sie aus. <strong>ES2015+</strong> bietet uns mit <code>Array.map()</code>, <code>Array.filter()</code> oder <code>Array.find()</code> schöne deklarative Methoden, die wir als Ausdrücke in JSX innerhalb von geschweiften Klammern <code>{}</code> nutzen können.</p>
<p>Welche Rolle Ausdrücke in JSX spielen und wie wir Ausdrücke in JSX nutzen können, habe ich bereits im Kapitel über JSX angesprochen. Kurz aufgefrischt: Arrays können als Ausdruck in JavaScript genutzt werden und somit auch in JSX. Das heißt sie können in geschweiften Klammern stehen und werden dann von beim Transpiling von JSX als Child-Node behandelt.</p>
<p>Das ist aber noch nicht alles, denn <code>Array.map()</code> kann bspw. modifizierte Items zurückgeben, die selbst wiederum JSX beinhalten. Das ist insofern praktisch, als dass es uns weitere Flexibilität verschafft und es uns ermöglicht Datensammlungen in React-Elemente zu verwandeln.</p>
<p>Nehmen wir als Beispiel an, wir wollen eine Liste aus Cryptocurrencies anzeigen. Unser Array mit den entsprechenden Daten hat die folgende Form:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> cryptos = [
  {
    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Bitcoin'</span>,
    <span class="hljs-attr">symbol</span>: <span class="hljs-string">'BTC'</span>,
    <span class="hljs-attr">quotes</span>: { <span class="hljs-attr">EUR</span>: { <span class="hljs-attr">price</span>: <span class="hljs-number">7179.92084586</span> } },
  },
  {
    <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Ethereum'</span>,
    <span class="hljs-attr">symbol</span>: <span class="hljs-string">'ETH'</span>,
    <span class="hljs-attr">quotes</span>: { <span class="hljs-attr">EUR</span>: { <span class="hljs-attr">price</span>: <span class="hljs-number">595.218568203</span> } },
  },
  {
    <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Litecoin'</span>,
    <span class="hljs-attr">symbol</span>: <span class="hljs-string">'LTC'</span>,
    <span class="hljs-attr">quotes</span>: { <span class="hljs-attr">EUR</span>: { <span class="hljs-attr">price</span>: <span class="hljs-number">117.690716234</span> } },
  },
];</code></pre>
<p>Dargestellt werden sollen die Daten erst einmal als einfache ungeordnete Liste in simplen HTML. Die entsprechende Komponente könnte dann zum Beispiel so aussehen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> CryptoList = <span class="hljs-function">(<span class="hljs-params">{ currencies }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    {currencies.map((currency) =&gt; (
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>
          {currency.name} ({currency.symbol})
        <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{currency.quotes.EUR.price.toFixed(2)} €<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    ))}
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
);</code></pre>
<p>Und würde dann etwa so benutzt werden:</p>
<pre><code class="hljs jsx language-jsx">&lt;CryptoList currencies={cryptos} /&gt;</code></pre>
<p>Heraus kommt eine Liste mit den entsprechenden Kryptowährungen und ihrem jeweiligen Preis. Allerdings bekommen wir auch direkt eine Warnung von React an den Kopf geworfen:</p>
<p class="has-image"><span><img src="../.gitbook/assets/react-missing-key.png" alt="Fehlermeldung bei fehlender key-Prop in einer durch einen Iterator erzeugten Liste" /><span class="caption">Fehlermeldung bei fehlender key-Prop in einer durch einen Iterator erzeugten Liste</span></span></p>
<p>React erwartet bei allen Arrays und von einem Iterator zurückgegebenen Werten eine <code>key</code>-Prop. Diese dient dazu dem Reconciler (also dem React-Vergleichsalgorithmus) eine Möglichkeit zu geben, um Listen-Elemente zu identifizieren und letztendlich vergleichen zu können. Der Reconciler erkennt dadurch welche Array-Elemente hinzugefügt, entfernt oder modifiziert wurden. Die <code>key</code>-Prop nimmt dabei die Funktion einer eindeutigen ID ein und muss <strong>innerhalb dieses Arrays einmalig</strong> sein. In der Praxis wird hier typischerweise die ID eines Datensatzes verwendet.</p>
<p>In unserem Fall haben wir eine solche ID vorliegen, das oberste Element das aus der <code>map()</code>-Methode zurückgegeben wird würde also korrekt so aussehen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> CryptoList = <span class="hljs-function">(<span class="hljs-params">{ currencies }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    {currencies.map((currency) =&gt; (
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{currency.id}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>
          {currency.name} ({currency.symbol})
        <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{currency.quotes.EUR.price.toFixed(2)} €<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    ))}
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
);</code></pre>
<p>Der Key muss dabei nur <strong>innerhalb eines Arrays/Iterators inmitten seiner Geschwister-Elemente einmalig sein, nicht innerhalb der Komponente!</strong> Dies bedeutet, dass wir die gleiche <code>CryptoList</code>-Komponente mit den gleichen Keys an anderer Stelle, auch in der gleichen Komponente, problemlos noch ein zweites Mal verwenden könnten. Nur eben nicht innerhalb dieses einen Loops.</p>
<p>Sind zu einer Liste aus Datensätzen keine eindeutigen Schlüssel vorhanden, kann als letzter Ausweg der <strong>Index</strong> des Array-Elements verwendet werden. Davon wird jedoch <strong>ausdrücklich abgeraten</strong>, da dies zu Problemen bei der Performance sowie zu unvorhersehbarem Verhalten beim Rendering des User Interfaces führen kann.</p>
<p>Wichtig ist außerdem, dass die <code>key</code>-Prop immer <strong>direkt in der von der Iterator-Funktion</strong> zurückgegebenen <strong>Toplevel-Komponente</strong> oder dem <strong>Array-Element</strong> vorhanden sein muss, nicht in der von dieser Komponente zurückgegebenen JSX.</p>
<p>Um besser zu veranschaulichen was das genau bedeutet, machen wir aus unserem obigen Listen-Element eine eigene kleine <code>CryptoListItem</code>-Komponente:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> CryptoListItem = <span class="hljs-function">(<span class="hljs-params">{ name, symbol, quotes }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>
      {name} ({symbol})
    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{quotes.EUR.price.toFixed(2)} €<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
);</code></pre>
<p>Was fällt auf? Richtig: die <code>key</code>-Prop die wir zuvor hinzugefügt haben ist nun nicht mehr da. Unser <code>map()</code>-Aufruf würde sich dafür wie folgt verändern:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> CryptoList = <span class="hljs-function">(<span class="hljs-params">{ currencies }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    {currencies.map((currency) =&gt; (
      <span class="hljs-tag">&lt;<span class="hljs-name">CryptoListItem</span>
        <span class="hljs-attr">key</span>=<span class="hljs-string">{currency.id}</span>
        <span class="hljs-attr">name</span>=<span class="hljs-string">{currency.name}</span>
        <span class="hljs-attr">symbol</span>=<span class="hljs-string">{currency.symbol}</span>
        <span class="hljs-attr">quotes</span>=<span class="hljs-string">{currency.quotes}</span>
      /&gt;</span>
    ))}
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
);</span></code></pre>
<p>Obwohl es das <code>&lt;li&gt;&lt;/li&gt;</code>-Element ist welches letztendlich gerendert wird, muss dennoch die <code>&lt;CryptoListItem /&gt;</code>-Komponente die <code>key</code>-Prop bekommen, da sie es ist, die von <code>Array.map()</code> an der entsprechenden Stelle im JSX zurückgegeben wird.</p>
<p>Offtopic: die <code>CryptoList</code>-Komponente könnte durch Verwendung der <strong>Object-Spread Syntax</strong> weiter vereinfacht werden:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> CryptoList = <span class="hljs-function">(<span class="hljs-params">{ currencies }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    {currencies.map((currency) =&gt; (
      <span class="hljs-tag">&lt;<span class="hljs-name">CryptoListItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{currency.id}</span> {<span class="hljs-attr">...currency</span>} /&gt;</span>
    ))}
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
);</span></code></pre>
<p>Auf diese Art werden alle Eigenschaften des <code>currency</code>-Objekts entsprechend als gleichnamige Props an die <code>CryptoListItem</code>-Komponente übertragen.</p>
<p>Bei der direkten Arbeit mit Arrays, ohne einen Iterator wie <code>Array.map()</code> sähe das analog dazu so aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> MyList = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    {[<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"1"</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"2"</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"3"</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>]}
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
);</code></pre>
<h2 id="refs">Refs</h2>
<p><strong>Refs</strong> (also <strong>References/Referenzen</strong>) erlauben es in React direkt auf DOM-Elemente zuzugreifen, die während des Render-Prozesses erzeugt wurden. Auch wenn das in React eher ein Anti-Pattern ist, gibt es einige legitime Situationen in denen man nicht drumherum kommt, direkt auf die DOM-Elemente zuzugreifen. Etwa wenn die Position oder die Größe eines Elements benötigt wird, um basierend darauf bspw. ein Tooltip einzublenden oder um ein Eingabefeld mittels <code>.focus()</code> nach dem Laden einer Komponente zu fokussieren.</p>
<p>Hier hat sich React im Laufe der Zeit weiterentwickelt und hat uns so historisch bedingt verschiedene Möglichkeiten geschaffen um solche <strong>Refs</strong> zu erstellen. Die <strong>Refs</strong>, egal in welcher Form, werden dabei stets über die <code>ref</code>-Prop eines DOM-Elements im <strong>JSX</strong> bzw. <code>createElement()</code>-Aufruf definiert.</p>
<div class="hint hint--warning">
<p>Eine Warnung jedoch gleich noch vorweg: auch wenn React es erlaubt, durch die Verwendung von <strong>Refs</strong> direkt auf DOM-Elemente zuzugreifen, sollte dies <strong>immer der letzte Ausweg sein!</strong> Sämtliche Manipulation von Attributen oder Attribut-Werten, das Hinzufügen oder Entfernen bspw. von Klassen oder Event-Listenern oder das Ändern von anderen Eigenschaften wie <code>aria-hidden</code> sollte <strong>immer</strong> deklarativ über den <strong>State</strong>, <strong>JSX</strong> und entsprechende <strong>Re-Renderings</strong> realisiert werden!</p>
</div>
<h3 id="string-refs">String Refs</h3>
<p>Die simpelste und älteste Variante sind die sogenannten <strong>String Refs</strong>. Mittlerweile wird von der Nutzung eher abgeraten, da sie die Performance beeinträchtigen können und in Zukunft ggf. entfernt werden. Der Vollständigkeit halber möchte ich sie dennoch erwähnen, da sie noch Teil der offiziellen API sind und euch gelegentlich auch noch bei der Arbeit mit React begegnen werden, insbesondere wenn ihr mit Legacy-Code zu tun habt.</p>
<p>Um eine <strong>String Ref</strong> zu definieren, gebt ihr einem DOM-Element eine Prop mit dem Namen <code>ref</code> und weist dieser Prop einen <strong>String</strong> als Wert zu. Das enstprechende DOM-Element ist dann <strong>innerhalb der Komponente</strong> in der Instanz-Eigenschaft <code>this.ref</code> zugänglich.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponentWithStringRef</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  componentDidMount() {
    <span class="hljs-keyword">this</span>.refs.username.focus();
  }

  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> /&gt;</span>;
  }
}

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">ComponentWithStringRef</span> /&gt;</span>, document.getElementById('app'));</span></code></pre>
<p>Im obigen Beispiel können wir im <code>componentDidMount()</code> Lifecycle-Hook über <code>this.refs.wrapper</code> auf das umgebende div und über <code>this.refs.username</code> auf das Eingabefeld zugreifen. Über <code>this.refs.username.focus()</code> lässt sich letzteres dann bspw. fokussieren.</p>
<h3 id="callback-refs">Callback Refs</h3>
<p>Eine Alternative zu <strong>String Refs</strong> sind die sogenannten <strong>Callback Refs</strong>. Diese erlauben mehr Flexibilität, sind aber dafür natürlich auch etwas umständlicher zu implementieren, da ihr euch um deren Handling selbst kümmern müsst. Dafür ist es mit <strong>Callback Refs</strong> möglich diese an <strong>Kind-Komponenten</strong> weiterzugeben um auch auf DOM-Elemente innerhalb von diesen zugreifen zu können.</p>
<p><strong>Callback Refs</strong> werden, wie der Name es vermuten lässt, in <strong>Callback-Form</strong> definiert und bekommen beim <strong>Mounting</strong> als einzigen Parameter das DOM-Element oder bei Anwendung auf eine React-Komponente deren Instanz übergeben, beim <strong>Unmounting</strong> wird der Callback erneut aufgerufen, dann allerdings mit <code>null</code> als Parameter.</p>
<p>Was ihr dann damit macht, ist euch selbst überlassen. Ein gängiger Ansatz ist es jedoch, die Referenz zu diesem DOM-Element als Instanz-Eigenschaft zu speichern, um von innerhalb der Komponente überall darauf zugreifen zu können.</p>
<p>Angewendet auf das obige Beispiel sähe das dann so aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponentWithCallbackRef</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  componentDidMount() {
    <span class="hljs-keyword">this</span>.usernameEl.focus();
  }

  usernameEl = <span class="hljs-literal">null</span>;

  setUsernameEl = <span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> {
    <span class="hljs-keyword">this</span>.usernameEl = el;
  };

  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.setUsernameEl}</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> /&gt;</span>;
  }
}

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">ComponentWithCallbackRef</span> /&gt;</span>, document.getElementById('app'));</span></code></pre>
<p><strong>Callback Refs</strong> können auch in Kind-Komponenten benutzt und auf diese <strong>Refs</strong> dann von innerhalb der Eltern-Komponente zugegriffen werden. Dazu übergebt ihr die Callback-Funktion der Kind-Komponente in einer eigenen Prop, die nicht <code>ref</code> heißen darf:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsernameInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> &lt;input type="text" name="username" ref={this.props.inputRef} /&gt;;
  }
}

class ComponentWithRefChild extends React.Component {
  componentDidMount() {
    this.usernameEl.focus();
  }

  usernameEl = null;

  setUsernameRef = (el) =&gt; {
    this.usernameEl = el;
  };

  render() {
    return (
      &lt;div&gt;
        Username:
        &lt;UsernameInput inputRef={this.setUsernameRef} /&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(&lt;ComponentWithRefChild /&gt;, document.getElementById('app'));</code></pre>
<p>Würdet ihr die Prop hier <code>ref</code> nennen, also <code>&lt;UsernameInput ref={this.setUsernameRef} /&gt;</code> würdet ihr stattdessen eine Referenz zur <code>UsernameInput</code>-<strong>Instanz</strong> erhalten, statt zu deren Input-Element. Bei <strong>Stateless Functional Components</strong> wäre <code>UsernameInput</code> sogar <code>null</code>, da SFCs nicht instanziiert werden!</p>
<h3 id="refs-über-createref">Refs über createRef()</h3>
<p>Neu in React 16.3. eingeführt wurde die Top Level Methode <code>React.createRef()</code>. Sie ähnelt von der Art der Verwendung her ein wenig den <strong>Callback Refs</strong>, jedoch mit kleinen Unterschieden. So müsst ihr euch auch hier um das Handling selbst kümmern. Durch ihre Ähnlichkeit zu <strong>Callback Refs</strong>, ist es auch hier gängige Praxis die <strong>Refs</strong> einer <strong>Instanz-Eigenschaft</strong> zuzuweisen.</p>
<p>Statt jedoch jedesmal eine nahezu identische Methode in der Form <code>(el) =&gt; { this.property = el }</code> zu übergeben, erstellt ihr bei der Instanziierung der Komponente bereits die Referenz und übergebt diese dann an die <code>ref</code>-Prop des jeweiligen Elements.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponentWithCreatedRef</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  componentDidMount() {
    <span class="hljs-keyword">this</span>.usernameEl.current.focus();
  }

  usernameEl = React.createRef();

  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.usernameEl}</span> /&gt;</span>;
  }
}

ReactDOM.render(<span class="hljs-tag">&lt;<span class="hljs-name">ComponentWithCreatedRef</span> /&gt;</span>, document.getElementById('app'));</span></code></pre>
<p>Vom Prinzip her also sehr ähnlich zu den <strong>Callback Refs</strong>, allerdings mit einem weiteren entscheidenden Unterschied: auf die entsprechende Referenz greift ihr hier via <code>this.usernameEl.current</code> zu.</p>
<p>Die Referenz zum Element wird hier also nicht in der Instanz-Eigenschaft gespeichert, der ihr die Ref zuordnet, sondern in deren <code>.current</code> Eigenschaft. Ansonsten ist ihr Verhalten soweit vergleichbar mit den Callback Refs. Ihr könnt diese ebenfalls an Kind-Komponenten über deren Props weitergeben und dann aus der Eltern-Komponente auf das jeweilige DOM-Element zugreifen.</p>
<p>Im direkten Vergleich hier noch einmal die <strong>Callback Ref</strong>:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  usernameEl = <span class="hljs-literal">null</span>;
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>
        <span class="hljs-attr">ref</span>=<span class="hljs-string">{(el)</span> =&gt;</span> {
          this.usernameEl = el;
        }}
      /&gt;
    );
  }
}</span></code></pre>
<p>Zugriff auf das Element via: <code>this.usernameEl</code></p>
<p>Und alternativ dazu die mittels <strong><code>React.createRef()</code></strong> erstellte Referenz:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  usernameEl = React.createRef();
  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.usernameEl}</span> /&gt;</span>;
  }
}</span></code></pre>
<p>Zugriff auf das Element via: <code>this.usernameEl.current</code>.</p>
<h2 id="fragments">Fragments</h2>
<p>Fragments sind eine Art Spezial-Komponente und dienen hilfsweise dazu gültiges JSX zu erzeugen ohne dabei sichtbare Spuren in der gerenderten Ausgabe zu hinterlassen. Gültiges JSX in dem Sinne, als das die <code>render()</code>-Methode immer nur ein Element auf oberster Ebene zurückgeben darf. Also etwa:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Bullet Point 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Bullet Point 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Bullet Point 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
  );
}</code></pre>
<p>Aber eben nicht so etwas wie:</p>
<pre><code class="hljs jsx language-jsx">render() {
  return (
    &lt;li&gt;Bullet Point 1&lt;/li&gt;
    &lt;li&gt;Bullet Point 2&lt;/li&gt;
    &lt;li&gt;Bullet Point 3&lt;/li&gt;
  );
}</code></pre>
<p>Hier geben wir aus der <code>render()</code>-Methode direkt und ohne umschließendes Eltern-Element mehrere <code>li</code>-Elemente zurück, was zu einer Fehlermeldung führt. Manchmal ist dies aber notwendig, bspw. wenn sich das umschließende Element in einer Eltern-Komponente befinden soll, die Kind-Elemente aber durch eine eigene Komponente erzeugt werden soll.</p>
<p>Innerhalb einiger Elemente (<code>table</code>, <code>ul</code>, <code>ol</code>, <code>dl</code>, …) ist es aber nicht erlaubt bspw. ein <code>div</code>-Element als Zwischenebene zu verwenden, um die Regel zu erfüllen stets nur ein einzelnes Root-Element aus einer Komponente zurückzugeben. In diesem Fall kommt das Fragment ins Spiel und würde angewendet auf das obige Beispiel folgende Änderung bedeuten um valides JSX zu erzeugen:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Bullet Point 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Bullet Point 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Bullet Point 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span>
  );
}</span></code></pre>
<p>Dabei gilt auch hier die Regel, dass iterativ, also durch eine Schleife, erzeugte Ausgabe eine key-Prop besitzen muss. Mit der Fragment Helper-Komponente ist dies möglich. Schauen wir uns ein weiteres, etwas umfassenderes und praxisnäheres Beispiel an:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">const</span> TicketMeta = <span class="hljs-function">(<span class="hljs-params">{ metaData }</span>) =&gt;</span> (
  &lt;dl&gt;
    {Object.entries(metaData).map(([property, value]) =&gt; (
      &lt;React.Fragment key={property}&gt;
        &lt;dt&gt;{property}&lt;/dt&gt;
        &lt;dd&gt;{value}&lt;/dd&gt;
      &lt;/React.Fragment&gt;
    ))}
  &lt;/dl&gt;
);

ReactDOM.render(
  &lt;TicketMeta
    metaData={{
      createdAt: '2018-06-09',
      author: 'Manuel Bieh',
      category: 'General',
    }}
  /&gt;,
  document.getElementById('root')
);</code></pre>
<p>Die so erzeugte Ausgabe wäre die folgende:</p>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>createdAt<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>2018-06-09<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>author<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>Manuel Bieh<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>category<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>General<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span></code></pre>
<p>Hier wäre es beispielsweise nicht möglich ein <code>div</code> oder <code>span</code> oder ein sonstiges Element um <code>&lt;dt&gt;&lt;dt&gt;</code> und <code>&lt;dd&gt;&lt;/dd&gt;</code> zu wrappen. Dies würde zu folgender Ausgabe führen:</p>
<pre><code class="hljs markup language-markup"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>createdAt<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>2018-06-09<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>author<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>Manuel Bieh<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>category<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>General<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span></code></pre>
<p>… und wäre damit ungültiges HTML, da ein <code>dl</code>-Element nur <code>dt</code> und <code>dd</code> als Kind-Element erlaubt. Das Fragment hilft uns hier also gültiges JSX zu erzeugen, ohne dabei gleichzeitig das HTML ungültig werden zu lassen. Dies war in React bis zur Einführung von Fragments in Version 16.3. ein Problem was dazu führte, dass Komponenten unnötig kompliziert implementiert werden mussten um weder gegen JSX- noch gegen HTML-Regeln zu verstoßen.</p>
<p><em>[<strong>TODO</strong>: sprachlich eine Katastrophe. Vielleicht nochmal den einen oder anderen Satz glatt ziehen und Beispiele und Erklärungen zur Short Syntax &lt;&gt;&lt;/&gt; einfügen]</em></p>
<h2 id="conditional-rendering">Conditional Rendering</h2>
<p><strong>Conditional Rendering</strong>, also das Rendering von Komponenten auf Basis verschiedener Bedingungen ist ein zentrales Konzept in React. Da React-Komponenten unter der Haube lediglich eine Komposition aus JavaScript-Funktionen, -Objekten und -Klassen sind, funktionieren und verhalten sich Bedingungen hier exakt wie auch in herkömmlichem JavaScript.</p>
<p>Eine React-Komponente rendert <strong>Zustände</strong> eines <strong>User Interfaces</strong> basierend auf ihren <strong>Props</strong> und ihrem <strong>aktuellen State</strong>, optimalerweise <strong>frei von Seiten-Effekten.</strong> Um also korrekt auf diese verschiedenen Parameter reagieren zu können machen wir uns Rendering-Funktionen zu nutze, die an verschiedene Bedingungen geknüpft sind. Ist mein Parameter A, rendere dies, ist mein Parameter B, rendere das. Habe ich eine Liste mit Daten, zeige mir die Daten in einer HTML-Liste an. Habe ich keinerlei Daten, zeige mir stattdessen einen Platzhalter an.</p>
<p>Was einfach klingt, ist es im Grunde genommen auch. Aber man sollte die richtigen Wege kennen, insbesondere in JSX. Die <code>render()</code>-Funktion von Komponenten, also sowohl von <strong>Class Components</strong> als auch <strong>Stateless Functional Components</strong> kann grundsätzlich ein <strong>React-Element</strong> (natürlich auch in Form von JSX), einen <strong>String</strong>, eine <strong>Nummer</strong>, <code>null</code>, für den Fall, dass nichts gerendert werden soll oder ein <strong>Array</strong> aus den zuvor genannten Typen zurückgeben.</p>
<p>Darüber hinaus gibt es einige Möglichkeiten die <code>render()</code>-Methoden in den Komponenten übersichtlich zu halten. Diese Möglichkeiten werde ich euch hier vorstellen.</p>
<h3 id="ifelse">if/else</h3>
<p>Die wohl einfachste und wahrscheinlich auch gängigste Form des <strong>Conditional Renderings</strong> ist ein klassisches <code>if</code>/<code>else</code>-Konstrukt.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> NotificationList = <span class="hljs-function">(<span class="hljs-params">{ items }</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (items.length) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
        {items.map((notification) =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>{notification.title}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        ))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
    );
  }
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Keine neuen Benachrichtigungen<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
};</code></pre>
<p>Einfacher Anwendungsfall. Wir haben eine Komponente <code>NotificationList</code>, die eine Liste an Items in Form einer Prop entgegen nimmt. Enthält diese Liste Einträge, werden diese als simple ungeordnete Liste ausgegeben. Ist die Liste hingegen leer, lassen wir unsere Komponente stattdessen eben einen Hinweis ausgeben, dass keine neuen Benachrichtigungen vorhanden sind.</p>
<p>Ein weiteres Beispiel mit einem komplexeren Fall. Wir haben einen Wert und möchten diesen editierbar machen. Unsere Komponente kennt zwei verschiedene Modi: <code>edit</code> und <code>view</code>. Je nachdem ob wir uns <strong>View-Mode</strong> oder im <strong>Edit-Mode</strong> befinden, möchten wir nur den Text anzeigen oder ein vorausgefülltes Textfeld mit dem jeweiligen letzten aktuellen Wert.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { render } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EditableText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span>,
  };

  <span class="hljs-keyword">static</span> getDerivedStateFromProps(nextProps, prevState) {
    <span class="hljs-keyword">if</span> (prevState.value === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">value</span>: nextProps.initialValue || <span class="hljs-string">''</span>,
      };
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  handleChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> { value } = e.target;
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      value,
    }));
  };

  setMode = <span class="hljs-function">(<span class="hljs-params">mode</span>) =&gt;</span> () =&gt; {
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      mode,
    }));
  };

  render() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.mode === <span class="hljs-string">'edit'</span>) {
      <span class="hljs-keyword">return</span> (
        &lt;div&gt;
          &lt;input
            type="text"
            value={this.state.value}
            onChange={this.handleChange}
          /&gt;
          &lt;br /&gt;
          &lt;button onClick={this.setMode('view')}&gt;Done&lt;/button&gt;
        &lt;/div&gt;
      );
    }

    return (
      &lt;div&gt;
        {this.state.value}
        &lt;br /&gt;
        &lt;button onClick={this.setMode('edit')}&gt;Edit&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}

render(
  &lt;EditableText initialValue="Example" /&gt;,
  document.getElementById('root')
);</code></pre>
<p>Der für dieses Kapitel relevante Teil spielt sich innerhalb der <code>render()</code>-Methode der Komponente ab. Wir prüfen hier auf den Wert der State-Eigenschaft <code>mode</code>, ist dieser <code>edit</code>, geben wir direkt das Eingabefeld zurück („early return“). Ist dieses nicht <code>edit</code>, gehen wir davon aus, dass der „Standardfall“ eintritt, der in diesem Falle der Ansichtsmodus (<code>view</code>) wäre. Der <code>else</code>-Teil der Condition ist hier also gar nicht nötig und würde lediglich unnötig Komplexität hinzufügen. Gerendert wird jeweils der Text, einmal editierbar als <code>value</code> eines <code>input</code>-Felds, einmal lediglich als Textknoten und dazu jeweils ein Button, um die State-Eigenschaft <code>mode</code> der Komponente zwischen <code>view</code> und <code>edit</code> hin und her zu wechseln.</p>
<p>Derartige <code>if</code>, <code>if</code>/<code>else</code> oder <code>if</code>/<code>else if</code>/<code>else</code>-Konstrukte sind in verschiedenen Varianten, auf die ich hier gleich noch eingehen werde, eine häufige Form wenn es darum geht eine Ausgabe auf Basis von <strong>State</strong> und <strong>Props</strong> innerhalb einer Komponente zu erzeugen.</p>
<h3 id="null">null</h3>
<p>Nein, die Überschrift ist kein Fehler. <code>null</code> zurückzugeben ist wohl der einfachste Fall für <strong>Conditional Rendering.</strong> Gibt die <code>render()</code>-Methode einer Komponente <code>null</code> zurück, wird diese nicht gerendert und erscheint daher auch nicht im DOM. Dies kann manchmal sinnvoll sein, bspw. wenn eine Fehler-Komponente nur dann angezeigt werden soll wenn auch ein Fehler aufgetreten ist.</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.state.error) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"error-message"</span>&gt;</span>{this.state.error.message}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}</code></pre>
<p>Hier wird geprüft ob im State der Komponente eine error-Eigenschaft gesetzt ist. Ist dies nicht der Fall, wird <code>null</code> zurückgegeben und somit auch nichts gerendert. Existiert die Eigenschaft hingegen, wird die entsprechende Fehlermeldung in einem <code>div</code> ausgegeben, wozu wir wieder auf das Conditional Rendering mit einem einfachen <code>if</code> zurückgreifen.</p>
<h3 id="ternary-operator">Ternary Operator</h3>
<p>Dies waren Beispiele für Bedingungen die relativ grundlegende Unterschiede in ihren Komponenten ausgeben. Oftmals möchte man allerdings nur kleine Unterschiede ausgeben, etwa eine CSS-Klasse hinzufügen wenn ein bestimmter State gesetzt ist. Hier hilft uns der Ternary Operator weiter. Kurze Auffrischung: der <strong>Ternary Operator</strong> ist ein Ausdruck und hat die Form <code>Bedingung ? Erfüllt : Nicht Erfüllt</code>. Also etwa: <code>isLoggedIn ? 'Logout' : 'Login';</code></p>
<p>Und damit hätten wir auch schon unser erstes Beispiel für die Verwendung des <strong>Ternary Operators</strong> innerhalb von JSX. Er kann sowohl innerhalb von Props verwendet werden als auch einfach um, je nach Bedingung, verschiedene Elemente zu rendern. Ein konkreter Anwendungsfall für das eben genannte Beispiel wäre die Ausgabe von Text in Abhängigkeit zu einer Bedingung:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">const</span> { isLoggedIn } = <span class="hljs-keyword">this</span>.props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>{ isLoggedIn ? 'Logout' : 'Login' }<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  );
}</code></pre>
<p>In diesem Fall würden wir stets einen Button ausgeben, dieser hätte aber abhängig von seiner <code>isLoggedIn</code>-Prop entweder die Beschriftung <strong>Logout</strong> oder <strong>Login</strong>.</p>
<p>Genau in der gleichen Form kann der <strong>Ternary Operator</strong> in Props verwendet werden. Nehmen wir an wir wollen ein Liste mit Benutzern ausgeben, von denen einige deaktiviert wurden. In diesem Fall möchten wir eine Klasse setzen um diese mittels CSS markieren zu können. Ein entsprechendes Markup könnte dann bspw. so aussehen:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">const</span> { user } = <span class="hljs-keyword">this</span>.props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{user.isDisabled</span> ? '<span class="hljs-attr">is-disabled</span>' <span class="hljs-attr">:</span> '<span class="hljs-attr">is-active</span>'}&gt;</span>{user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}</code></pre>
<p>Deaktivierte Benutzer würden hier mit einer Klasse <code>is-disabled</code> gekennzeichnet, aktive Benutzer hingegen mit einer Klasse <code>is-active</code>.</p>
<p>Auch komplexeres JSX lässt sich mittels <strong>Ternary Operator</strong> abbilden. Dazu muss lediglich die allgemein gültige Regel befolgt werden, dass sich über mehrere Zeilen erstreckendes JSX in Klammern gefasst werden muss:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">const</span> { country } = <span class="hljs-keyword">this</span>.props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>State:<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      {country === 'de' ? (
        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"state"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"bw"</span>&gt;</span>Baden-Württemberg<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"by"</span>&gt;</span>Bayern<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"be"</span>&gt;</span>Berlin<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"bb"</span>&gt;</span>Brandenburg<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
          […]
        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
      ) : (
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"state"</span> /&gt;</span>
      )}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  );
}</span></code></pre>
<p>In diesem Fall rendern wir also eine Select-Liste mit allen deutschen Bundesländern wenn das zuvor ausgewählte Land <strong>Deutschland</strong> (<code>de</code>) ist, in allen anderen Fällen zeigen wir dem Benutzer nur ein Textfeld an, in das dieser sein entsprechendes Bundesland frei eintragen kann. Hier sollte jedoch immer abgewogen werden ob dies sinnvoll ist, denn der <strong>Ternary Operator</strong> kann insbesondere in komplexerem JSX schnell unübersichtlich werden.</p>
<h3 id="logical-and--und-logical-or-">Logical AND (<code>&amp;&amp;</code>) und Logical OR (<code>||</code>)</h3>
<p>Der <strong>Logical Operator</strong> hat auf den ersten Blick Ähnlichkeit zum <strong>Ternary Operator</strong>, jedoch mit dem Unterschied dass er noch kürzer und prägnanter ist. Anders als beim <strong>Ternary Operator</strong> wird hier kein „zweiter Fall“ benötigt, also ein Wert der verwendet wird, falls die Bedingung nicht erfüllt ist. Ist die Bedingung in einem <strong>Logical AND Operator</strong> nicht erfüllt, ist der Ausdruck <code>undefined</code> und verursacht somit keinerlei sichtbare Ausgabe im User Interface:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">const</span> { isMenuVisible } = <span class="hljs-keyword">this</span>.props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
      { isMenuVisible &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">Menu</span> /&gt;</span> }
    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span>
  );
}</code></pre>
<p>In diesem Fall würde eine Komponente prüfen ob der Wert der <code>isMenuVisible</code>-Prop <code>true</code> ist <strong>und</strong> dann eine <code>Menu</code>-Komponente anzeigen. Ist der Wert <code>false</code>, gibt der Ausdruck <code>undefined</code> zurück und die Komponente rendert dementsprechend keine Ausgabe an dieser Stelle.</p>
<p>In Verbindung mit dem <strong>Logical OR Operator</strong> kann hier ein Fall wie beim <strong>Ternary Operator</strong> herbeigeführt werden:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">const</span> { isLoggedIn } = <span class="hljs-keyword">this</span>.props;
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>{ isLoggedIn &amp;&amp; 'Logout' || 'Login' }<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  );
}</code></pre>
<p>Die Beschriftung des Buttons ist in diesem Fall <strong>Logout</strong>, wenn die <code>isLoggedIn</code> <strong>Prop</strong> <code>true</code> ist, der Benutzer also eingeloggt ist oder <strong>Login</strong> wenn der Benutzer nicht eingeloggt ist.</p>
<h3 id="eigene-render-methoden">Eigene <code>render()</code>-Methoden</h3>
<p>Eine Möglichkeit um die Übersicht bei <strong>Conditional Rendering</strong> zu erhöhen ist, bestimmte Teile aus der <code>render()</code>-Methode in eigene <code>renderXY()</code>-Methoden zu verfrachten. Die <code>render()</code>-Methode stellt so gesehen den Kern einer Komponente dar, ist sie doch dafür verantwortlich zu entscheiden, was ein Benutzer später auf seinem Bildschirm sieht. Sie sollte also nicht zu komplex werden, nicht unnötig viel Logik enthalten und lesbar sein.</p>
<p>Nicht unüblich ist es daher sehr komplexe und lange <code>render()</code>-Methoden in kleine übersichtliche Häppchen zu unterteilen und als eigene Klassenmethoden zu implementieren. Dies führt bei sinnvoller Benamung der jeweiligen Methoden meist zur Erhöhung und zu besserer Verständlichkeit des Codes. Meist werden die einzelnen <code>render()</code>-Methoden noch mit <code>if</code>-Blöcken kombiniert:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Countdown</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  renderTimeLeft() {
    <span class="hljs-comment">// […]</span>
  }

  renderTimePassed() {
    <span class="hljs-comment">// […]</span>
  }

  render() {
    <span class="hljs-keyword">const</span> { currentDate, eventDate } = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">if</span> (currentDate &lt; eventDate) {
      <span class="hljs-comment">// currentDate is before eventDate so render countdown</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.renderTimeLeft();
    }
    <span class="hljs-comment">// time is over so render how much time has passed since then</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.renderTimePassed();
  }
}</code></pre>
<p>Dies <strong>kann</strong> bei kluger Verwendung die Lesbarkeit einer <code>render()</code>-Methode erhöhen, führt aber unweigerlich auch dazu, dass sich die Komplexität einer Komponente (im etwas geringeren Maß) erhöht. Viele Leute – ich zähle mich dazu – raten daher eher dazu Teile des Codes wiederum in eigene gekapselte <strong>Stateless Functional Components</strong> auszulagern statt <code>renderXY()</code>-Methoden zu verwenden.</p>
<div class="hint hint--info">
<p>Sobald die Überlegung ansteht eine weitere <code>render()</code>-Methode innerhalb einer Komponente zu implementieren sollte darüber nachgedacht werden, stattdessen eine eigene, separate <strong>Stateless Functional Component</strong> zu erstellen.</p>
</div>
<h3 id="eigene-komponenten-bei-komplexen-conditions">Eigene Komponenten bei komplexen Conditions</h3>
<p>Statt weiterer <code>render()</code>-Methoden innerhalb einer Komponente können wie eben bereits angesprochen auch eigene, neue, bevorzugterweise <strong>Stateless Functional Components</strong> erstellt werden. Diese bekommen dann entsprechende <strong>Props</strong> aus ihrer Eltern-Komponente hereingereicht und kümmern sich dann als eigenständige, unabhängige, wiederverwendbare und testbare Komponente um die Anzeige der ihnen übergebenen Daten.</p>
<p>An erster Stelle sollte die Überlegung stehen wie einfach sich die Daten aus der ursprünglichen Eltern-Komponente in die neue(n) Kind-Komponente(n) übertragen lassen und vor allem welche Daten überhaupt in eine neue Komponente ausgelagert werden sollten. Dabei sollte beachtet werden dass die neuen Komponenten selbst wiederum nicht wieder zuviel Logik oder gar State enthalten sollten.</p>
<p>Dieses Vorgehen bietet sich vor allem dann an wenn immer wiederkehrende Elemente in einer Komponente verwendet wird oder eine <code>render()</code>-Methode eben zu groß und unübersichtlich wird.</p>
<p>Stellen wir uns ein Formular vor, das aus zumeist sehr ähnlichen Textfeldern besteht. Jedes Textfeld befindet sich in einem eigenen Paragraphen, hat ein Label und natürlich auch ein <code>type</code>-Attribute. Zum Label gehört außerdem auch eine id, die ebenfalls angegeben werden muss für jedes Feld:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">return</span> (
    &lt;form&gt;
      &lt;p&gt;
        &lt;label for="email"&gt;
          Email
        &lt;/label&gt;
        &lt;br /&gt;
        &lt;input type="email" name="email" id="email" /&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;label for="password"&gt;
          Password
        &lt;/label&gt;
        &lt;br /&gt;
        &lt;input type="password" name="password" id="password" /&gt;
      &lt;/p&gt;
      &lt;input type="submit" value="Send" /&gt;
    &lt;/form&gt;
  );
}</code></pre>
<p>In diesem Fall haben wir lediglich zwei Formularfelder. Oft ist es aber bereits in durchschnittlich komplexen Anwendungen so, dass es deutlich größere Formulare mit deutlich mehr Feldern gibt. Doch bereits in diesem Fall kann es sinnvoll sein die sich wiederholenden Felder in eigene Komponenten auszulagern, da wir uns viel Schreibarbeit ersparen können.</p>
<p>Wir erstellen also zunächst eine <code>TextField</code>-Komponente und lagern das sich wiederholende JSX aus unserer Formular-Komponente dorthin aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> TextField = <span class="hljs-function">(<span class="hljs-params">{ id, label, ...HTMLInputAttributes }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">{id}</span>&gt;</span>{label}<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> {<span class="hljs-attr">...HTMLInputAttributes</span>} <span class="hljs-attr">id</span>=<span class="hljs-string">{id}</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
);

export default TextField;</span></code></pre>
<p>Unsere neue Komponente empfängt eine <code>id</code>, die wir benötigen, um das Label mit dem Eingabefeld zu verknüpfen und ein Label als solches. Mittels <strong>Object Rest/Spread</strong> fügen wir dem <code>input</code>-Element dann außerdem alle weiteren Props, die der Komponente übergeben werden, als Attribut hinzu.</p>
<p>Unsere Komponente von oben sieht dann wie folgt aus:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">return</span> (
    &lt;form&gt;
      &lt;TextField name="email" label="Email" id="email" type="email" /&gt;
      &lt;TextField name="password" label="Password" id="password" type="password" /&gt;
      &lt;input type="submit" value="Send" /&gt;
    &lt;/form&gt;
  );
}</code></pre>
<p>Aus einem langen und potentiell sehr unübersichtlichen Markup haben wir also eine übersichtliche, prägnante <code>render()</code>-Methode gemacht die auf oberster Ebene aus wenigen Komponenten besteht. Möchten wir in Zukunft außerdem eine Änderung vornehmen die sich auf alle Textfelder auswirkt, bspw. eine neue Klasse hinzufügen, muss dies nur noch an einer einzigen Stelle geändert werden, in der neuen <code>TextField</code>-Komponente.</p>
</div><div class="chapter">
<h1 id="erweiterte-konzepte">Erweiterte Konzepte</h1>
</div><div class="chapter">
<h1 id="typechecking-mit-proptypes-flow-und-typescript">Typechecking mit PropTypes, Flow und TypeScript</h1>
<p><strong>Typechecking</strong> ist eine einfache Möglichkeit um potentielle Fehler in einer Anwendung zu vermeiden. Das Prinzip dabei ist ganz einfach: Komponenten sollten „Pure“ sein, wir wir schon in der Einführung gelernt haben. Sie sollten also keine Seiten-Effekte auslösen und vor allem sollten sie bei den <strong>gleichen Eingabeparametern</strong> (was im Fall von Komponenten die <strong>Props</strong> und deren daraus abgeleiteter <strong>State</strong> ist) auch die <strong>identische Ausgabe</strong> erzeugen.</p>
<p>Das bedeutet, dass es möglichst vorhersehbar und sehr strikt sein sollte welche <strong>Props</strong> in eine Komponente hereingereicht werden können und welche von ihr verarbeitet werden. Um dies sicherzustellen können wir uns das sog. <strong>Typechecking</strong> zu nutze machen. JavaScript ist prinzipiell eine untypisierte Sprache. Eine Variable die mal ein <strong>String</strong> war, kann problemlos in eine <strong>Number</strong> oder gar ein <strong>Object</strong> umgewandelt werden, ohne dass der JavaScript-Interpreter ein Problem damit hat.</p>
<p>Auch wenn dies bei der Entwicklung mitunter sehr praktisch ist weil wir uns nicht festlegen müssen, öffnet das die Tür für einige ärgerliche Fehler und macht es daher nötig, regelmäßig manuell auf den korrekten Typen zu prüfen. Wollen wir bspw. auf eine tief verschachtelte Eigenschaft <code>user.settings.notifications.newMessages</code>zugreifen, sollten wir zuvor prüfen ob <code>user</code> überhaupt ein Objekt und nicht <code>null</code> ist, anschließend sollten wir prüfen ob das gleiche für <code>settings</code> zutrifft, usw. Andernfalls könnten wir es mit einem Type Error zu tun haben:</p>
<div class="hint hint--danger">
<p>TypeError: Cannot read property 'settings' of undefined</p>
</div>
<p><strong>Typechecking</strong> kann uns hier also helfen derartige potentielle Fehler schon vorher zu entdecken. Dazu gibt es neben <strong>Flow</strong> und <strong>TypeScript</strong>, die statische Typisierung ermöglichen, mit den sogenannten <strong>PropTypes</strong> auch eine recht simple React-eigene Lösung. Während <strong>Flow</strong> und <strong>TypeScript</strong> generell statische Typisierung in JavaScript ermöglichen, beschränken sich die React <strong>PropTypes</strong> allein auf React-Komponenten und finden außerhalb von Komponenten keine Anwendung. Wer also Gefallen findet an statischer Typisierung, sollte durchaus mal einen Blick auf <strong>Flow</strong> oder <strong>TypeScript</strong> wagen.</p>
<h2 id="proptypes">PropTypes</h2>
<p><strong>PropTypes</strong> reichen zurück bis in ganz frühe Versionen von React, lange bevor React seine heutige Popularität erreicht hat und wurden in React 15.5. aus dem Core heraus und in ein eigenes <code>prop-types</code> Package ausgelagert. Während man seine <strong>PropTypes</strong> vorher mittels bspw. <code>React.PropTypes.string</code> direkt in der Core-Library definieren konnte, erfolgt der Zugriff nun über das zuvor importierte <code>PropTypes</code> Modul: <code>PropTypes.string</code>.</p>
<p>Das bedeutet auch, dass das Modul zuerst als <code>devDependency</code> installiert werden muss. Auf der Kommandozeile reicht dafür ein simples:</p>
<pre><code class="hljs text language-text">yarn <span class="hljs-keyword">add</span><span class="bash"> --dev prop-types</span></code></pre>
<p>oder:</p>
<pre><code class="hljs text language-text">npm install --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> prop-types</code></pre>
<p><strong>PropTypes</strong> dienen dabei als eine Art Interface und legen fest, welche Form bzw. welchen Typen eine Prop annehmen darf und ob diese optional ist oder erforderlich ist. Gibt es Abweichungen, weist uns React <strong>im Development-Modus</strong> darauf hin. Bei einer korrekt veröffentlichten Anwendung, die die Production-Version von React nutzt und/oder mit der Umgebungsvariable <code>process.env.NODE_ENV=production</code> gebaut wurde bekommen wir diese Warnungen <strong>nicht</strong> mehr zu sehen!</p>
<p>Doch wie sieht die Verwendung von <strong>PropTypes</strong> nun aus? Hier müssen wir unterscheiden zwischen der <strong>Class Component</strong> und der <strong>Stateless Functional Component</strong>.</p>
<p>Bei der <strong>Class Component</strong> sind die <strong>PropTypes</strong> eine statische Eigenschaft <code>propTypes</code> der Komponente:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;
​
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventOverview</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">static</span> propTypes = {
    <span class="hljs-attr">date</span>: PropTypes.instanceOf(<span class="hljs-built_in">Date</span>).isRequired,
    <span class="hljs-attr">description</span>: PropTypes.string,
    <span class="hljs-attr">ticketsUrl</span>: PropTypes.string,
    <span class="hljs-attr">title</span>: PropTypes.string.isRequired
  };
​
  render() {
    <span class="hljs-keyword">const</span> { date, description, ticketUrl, title } = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{title}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{date.toLocaleString()}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        {description &amp;&amp; (
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"description"</span>&gt;</span>{description}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        )}
        {ticketsUrl &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">{ticketsUrl}</span>&gt;</span>Tickets!<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}
​
ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">EventOverview</span> <span class="hljs-attr">date</span>=<span class="hljs-string">{new</span> <span class="hljs-attr">Date</span>()} <span class="hljs-attr">title</span>=<span class="hljs-string">"React lernen und verstehen"</span> /&gt;</span>,
  document.getElementById('root')
);</span></code></pre>
<p>In diesem Beispiel möchten wir eine Übersicht zu einem Event ausgeben. Wir definieren, dass die <code>EventOverview</code>-Komponente die beiden Props <code>date</code> und <code>title</code> haben <strong>muss</strong>, darüber hinaus die beiden Props <code>description</code> und <code>ticketsUrl</code> haben <strong>kann</strong>. Ob eine Prop <strong>vorausgesetzt</strong> wird, kann mittels des angehängten <code>.isRequired</code> gekennzeichnet werden. Die <code>date</code>-Prop muss dabei in unserem Beispiel eine Instanz des nativen JavaScript <code>Date</code>-Objekts sein, <code>title</code> muss ein <code>string</code> sein. Die beiden optionalen Props <code>description</code> und <code>ticketsUrl</code> müssen nicht übergeben werden, werden sie allerdings übergeben, müssen auch sie vom Typ <code>string</code> sein.</p>
<p>Trifft eine dieser Bedingungen nicht zu, weist uns React darauf ziemlich deutlich mit einer Warnung in der Konsole hin:</p>
<div class="hint hint--danger">
<p>Warning: Failed prop type: Invalid prop `title` of type `number` supplied to `EventOverview`, expected `string`.</p>
</div>
<p>Bei <strong>Stateless Functional Components</strong> werden die <strong>PropTypes</strong> in gleicher Art und Weise definiert, allerdings haben wir hier natürlich keine Klasse, in der wir eine <code>static propTypes</code> Eigenschaft definieren können. Hier können wir einfach der Funktion selbst eine <code>propTypes</code>-Eigenschaft hinzufügen. Das sieht dann so aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> EventOverview = <span class="hljs-function">(<span class="hljs-params">{ date, description, ticketUrl, title }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{title}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{date.toLocaleString()}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    {description &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"description"</span>&gt;</span>{description}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}
    {ticketsUrl &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">{ticketsUrl}</span>&gt;</span>Tickets!<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>}
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
);

EventOverview.propTypes = {
  <span class="hljs-attr">date</span>: PropTypes.instanceOf(<span class="hljs-built_in">Date</span>).isRequired,
  <span class="hljs-attr">description</span>: PropTypes.string,
  <span class="hljs-attr">ticketsUrl</span>: PropTypes.string,
  <span class="hljs-attr">title</span>: PropTypes.string.isRequired,
};</code></pre>
<p>Und damit wäre auch unsere <strong>Stateless Functional Component</strong> mit <strong>PropType</strong>-Checking ausgestattet!</p>
<p>In einigen Fällen ist es wünschenswert sinnvolle Standardwerte zu vergeben. Auch hierfür bietet uns React eine Möglichkeit, die sogenannten <code>defaultProps</code>. Diese werden ähnlich verwendet wie die <code>propTypes</code>, nämlich als statische Eigenschaft. Aber schauen wir uns ein schnelles Beispiel an:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> Greeting = <span class="hljs-function">(<span class="hljs-params">{ name }</span>) =&gt;</span> &lt;h1&gt;Hallo {name}!<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;

Greeting.propTypes = {
  <span class="hljs-attr">name</span>: PropTypes.string.isRequired,
};

Greeting.defaultProps = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Gast'</span>,
};</code></pre>
<p>Wir markieren die <code>name</code>-Prop der Komponente als <code>string.isRequired</code>, wir erwarten also, dass die Prop immer übergeben wird und dass sie auch immer ein String ist. Anschließend definieren wir einen Standardwert für die <code>name</code>-Prop. Dieser wird immer dann verwendet, wenn kein Wert für die entsprechende Prop übergeben wird.</p>
<pre><code class="hljs jsx language-jsx">&lt;Greeting name=<span class="hljs-string">"Manuel"</span> /&gt;</code></pre>
<p>Verursacht also die Ausgabe: <strong>Hallo Manuel!</strong></p>
<pre><code class="hljs jsx language-jsx">&lt;Greeting /&gt;;
<span class="hljs-comment">// oder:</span>
<span class="hljs-keyword">const</span> user = {};
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">{user.name}</span> /&gt;</span>;</span></code></pre>
<p>Nutzt wegen der fehlenden bzw. undefinierten <code>name</code>-Prop hingegen den <code>defaultValue</code>, in diesem Fall <strong>Gast</strong> und zeigt in beiden Fällen an: <strong>Hallo Gast!</strong> React ist dabei klug genug und erkennt bei fehlender aber als <code>isRequired</code> markierter Prop ob ein <code>defaultValue</code> existiert und zeigt eine Warnung nur dann an, wenn eine Prop fehlt und auch nicht gleichzeitig ein <code>defaultValue</code> definiert wurde.</p>
<div class="hint hint--info">
<p>Beim <strong>Deployment in Production</strong> lohnt es sich das <strong>Babel-Plugin-Transform-React-Remove-Prop-Types</strong> zu verwenden. Dies spart noch einmal ein paar Bytes Bandbreite, da die <code>propType</code>-Definitionen aus dem Build entfernt werden, da diese ohnehin <strong>nur im Development-Modus</strong> berücksichtigt werden.</p>
<p>Das Plugin findet ihr unter:<br />
https://github.com/oliviertassinari/babel-plugin-transform-react-remove-prop-types</p>
</div>
<h2 id="flow">Flow</h2>
<p>Anders als die <strong>React PropTypes</strong> ist <strong>Flow</strong> ein <strong>statischer Typechecker</strong> für <strong>sämtliches</strong> JavaScript, nicht allein nur für React-Komponenten. Wie React selbst wird auch <strong>Flow</strong> von Facebook entwickelt und fügt sich dadurch schön nahtlos in die meisten React Setups ein. Bis <strong>Babel 6</strong> war es sogar Teil des <code>babel-preset-react</code> Pakets wurde also sozusagen zur Verwendung mit React „mit-installiert“ und konnte ohne jeglichen zusätzlichen Aufwand einfach verwendet werden.</p>
<p>Seit <strong>Babel 7</strong> ist <strong>Flow</strong> in ein eigenes <strong>Babel Preset</strong> ausgelagert worden, dass sich aber ebenso einfach über <code>npm install @babel/preset-flow</code> (bzw. analog dazu <code>yarn add @babel/preset-flow</code>) installieren lässt. Anschließend muss dann lediglich noch das entsprechende <code>@babel/preset-flow</code> als Preset in die Babel-Config eingetragen werden. Das <strong>Preset</strong> wird benötigt um die <strong>Flow-Syntax</strong>, die kein valides JavaScript wäre, im <strong>Build-Prozess</strong> aus dem entsprechenden Files zu entfernen, so dass es beim Aufruf im Browser nicht zu Syntax-Fehlern kommt.</p>
<p>Neben dem Babel Preset wird außerdem noch die <strong>Flow Executable</strong> benötigt, die sich in ihrer jeweils aktuellsten Version mittels <code>npm install flow-bin</code> (bzw. <code>yarn add flow-bin</code>) installieren lässt. Die <strong>Flow Executable</strong> führt dann das eigentliche <strong>Typechecking</strong> durch.</p>
<p>Nachdem <strong>Flow</strong> installiert und das <strong>Babel Preset</strong> eingerichtet wurde, wird noch eine <strong>Flow-Config</strong> benötigt. Diese erstellt ihr ganz einfach über den Aufruf von <code>./node_modules/flow init</code> im Terminal in eurem Projektverzeichnis.</p>
<p><strong>Tipp:</strong> um zu vermeiden jedes Mal <code>./node_modules</code> voranzustellen wenn Flow aufgerufen werden soll, könnt ihr euch einen Eintrag in den <code>script</code>-Teil eurer <code>package.json</code> machen:</p>
<pre><code class="hljs javascript language-javascript">{
  <span class="hljs-string">"scripts"</span>: {
    [...]
    <span class="hljs-string">"flow"</span>: <span class="hljs-string">"flow"</span>
  }
}</code></pre>
<p>Dies sorgt dafür, dass ihr Flow anschließend über npm oder Yarn aufrufen könnt:</p>
<pre><code class="hljs bash language-bash">npm run flow init</code></pre>
<p>oder mit Yarn:</p>
<pre><code class="hljs bash language-bash">yarn flow init</code></pre>
<p>Nachdem ihr <code>flow init</code> aufgerufen habt, solltet ihr in eurem Projektverzeichnis eine neue Datei <code>.flowconfig</code> sehen, die erst einmal ziemlich leer aussieht, die von Flow aber benötigt wird. In diese Datei könnt ihr später Optionen setzen oder angeben welche Dateien mit Flow geprüft werden sollen oder welche eben nicht.</p>
<p>Ihr habt eure Babel-Config aktualisiert, das <code>flow-bin</code> Package in euer Projekt installiert und die <code>.flowconfig</code> angelegt? Super. Dann kann es richtig losgehen. Um zu verifizieren dass alles korrekt eingerichtet wurde, könnt ihr einmal flow aufrufen. Wenn ihr den flow-Eintrag von oben in eurer <code>package.json</code> hinzugefügt habt könnt ihr das mit dem Befehl <code>yarn flow</code> in eurem Terminal. Ist alles korrekt eingerichtet, seht ihr eine Meldung wie die folgende:</p>
<pre><code class="hljs bash language-bash">No errors!
Done <span class="hljs-keyword">in</span> 0.57s.</code></pre>
<p>Dies bedeutet Flow hat eure Files geprüft und keine Fehler gefunden. Wie auch, haben wir doch noch gar keine Files mit Typechecking erstellt.</p>
<p>Die Standard-Einstellungen von Flow sehen vor, dass nur Files gecheckt werden, die Flow mit einem entsprechenden Kommentar im Code signalisieren, dass diese Typechecks beinhalten. Dazu fügt ihr einfach oben in jedem beliebigen JavaScript-File folgende Zeile ein:</p>
<pre><code class="hljs javascript language-javascript"><span class="hljs-comment">// @flow</span></code></pre>
<p>Schauen wir uns das obige Beispiel noch einmal an. Diesmal mit <strong>Flow</strong> als Typechecker anstelle von <strong>PropTypes</strong>:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// @flow</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
​
type PropsT = {
  <span class="hljs-attr">date</span>: <span class="hljs-built_in">Date</span>,
  description?: string,
  ticketsUrl?: string,
  <span class="hljs-attr">title</span>: string,
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventOverview</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">PropsT</span>&gt; </span>{
  render() {
    <span class="hljs-keyword">const</span> { date, description, ticketUrl, title } = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{title}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{date.toLocaleString()}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        {description &amp;&amp; (
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"description"</span>&gt;</span>{description}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        )}
        {ticketsUrl &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">{ticketsUrl}</span>&gt;</span>Tickets!<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}
​
ReactDOM.render(
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">EventOverview</span> <span class="hljs-attr">date</span>=<span class="hljs-string">{new</span> <span class="hljs-attr">Date</span>()} <span class="hljs-attr">title</span>=<span class="hljs-string">"React lernen und verstehen"</span> /&gt;</span>,
  document.getElementById('root')
);</span></code></pre>
<p>Anders als bei den <strong>PropTypes</strong> definieren wir hier zuerst eine <strong>Type Definition</strong> mit dem Namen <code>PropsT</code>. Der Name kann hier grundsätzlich frei gewählt werden. Oft werden <code>T</code> oder <code>Type</code> an den Namen der Type-Definitions angehängt, um es für Entwickler gleich ersichtlich zu machen, dass es sich dabei um eben solche handelt. Aber rein aus technischer Sicht ist das nicht notwendig. Den eben definierten Type übergeben wir dann in Form eines sogenannten „Generic Type“ an die Komponente:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventOverview</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">PropsT</span>&gt;</span></code></pre>
<p>Type Definitions können auch inline definiert werden. Allerdings wirkt sich das ab einer gewissen Anzahl auch auf die Lesbarkeit aus. In unserem Beispiel sähe die dann so aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventOverview</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;</span>{
  date: <span class="hljs-built_in">Date</span>,
  description?: string,
  ticketsUrl?: string,
  <span class="hljs-attr">title</span>: string,
}&gt; {
  […]
}</code></pre>
<p>Doch schauen wir uns die <strong>Type-Definition</strong> einmal genauer an. Wie schon bei den <strong>PropTypes</strong> legen wir hier fest welche <strong>Props</strong> eine Komponente übergeben bekommen kann und von welchem Typen diese sein müssen. Da wäre eine <code>date</code> Prop, die aus einer <code>Date</code>-Instanz bestehen muss und erforderlich ist. Als nächstes dann <code>description</code> und <code>ticketsUrl</code>, die durch ein <code>?</code> nach ihrem Namen als <strong>optional</strong> gekennzeichnet wurden und jeweils, sollten sie übergeben werden, vom Typ <code>string</code> sein müssen. Zuletzt wird eine <code>title</code> Prop erwartet, die ebenfalls ein <code>string</code> sein muss, aber nicht optional ist. Anders als bei <strong>PropTypes</strong> müssen hier nicht die erforderlichen Props mittels <code>isRequired</code> gekennzeichnet werden, sondern im Gegenteil die optionalen Props mittels Fragezeichen als optional markiert werden.</p>
<p><strong>Stateless Functional Components</strong> können in gleicher Form gleich der Übergabe der Props als Funktionsargument typisiert werden:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> EventOverview = <span class="hljs-function">(<span class="hljs-params">props: PropsT</span>) =&gt;</span> ([…]);</code></pre>
<p>bzw. in destrukturierter Form:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> EventOverview = <span class="hljs-function">(<span class="hljs-params">{ date, description, ticketUrl, title }: PropsT</span>) =&gt;</span> ([…]);</code></pre>
<p>oder als Inline-Definition:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> EventOverview = ({
    date,
    description,
    ticketUrl,
    title
}: {
    <span class="hljs-attr">date</span>: <span class="hljs-built_in">Date</span>,
    description?: string,
    ticketsUrl?: string,
    <span class="hljs-attr">title</span>: string
}) =&gt; {
  […]
};</code></pre>
<p>Doch das ist noch nicht alles. Flow kann eben, anders als <strong>PropTypes</strong>, sämtliches JavaScript checken, nicht bloß Props von React-Komponenten. Dies bedeutet, dass auch der State einer Komponente typisiert werden kann. Dazu ist ein zweiter Parameter in den sog. <strong>Generics</strong> vorgesehen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-comment">// @flow</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
​
type PropsT = {
  <span class="hljs-attr">date</span>: <span class="hljs-built_in">Date</span>,
  description?: string,
  ticketsUrl?: string,
  <span class="hljs-attr">title</span>: string,
};

type StateT = {
  <span class="hljs-attr">isBookmarked</span>: boolean,
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventOverview</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">PropsT</span>, <span class="hljs-title">StateT</span>&gt; </span>{
  state = {
    <span class="hljs-attr">isBookmarked</span>: <span class="hljs-literal">false</span>,
  };
  […]
}</code></pre>
<p>Anders als in bisherigen Beispielen im Buch haben die Imports hier eine etwas andere Form. Statt:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;</code></pre>
<p>… wurde React in diesem Kapitel folgendermaßen importiert:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;</code></pre>
<p>Dies führt dazu, dass gleichzeitig auch die von React mitgelieferten <strong>Type Definitions</strong> mit importiert wurden. Dies ist notwendig, wenn wir bspw. ein React-Element aus einer Funktion zurückgeben und dieses typisieren wollen.</p>
<p>[TODO: Weiter ausführen, mehr Beispiele]</p>
<h2 id="typescript">TypeScript</h2>
<p><strong>TypeScript</strong> wird von Microsoft entwickelt und ist ein sogenanntes typisiertes <strong>Superset</strong> von JavaScript, was bedeutet, dass es nicht direkt im Browser ausgeführt werden kann sondern zuvor in einem Zwischenschritt von einem Compiler in „echtes“ JavaScript kompiliert wird. <strong>TypeScript</strong> sieht auf den ersten Blick erst einmal ähnlich aus wie <strong>Flow</strong> und funktioniert auch ähnlich. Während Flow allerdings lediglich ein reiner <strong>Typechecker</strong> ist bringt <strong>TypeScript</strong> als Superset noch etwas mehr mit. So war es lange vor <strong>ES2015</strong> schon möglich Klassen und Imports in <strong>TypeScript</strong> zu verwenden.</p>
<p>In der JavaScript-Community erfreut sich <strong>TypeScript</strong> immer wachsender Beliebtheit und auch in Verbindung mit React ist es immer häufiger zu finden. Aus diesem Grund möchte ich das hier nicht ganz unerwähnt lassen, wobei ich hier gleichzeitig nicht all zu sehr in die Tiefe gehen möchte, da <strong>TypeScript</strong> allein genug Material für ein eigenes Buch hergeben würde.</p>
<p>Im Bezug auf React wichtig zu wissen ist, dass TypeScript-Files üblicherweise eine <code>.ts</code> Datei-Endung haben, enthält eine Datei auch JSX, muss die Datei zwingend mit <code>.tsx</code> enden.</p>
<p>Mit dem Release von Babel 7 wurde auch die Integration vereinfacht und es benötigt nun nicht mehr zwangsweise den <strong>TypeScript</strong> Compiler (<code>tsc</code>) sondern kann in Form eines Babel Plugins verwendet werden. Das Plugin wird mit dem Babel Preset <code>@babel/preset-typescript</code> installiert.</p>
</div><div class="chapter">
<h1 id="higher-order-components">Higher Order Components</h1>
<p><strong>Higher Order Components</strong> (meist abgekürzt: <strong>HOC</strong> oder <strong>HOCs</strong>) waren und sind ein sehr zentrales Konzept bei der Arbeit mit React. Sie erlauben es Komponenten mit wiederverwendbarer Logik zu implementieren und sind angelehnt an <strong>Higher Order Functions</strong> aus der funktionalen Programmierung. Das Prinzip hinter derartigen Funktionen ist, dass sie eine Funktion als Parameter entgegennehmen und eine neue Funktion zurückgeben. Im Fall von React wird das Prinzip auf Komponenten angewandt. Daher der von den <strong>Higher Order</strong> <em><strong>Functions</strong></em> abgeleitete Name <strong>Higher Order</strong> <em><strong>Component</strong></em>.</p>
<p>Zum leichteren Verständnis gleich ein erstes einfaches Beispiel:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> withFormatting = <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    bold = <span class="hljs-function">(<span class="hljs-params">string</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>{string}<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span></span>;
    };
    italic = <span class="hljs-function">(<span class="hljs-params">string</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>{string}<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span></span>;
    };
    render() {
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> <span class="hljs-attr">bold</span>=<span class="hljs-string">{this.bold}</span> <span class="hljs-attr">italic</span>=<span class="hljs-string">{this.italic}</span> /&gt;</span>;
    }
  };
};</span></code></pre>
<p>Hier haben wir eine Funktion <code>withFormatting</code> definiert, die eine React-Komponente entgegen nimmt. Die Funktion gibt dabei eine neue React-Komponente zurück welche die <em>in die Funktion herein gegebene Komponente</em> rendert und ihr dabei die Props <code>bold</code> und <code>italic</code> übergibt. Die hereingegebene Komponente kann nun auf diese Props zugreifen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> FormattedComponent = withFormatting(<span class="hljs-function">(<span class="hljs-params">{ bold, italic }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    Dieser Text ist {bold('fett')} und {italic('kursiv')}.
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
));</code></pre>
<p>Typischerweise werden <strong>Higher Order Components</strong> benutzt um Logik darin zu kapseln. In diesem Zusammenhang ist auch oft die Rede von <strong>Smart</strong> und <strong>Dumb Components</strong> also: <strong>schlaue</strong> und <strong>dumme</strong> Komponenten. Die Smart Components (zu denen Higher Order Components zählen) sind dann dazu da um Business Logik abzubilden, mit APIs zu kommunizieren oder Verhaltenslogik zu verarbeiten. <em>Dumme</em> Komponenten hingegen bekommen weitestgehend statische Props übergeben und beschränken den Logik-Teil auf reine Darstellungslogik. Also bspw. ob ein Benutzerbild oder, falls dieses nicht vorhanden ist, stattdessen ein Platzhalterbild angezeigt wird. In diesem Zusammenhang fällt auch oft der Begriff <strong>Container Component</strong> (für <em>Smart</em> Components) und <strong>Layout Components</strong> (für <em>Dumb</em> Components).</p>
<p>Doch wozu das überhaupt? Eine solche strikte Unterteilung in Business Logik und Darstellungslogik macht echte Komponenten getriebene Entwicklung erst einmal möglich. Sie erlaubt es Layout Komponenten zu erstellen die keinerlei Kenntnis von etwaigen APIs haben und nur stumpf die Daten darstellen die ihnen übergeben werden, völlig egal woher diese kommen. Gleichzeitig erlaubt sie es auch den Business Logik Komponenten sich um die reine Business Logik zu kümmern, völlig gleichgültig wie die Daten letzten Endes dargestellt werden.</p>
<p>Stellen wir uns ein gängiges Beispiel aus der Interface Entwicklung einmal vor: die Umschaltung zwischen einer <strong>Listen-</strong> und einer <strong>Karten-Ansicht</strong>. Hier würde sich eine <strong>Container-Komponente</strong> darum kümmern die Daten zu beschaffen die relevant sind für den Benutzer. Sie würde die beschafften Daten dann an die frei konfigurierbare <strong>Layout-Komponente</strong> übergeben. Solange beide Komponenten sich an das vom Entwickler vorgebene Interface (Stichwort <strong>PropTypes</strong>) halten sind beide Komponenten beliebig austauschbar und können vollkommen unabhängig voneinander entwickelt und <strong>getestet</strong> werden!</p>
<p>Genug Theorie. Zeit für ein weiteres Beispiel. Wir wollen uns eine Liste mit den 10 größten Kryptowährungen laden und ihren momentanen Preis anzeigen. Dazu erstellen wir eine <strong>Higher Order Component</strong> die sich diese Daten über die frei zugängliche Coinmarketcap API beschafft und an eine Layout-Komponente übergibt.</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> withCryptoPrices = <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    state = {
      <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">items</span>: [],
    };

    componentDidMount() {
      <span class="hljs-keyword">this</span>.loadData();
    }

    loadData = <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
        <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">true</span>,
      }));

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> cryptoTicker = <span class="hljs-keyword">await</span> fetch(
          <span class="hljs-string">'https://api.coinmarketcap.com/v2/ticker/?limit=10&amp;convert=EUR'</span>
        );
        <span class="hljs-keyword">const</span> cryptoTickerResponse = <span class="hljs-keyword">await</span> cryptoTicker.json();

        <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
          <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">items</span>: <span class="hljs-keyword">this</span>.convertResponseToArray(cryptoTickerResponse),
        }));
      } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
          <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>,
        }));
      }
    };

    convertResponseToArray = <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.entries(response.data).map(<span class="hljs-function">(<span class="hljs-params">[id, item]</span>) =&gt;</span> item);
    };

    render() {
      <span class="hljs-keyword">const</span> { isLoading, items } = <span class="hljs-keyword">this</span>.state;
      <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span>
          <span class="hljs-attr">isLoading</span>=<span class="hljs-string">{isLoading}</span>
          <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span>
          <span class="hljs-attr">loadData</span>=<span class="hljs-string">{this.loadData}</span>
        /&gt;</span>
      );
    }
  };
};</span></code></pre>
<p>Voilà, fertig ist die <strong>HOC</strong> für die Abfrage der Crypto-Preise auf coinmarketcap.com. Doch die <strong>Higher Order Component</strong> allein reicht noch nicht. Wir benötigen nun auch noch eine Layout-Komponente, an die wir die Verantwortung delegieren die Daten entsprechend anzuzeigen.</p>
<p>Hierzu erstellen wir eine möglichst generische <code>PriceTable</code>-Komponente, die selbst keinerlei Kenntnis davon hat ob sie nun die aktuellen Joghurtpreise aus dem örtlichen Supermarkt darstellt oder Preise von Kryptowährungen auf irgendeiner beliebigen Börse. Entsprechend nennen wir sie auch sehr generisch <code>PriceTable</code>:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> PriceTable = <span class="hljs-function">(<span class="hljs-params">{ isLoading, items, loadData }</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (isLoading) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading prices. Please be patient.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
  }

  <span class="hljs-keyword">if</span> (!items || items.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
        No data available. <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{loadData}</span>&gt;</span>Try again<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
    );
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
      {items.map((item) =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
            {item.name} ({item.symbol})
          <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>EUR {item.quotes.EUR.price}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
      ))}
      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colSpan</span>=<span class="hljs-string">"2"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{loadData}</span>&gt;</span>Refresh<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span>
  );
};</code></pre>
<p>Die Komponente kennt drei Props: <code>isLoading</code>, um ihr mitzuteilen, dass die Daten die sie einmal darstellen soll aktuell noch geladen werden, <code>items</code>, was ein Array aus „Artikeln“ mit Preisen repräsentiert und <code>loadData</code>, eine Funktion um erneut einen API-Request zu starten um die neuen Daten zu beziehen.</p>
<p>Beide Komponenten funktionieren vollkommen unabhängig voneinander. Die <code>PriceTable</code> kann nicht nur Crypto-Preise anzeigen, die <code>withCryptoPrices</code>-Komponente muss ihre Daten nicht zwangsweise in einer <code>PriceTable</code> darstellen. Wir haben hier also zwei vollständig gekapselte und wiederverwendbare Komponenten erstellt!</p>
<p>Doch wie bringen wir die beiden nun zusammen? Ganz einfach indem wir die <code>PriceTable</code>-Komponente als Parameter an die <code>withCryptoPrices</code>-Komponente übergeben. Aha! Und das sieht wie folgt aus:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> CryptoPriceTable = withCryptoPrices(PriceTable);</code></pre>
<p>Rendern wir nun eine Instanz der <code>CryptoPriceTable</code>, stößt die <strong>Higher Order Component</strong> beim <code>componentDidMount()</code> einen API-Request an und übergibt das Ergebnis dieses Requests an die ihr übergebene <code>PriceTable</code>-Komponente. Diese kümmert sich anschließend nur noch um die entsprechende Darstellung.</p>
<pre><code class="hljs jsx language-jsx">ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CryptoPriceTable</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Dadurch ergeben sich großartige Möglichkeiten für uns. Erst einmal sind beide Komponenten unabhängig voneinander testbar. Mehr dazu gibt es im entsprechenden Kapitel, wo wir uns nochmal gezielt anschauen wie einfach man insbesondere Layout-Komponenten mittels Snapshot-Tests testen kann.</p>
<p>Weiter haben wir nun eben die Möglichkeit auch andere Layout-Komponenten mit der <code>withCryptoPrices</code>-HOC zu „verbinden“. Um dieses mächtige Konzept einmal anhand eines Beispiels zu verdeutlichen, geben wir die Preise nun im CSV-Format aus. Unsere HOC bleibt dabei völlig unverändert. Unsere Layout-Komponente könnte wie folgt implementiert werden:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> PriceCSV = <span class="hljs-function">(<span class="hljs-params">{ isLoading, items, loadData, separator = <span class="hljs-string">';'</span> }</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (isLoading) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading prices. Please be patient.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
  }

  <span class="hljs-keyword">if</span> (!items || items.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
        No data available. <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{loadData}</span>&gt;</span>Try again<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
    );
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>
      {items.map(
        ({ name, symbol, quotes }) =&gt;
          `${name}${separator}${symbol}${separator}${quotes.EUR.price}\n`
      )}
    <span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span></span>
  );
};</code></pre>
<p>Und damit haben wir auch schon unsere CSV-Layout-Komponente implementiert. Wieder schauen wir zuerst ob noch Daten geladen werden, anschließend schauen wir erneut ob <code>items</code> vorhanden sind. Hier könnte man anfangen darüber nachzudenken auch dies in einer weiteren HOC zu bündeln, denn HOCs lassen sich beliebig ineinander schachteln, sind es doch am Ende lediglich Funktionen die als Parameter an andere Funktionen weitergegeben werden.</p>
<p>Zuletzt rendern wir den tatsächlichen Output: wir iterieren durch die Liste der <code>items</code>, picken uns über die <strong>Object Destructuring</strong> Syntax die für uns relevanten Eigenschaften <code>name</code>, <code>symbol</code> und <code>quotes</code> heraus und umschließen die einzelnen Zeilen mit einem <code>pre</code>-Element um den Zeilenumbruch am Ende der Zeile korrekt darzustellen.</p>
<p>Anders als bei der <code>PriceTable</code> haben wir hier allerdings noch eine weitere (optionale) Prop eingeführt: <code>separator</code> - um der Render-Komponente mitzuteilen welches Trennzeichen sie bei der Darstellung der Daten verwenden soll. Die Prop kann wie in JSX üblich bei der Verwendung der Komponente als simple Prop angegeben werden:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> CryptoCSV = withCryptoPrices(PriceCSV);

ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CryptoCSV</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">","</span> /&gt;</span>, document.getElementById('root'));</span></code></pre>
<p>Allerdings wird dafür eine Änderung an unserer ursprünglichen <code>withCryptoPrices</code>-HOC notwendig. Momentan werden lediglich die fest definierten Props <code>isLoading</code>, <code>items</code> und <code>loadData</code> an die Kind-Komponente (<code>WrappedComponent</code>) übergeben:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span>
    <span class="hljs-attr">isLoading</span>=<span class="hljs-string">{isLoading}</span>
    <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span>
    <span class="hljs-attr">loadData</span>=<span class="hljs-string">{this.loadData}</span>
  /&gt;</span>
);</span></code></pre>
<p>Damit die in <code>&lt;CryptoCSV separator="," /&gt;</code> angegebene separator-Prop auch korrekt an die <code>PriceCSV</code>-Komponente übergeben wird, müssen wir unserer HOC mitteilen, dass sie auch alle weiteren Props an die <code>WrappedComponent</code> übergibt. Je nach Einsatzzweck können weitere erlaubte Props entweder explizit übergeben werden oder aber, es werden einfach <strong>sämtliche</strong> weiteren Props übergeben:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span>
    {<span class="hljs-attr">...this.props</span>}
    <span class="hljs-attr">isLoading</span>=<span class="hljs-string">{isLoading}</span>
    <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span>
    <span class="hljs-attr">loadData</span>=<span class="hljs-string">{this.loadData}</span>
  /&gt;</span>
);</span></code></pre>
<p>Entscheidend ist hier Zeile 3: mittels <code>{...this.props}</code>. Über die Spread-Syntax leiten wir hier sämtliche Props an die Kind-Komponente weiter.</p>
</div><div class="chapter">
<h1 id="functions-as-a-child-und-render-props">Functions as a Child und Render Props</h1>
<p><strong>Functions as Children</strong> und <strong>Render Props</strong> werden in der offiziellen React-Dokumentation jeweils separat beschrieben, wobei <strong>Functions as Children</strong> im Kapitel zu <strong>Render Props</strong> ebenfalls erwähnt werden. Da beide vom Prinzip her ziemlich identisch funktionieren, möchte ich die beiden Konzepte in einem Kapitel beschreiben. Doch erst einmal: worum geht es überhaupt?</p>
<p>Wir wissen bereits, dass der Wert einer Prop in JSX jeder beliebige valide Ausdruck in JavaScript sein kann. Auch aufgerufene Funktionen können Ausdrücke zurückgeben und so können wir nicht nur Strings, Booleans, Arrays, Objekte, andere React Elements oder <code>null</code> als Wert für unsere Props verwenden sondern eben auch den return-Wert einer aufgerufenen Funktion. Wir haben auch gelernt, dass <code>children</code> in React nur eine Art Sonderform einer Prop sind und so haben die folgenden beiden Zeilen jeweils das gleiche Rendering-Ergebnis zur Folge:</p>
<pre><code class="hljs jsx language-jsx">&lt;MyComponent&gt;Ich bin ein Child-Element&lt;/MyComponent&gt;
&lt;MyComponent children="Ich bin ein Child-Element" /&gt;</code></pre>
<p>In der <code>MyComponent</code>-Komponente kann dann mittels <code>props.children</code> auf den <em>Ich bin ein Child-Element</em> Text zugegriffen werden.</p>
<p>Dies können wir uns zu nutze machen und eben auch Funktionen übergeben die dann in der <code>render()</code>-Methode einer Komponente aufgerufen werden. Die Idee dahinter ist, dass auf diesem Weg beliebige Daten von einer Komponente in die nächste übergeben werden können. Ähnlich wie bei <strong>Higher Order Components</strong>, jedoch mit etwas mehr Flexibilität. So müssen wir z.B. nicht die ganze Komponente mit einer <strong>Higher Order Component</strong> „verbinden“ sondern können dies einfach mittendrin im JSX unserer Komponente tun. Denken wir zurück an die <code>withFormatting</code> HOC aus dem vorherigen Kapitel. Eine entsprechende als <strong>Function as a Child (FaaC)</strong> Komponente implementiert könnte etwa so aussehen:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-keyword">const</span> bold = <span class="hljs-function">(<span class="hljs-params">string</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>{string}<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span></span>;
};

<span class="hljs-keyword">const</span> italic = <span class="hljs-function">(<span class="hljs-params">string</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>{string}<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span></span>;
};

<span class="hljs-keyword">const</span> Formatter = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> props.children !== <span class="hljs-string">'function'</span>) {
    <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">'children prop must be a function!'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">return</span> props.children({ bold, italic });
};</code></pre>
<p>Wir definieren also wieder eine <code>bold</code> und eine <code>italic</code> Funktion, prüfen in der <code>Formatter</code>-Komponente ob die übergebene <code>children</code>-Prop eine Funktion ist und rufen diese Funktion auf. Weiter übergeben wir ihr als einzigen Parameter ein Objekt mit den Eigenschaften <code>bold</code> mit der <code>bold</code>-Funktion als Wert sowie <code>italic</code> mit der <code>italic</code>-Funktion als Wert. Gleichzeitig geben wir die aufgerufene Funktion aus der Komponente zurück.</p>
<p>Bei der Verwendung dieser <strong>Function as a Child</strong>-Komponente wird dann eben eine Funktion im JSX als Kind-Element übergeben. Dies funktioniert wie folgt:</p>
<pre><code class="hljs jsx language-jsx">&lt;div&gt;
  &lt;p&gt;Dieser Text hat keinerlei Kenntnis der Formatter-Funktionen&lt;/p&gt;
  &lt;Formatter&gt;
    {({ bold }) =&gt; &lt;p&gt;Dieser Text hingegen {bold('sehr wohl')}&lt;/p&gt;}
  &lt;/Formatter&gt;
&lt;/div&gt;</code></pre>
<p>Der Nutzen dieses Ansatzes ist die besagte Flexibilität, da wir nun nicht mehr die ganze Komponente selbst mit einer Higher Order Funktion verbinden müssen nur um vielleicht an einer einzigen Stelle auf dessen wiederverwendbare Funktionalität zurückgreifen zu können. Anders als bei Higher Order Components ist es auf diese Art auf möglich Parameter direkt aus dem JSX an die Function as a Child Komponente zu übergeben und so mit dieser zu kommunizieren.</p>
<p>Schauen wir uns dazu noch einmal unser zweites Beispiel aus dem Kapitel über Higher Order Components an, die Preisliste der Kryptowährungen, und implementieren diese als Function as a Child:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CryptoPrices</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">items</span>: [],
  };

  componentDidMount() {
    <span class="hljs-keyword">this</span>.loadData();
  }

  loadData = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">true</span>,
    }));

    <span class="hljs-keyword">const</span> { limit } = <span class="hljs-keyword">this</span>.props;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> cryptoTicker = <span class="hljs-keyword">await</span> fetch(
        <span class="hljs-string">`https://api.coinmarketcap.com/v2/ticker/?limit=<span class="hljs-subst">${limit ||
          <span class="hljs-number">10</span>}</span>&amp;convert=EUR`</span>
      );
      <span class="hljs-keyword">const</span> cryptoTickerResponse = <span class="hljs-keyword">await</span> cryptoTicker.json();

      <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
        <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">items</span>: <span class="hljs-keyword">this</span>.convertResponseToArray(cryptoTickerResponse),
      }));
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
        <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>,
      }));
    }
  };

  convertResponseToArray = <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.entries(response.data).map(<span class="hljs-function">(<span class="hljs-params">[id, item]</span>) =&gt;</span> item);
  };

  render() {
    <span class="hljs-keyword">const</span> { isLoading, items } = <span class="hljs-keyword">this</span>.state;
    <span class="hljs-keyword">const</span> { children } = <span class="hljs-keyword">this</span>.props;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> children !== <span class="hljs-string">'function'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">return</span> children({
      isLoading,
      items,
      <span class="hljs-attr">loadData</span>: <span class="hljs-keyword">this</span>.loadData,
    });
  }
}</code></pre>
<p>Auf den ersten Blick sieht die Komponente gar nicht mal so anders aus als die Higher Order Component aus dem vorherigen Kapitel. Doch wer genau hinschaut erkennt:</p>
<ul>
<li>Es wird keine weitere Komponente mehr erzeugt und zurückgegeben sondern es wird direkt mit der Komponente gearbeitet</li>
<li>Die <code>loadData</code>-Methode greift auf this.props zu um daraus die <code>limit</code>-Prop abzulesen. Diese wird benutzt um sie als Parameter für den API Call zu verwenden.</li>
<li>Die <code>render()</code>-Methode gibt nun keine in die Komponente herein gegebene Komponente mehr zurück sondern ruft stattdessen die <code>children</code>-Funktion aus, die sie aus ihren eigenen Props bekommt.</li>
<li>Die <code>children</code>-Funktion hingegen bekommt den Lade-Status (<code>isLoading</code>), sowie letztendlich die items zurück.</li>
</ul>
<p>Die Verwendung dieser Komponente ist dann ähnlich zu der aus dem ersten Beispiel mit dem kleinen Unterschied, dass wir der Komponente optional eine <code>limit</code> Prop übergeben können:</p>
<pre><code class="hljs jsx language-jsx">&lt;div&gt;
  &lt;h1&gt;Current Crypto Currency Prices&lt;/h1&gt;
  &lt;CryptoPrices limit={5}&gt;
    {({ isLoading, items }) =&gt;
      isLoading ? (
        &lt;p&gt;Loading prices. Please be patient.&lt;/p&gt;
      ) : (
        &lt;ul&gt;
          {items.map((item) =&gt; (
            &lt;li&gt;
              {item.name} ({item.symbol}): EUR {item.quotes.EUR.price}
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
      )
    }
  &lt;/CryptoPrices&gt;
&lt;/div&gt;</code></pre>
<p>An dieser Stelle kommt ebenfalls auch wieder die <code>PriceTable</code>-Komponente ins Spiel. Diese erwartete genau die drei Props die wir aus der <code>CryptoPrices</code>-Komponente zurückgeben. Na, so ein Zufall! Schauen wir uns das doch einmal an, wie wir die beiden miteinander verbinden können:</p>
<pre><code class="hljs jsx language-jsx">&lt;CryptoPrices limit={<span class="hljs-number">5</span>}&gt;
  {({ isLoading, items, loadData }) =&gt; (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">PriceTable</span> <span class="hljs-attr">isLoading</span>=<span class="hljs-string">{isLoading}</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span> <span class="hljs-attr">loadData</span>=<span class="hljs-string">{loadData}</span> /&gt;</span>
  )}
<span class="hljs-tag">&lt;/<span class="hljs-name">CryptoPrices</span>&gt;</span></span></code></pre>
<p>Oder um es mittels der Spread-Syntax kurz zu machen:</p>
<pre><code class="hljs jsx language-jsx">&lt;CryptoPrices limit={<span class="hljs-number">5</span>}&gt;{(props) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">PriceTable</span> {<span class="hljs-attr">...props</span>} /&gt;</span>}<span class="hljs-tag">&lt;/<span class="hljs-name">CryptoPrices</span>&gt;</span></span></code></pre>
<p>Auf diese Art und Weise haben wir eine sehr hohe Flexibilität gewährleistet, müssen Komponenten jedoch nicht starr über eine HOC mit der Logik verbinden, was uns einiges an „organisatorischem Aufwand“ erspart.</p>
<p>Doch Vorsicht: Functions as a Child-Komponenten haben auch eine Einschränkung die Higher Order Components nicht haben. Nämlich können die Daten die wir aus einer FaaC-Komponente beziehen <strong>nur innerhalb von JSX</strong> verwendet werden! Möchten wir also relativ abstrakte Methoden über eine höher in der Komponenten-Hierarchie stehende Logik-Komponente bereitstellen ist dies mit einer FaaC-Komponente erst einmal nicht oder nur umständlich möglich!</p>
<h3 id="render-props">Render Props</h3>
<p>Doch Moment mal, wie war das jetzt eigentlich mit den <strong>Render Props</strong> und was ist das jetzt genau und wie unterscheiden sich diese von <strong>Function as a Child</strong>-Komponenten?</p>
<p>Vereinfacht gesagt: nur durch den Namen der Prop. Zwei sehr populäre Libraries aus der React-Welt (React Router und Downshift) hatten irgendwann damit angefangen <code>render</code> als Name für Props zu benutzen die Funktionen als Wert erwarten. Und so würde unsere CryptoPrices-Komponente wenn wir statt <code>children</code> eine <code>render</code>-Prop benutzen so aussehen:</p>
<pre><code class="hljs jsx language-jsx">&lt;CryptoPrices limit={<span class="hljs-number">5</span>} render={(props) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">PriceTable</span> {<span class="hljs-attr">...props</span>} /&gt;</span>} /&gt;</span></code></pre>
<p>Innerhalb der <code>CryptoPrices</code>-Komponente muss es dann natürlich heißen:</p>
<pre><code class="hljs jsx language-jsx">render() {
  <span class="hljs-keyword">const</span> { isLoading, items } = <span class="hljs-keyword">this</span>.state;
  <span class="hljs-keyword">const</span> { render } = <span class="hljs-keyword">this</span>.props;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> render !== <span class="hljs-string">"function"</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-comment">// Achtung: dieses render() hat nichts mit der gleichnamigen Komponenten Methode</span>
  <span class="hljs-comment">// zu tun sondern kommt über this.props.render in die Komponente hinein!</span>
  <span class="hljs-keyword">return</span> render({
    isLoading,
    items,
    <span class="hljs-attr">loadData</span>: <span class="hljs-keyword">this</span>.loadData
  });
}</code></pre>
<p>Ist also ein Stück weit auch Geschmackssache. Dabei seid ihr natürlich auf den Namen <code>render</code> nicht nicht festgelegt sondern könnt einfach jeder beliebigen Prop einfach eine Funktion übergeben und diese somit zu einer <em>„Render Prop“</em> machen.</p>
<p>Dabei ist es auch möglich beliebig viele solcher Props in einer Komponente zu haben. Wollt ihr beispielsweise eine Komponente haben die euch eine Tabelle ausgibt, welche einen Tabellenkopf sowie einen Body besitzt, wobei beide jeweils Daten aus der Komponente beziehen ist auch dies kein Problem!</p>
<h3 id="render-props-in-verbindung-mit-higher-order-components">Render Props in Verbindung mit Higher Order Components</h3>
<p>Zum Abschluss noch ein kleiner Trick: solltet ihr tatsächlich einmal eine <strong>Higher Order Component</strong> benötigen und ihr habt bereits eine <strong>FaaC-</strong> oder <strong>Render Prop</strong>-Komponente, könnt ihr auch in der HOC verwenden:</p>
<pre><code class="hljs jsx language-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withCryptoPrices</span>(<span class="hljs-params">WrappedComponent</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    render() {
      <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CryptoPrices</span>&gt;</span>
          {(cryptoPriceProps) =&gt; (
            <span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> {<span class="hljs-attr">...this.props</span>} {<span class="hljs-attr">...cryptoPriceProps</span>} /&gt;</span>
          )}
        <span class="hljs-tag">&lt;/<span class="hljs-name">CryptoPrices</span>&gt;</span>
      );
    }
  };
}</span></code></pre>
</div><div class="chapter">
<h1 id="context-api">Context API</h1>
</div><div class="chapter">
<h1 id="error-boundaries">Error Boundaries</h1>
</div><div class="chapter">
<h1 id="portals">Portals</h1>
</div><div class="chapter">
<h1 id="die-praxis">Die Praxis</h1>
</div><div class="chapter">
<h1 id="das-ecosystem">Das Ecosystem</h1>
</div>
  </body>
</html>
