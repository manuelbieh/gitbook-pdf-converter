<p><div class="chapter"></p>
<h1 id="ab-ins-kalte-wasser">Ab ins kalte Wasser</h1>
<p>Nun hatten wir bereits das „Was“, das „Wann“ und das „Wo“. Kommen wir also zum „Wie“ und schreiben unsere erste kleine <strong>React-Komponente</strong>. Neben <strong>React</strong> selbst benötigen wir für die Ausgabe unserer App im Browser auch das Package <strong>ReactDOM</strong> um unsere Anwendung <strong>mounten</strong> zu können, also grob gesagt: im Browser nutzbar zu machen.</p>
<p>Ein sehr minimalistisches Setup um schnell mit React loslegen zu können, sieht wie folgt aus:</p>
<pre><code class="markup language-markup">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8" /&gt;
&lt;title&gt;Hallo React!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="app"&gt;&lt;/div&gt;
&lt;script crossorigin src="https://unpkg.com/react@16.3.0/umd/react.development.js"&gt;&lt;/script&gt;
&lt;script crossorigin src="https://unpkg.com/react-dom@16.3.0/umd/react-dom.development.js"&gt;&lt;/script&gt;
&lt;script&gt;
// Platzhalter für unsere erste Komponente
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>Wir erstellen also das Grundgerüst für ein gewöhnliches HTML-Dokument und laden <strong>React</strong> und <strong>ReactDOM</strong> in der jeweils aktuellsten Stable-Version vom unpkg-CDN die uns dann jeweils als globale Variable im <code>window</code> Objekt unter <code>window.React</code> und <code>window.ReactDOM</code> zur Verfügung stehen. Ansonsten sehen wir hier vorerst nur eine leere Seite mit einem (noch inhaltlosen) <code>&lt;div id="app"&gt;</code>. Dieses div nutzen wir gleich als sogenannte <strong>Mount-Node</strong>, um dort unsere erste React-Komponente anzuzeigen.</p>
<div class="hint hint--info">
<p>Sind mehrere React-Komponenten im Spiel redet man üblicherweise von einer <strong>App</strong>, <strong>WebApp</strong> oder <strong>Single Page App</strong>. Die Grenzen ab wann eine Komponente als App bezeichnet wird sind dabei aber fließend. Einige Entwickler reden auch schon bei einer einzigen Komponente von einer App. 
Eine feste Definition gibt es dafür nicht.</p>
</div>
<p>Starten wir also klassischerweise mit dem üblichen „Hello World“ Beispiel und setzen das Script an die Stelle an der sich oben der Platzhalter befindet:</p>
<pre><code class="javascript language-javascript">&lt;script&gt;
class HelloWorld extends React.Component {
  render() {
    return React.createElement('div', {id: 'hello-world'}, 'Hello World');
  }
}
ReactDOM.render(
  React.createElement(HelloWorld), 
  document.getElementById('app')
);
&lt;/script&gt;</code></pre>
<p>Und damit haben wir bereits die erste einfache React-Komponente implementiert! Setzen wir diesen Code nun an die Stelle unseres Platzhalters aus dem vorangegangenen Code-Snippet. Sehen wir im Browser die folgende Ausgabe:</p>
<p><img src="https://lh5.googleusercontent.com/ELTAFiAHh3_lN8ETxYyNxvdSHs9-ZRzdmEZG_43ecDI3tkbJWtqLoaELcyMkKIKQcxyVs0kiaw9WYG_Ms5y8iUUId2mIh5-PiAunsc7XwlQ5BVS51YHi4S3LUcY-Vocb7VbCFqJJ" alt="Unsere erste React-Komponente im Browser." /></p>
<p>Sieht für’s Erste einmal gar nicht so kompliziert aus, oder? Gehen wir den Code einmal Schritt für Schritt durch. Die relevanten Stellen im Code habe ich fett hervorgehoben.</p>
<blockquote>
  <p><code>class HelloWorld</code></p>
</blockquote>
<p>Hier geben wir dem Kind seinen Namen. Unsere Komponente hat in dem Fall den Namen <strong>HelloWorld</strong>. Bei der Namensgebung sind der Fantasie grundsätzlich keine Grenzen gesetzt, doch Achtung: React-Komponenten müssen stets mit einem Großbuchstaben beginnen! So wäre helloWorld also kein gültiger Name für eine Komponente, HELLOWORLD hingegen schon (wenn auch sehr unüblich). </p>
<p>Die gängige Art der Benennung von Komponenten folgt der <strong>UpperCamelCase</strong>-Form. Auch längere, selbsterklärende Namen sind nicht unüblich. So wäre also ein Name wie <strong>UserNotificationView</strong> für eine Komponente keineswegs exotisch.</p>
<blockquote>
  <p><code>extends React.Component</code></p>
</blockquote>
<p>Hier erweitern wir schließlich die React interne Klasse <code>React.Component</code> wodurch unsere Klasse erst einmal zu einer Komponente wird die wir in React nutzen können. Neben der <code>React.Component</code> gibt es außerdem auch die <code>React.PureComponent</code> als Komponenten-Klasse, sowie eine zweite Form, die sogenannte <em>Stateless Functional Component</em>. Diese ist lediglich eine JavaScript-Funktion, die einem bestimmten Muster folgt. Beide werden im weiteren Verlauf noch ausführlich beleuchtet und sind an dieser Stelle zum Grundverständnis erst einmal weniger wichtig.</p>
<blockquote>
  <p><code>render()</code></p>
</blockquote>
<p>Unsere Komponente besteht lediglich aus dem einzigen zwingenden Bestandteil einer Komponente, nämlich der <code>render()</code>-Methode. Mittels dieser wird React mitgeteilt wie die entsprechende Komponente dargestellt (sprich: „gerendert“) werden soll. Eine Komponente hat zwingend einen <code>return</code>-Wert. Dieser kann entweder ein explizites <code>null</code> sein, um bewusst nichts anzuzeigen (jedoch nicht <code>undefined</code>!), ein React-Element oder ab Version 16 auch ein Array. </p>
<p>Im Falle eines Arrays darf dieser Strings, Numbers, React-Elemente oder ebenfalls <code>null</code> als Werte enthalten. Die <code>render()</code>-Methode dient also dazu <strong>deklarativ</strong> den Zustand unseres Interfaces zu beschreiben. All das, was wir aus ihr per <code>return</code> zurückgeben, zeigt uns React beim Render als Ausgabe im Browser an.</p>
<p>Auch wenn man in der Gestaltung seiner JavaScript-Klassen natürlich vollkommen frei ist und dies daher nicht zwingend notwendig ist, so wird die <code>render()</code>-Methode der Übersicht halber in der Regel meist als letzte Methode einer Komponente definiert. So wird es z.B. in den Code-Guidelines von AirBnB, dessen Entwickler in der React-Szene sehr aktiv sind, aber auch von vielen anderen bekannten Entwicklern vorgegeben oder zumindest empfohlen. Aus eigener Erfahrung kann ich sagen, dass es die tägliche Arbeit mit React deutlich erleichtert sich an diese Empfehlung zu halten<strong>.</strong></p>
<p><img src="../.gitbook/assets/react-no-render-error.png" alt="Fehlermeldungen bei fehlender render()-Methode" /></p>
<p><img src="../.gitbook/assets/invalid-react-element.png" alt="Fehlermeldung bei fehlerhafter render()-Methode" /></p>
<blockquote>
  <p><code>React.createElement()</code></p>
</blockquote>
<p>Wie erwähnt gibt die <code>render()</code>-Methode einer React-<strong>Komponente</strong> in den meisten Fällen ein React-<strong>Element</strong> zurück. React-Elemente sind sozusagen die kleinsten aber dennoch gleichzeitig auch die wesentlichen Bausteine in einer React-Anwendung und beschreiben, was der Benutzer letztendlich auf seinem Bildschirm sieht. Neben <code>React.cloneElement()</code> und <code>React.isValidElement()</code> ist <code>React.createElement()</code> zudem eine von lediglich 3 Top-Level API-Methoden (sieht man von mittlerweile veralteten (_deprecated_) Methoden einmal ab).</p>
<p>Die Methode erwartet 1-n Parameter:</p>
<ol>
<li>„Typ“, das können HTML-Elemente als String sein, also bspw. <code>'div'</code>, <code>'span'</code> oder <code>'p'</code> aber auch andere React-Komponenten</li>
<li>sog. „Props“, das sind im grundlegenden Sinn schreibgeschützte (_readonly_) „Eigenschafts-Objekte“ einer Komponente. Abgeleitet vom engl. <em>Properties</em> eben.</li>
<li>sowie beliebig viele Child-Elemente, die selbst wieder React-Elemente, Arrays, Funktionen oder auch einfacher Text sein können. Eine Komponente muss aber nicht zwingend auch Child-Elemente besitzen.</li>
</ol>
<p>Letztendlich ist ein React-Element unter der Haube nichts weiter als ein unveränderliches (_immutable_) JavaScript-Objekt zur Beschreibung von Eigenschaften, die React mitteilen wie etwas (und was) dargestellt werden soll. React erstellt nach dieser Beschreibung den sog. <strong>Virtual DOM</strong>. Dieser stellt eine Repräsentation des HTML-Baums in Form eines JavaScript-Objekts dar. Dieser Virtual DOM wird anschließend von React dazu verwendet, um möglichst nur die Teile einer Anwendung zu aktualisieren, in denen auch tatsächlich eine Änderung vorgenommen wurde wenn der Benutzer mit der Anwendung interagiert, Daten verändert oder Events auslöst.</p>
<p>Dadurch, dass React nicht einfach bei jeder State-Änderung die komplette Anwendung neu in den DOM schreibt, was aus Performance-Sicht sehr kostspielig wäre, sondern mittels eines <strong>Reconciliation</strong> (zu deutsch etwa <em>„Abgleich“</em>) genannten Prozesses zuvor vergleicht was geändert wurde, somit die Schreibvorgänge auf ein Minimum reduziert, wird ein zum Teil enormer Geschwindigkeitsvorteil erreicht gegenüber anderen Frameworks und Libraries die viele DOM-Operationen vornehmen.</p>
<p>Bei der täglichen Arbeit wird man <code>React.createElement()</code> jedoch für gewöhnlich niemals in dieser Form aufrufen, da uns <strong>JSX</strong>, eine von Facebook entwickelte Syntax-Erweiterung für JavaScript, diese Arbeit abnehmen und massiv erleichtern wird. Dennoch halte ich es für wichtig von ihrer Existenz zu wissen um zu verstehen wie JSX im Hintergrund arbeitet um so mögliche Fehlerquellen ausschließen zu können.</p>
<p>JSX sieht auf den ersten Blick aus wie HTML bzw. XML/XHTML, jedoch mit deutlich erweitertem Funktionsumfang und der Möglichkeit JavaScript-Ausdrücke darin zu verwenden. JSX ist eine Abstraktion um die Art, wie man React-Elemente erstellt, für den Entwickler <strong>deutlich</strong> zu vereinfachen. So würde unser obiges Beispiel:</p>
<p><code>React.createElement('div', {id: 'hello-world'}, 'Hello World');</code></p>
<p>würde in JSX ganz einfach wie folgt geschrieben werden:</p>
<p>`</p>
<div id="hello-world">Hello World</div>
<p>`</p>
<p>Was für viele Einsteiger in React erst einmal sehr befremdlich wirkt, ich habe in diesem Zusammenhang mal den schönen Begriff <strong>JSX-Schock</strong> gelesen, stellt sich aber nach etwas Rumspielerei jedoch sehr schnell als unglaublich praktisch heraus und ist meines Erachtens einer der wesentlichen Gründe warum React letztendlich so viel an Beliebtheit in so kurzer Zeit gewonnen hat.</p>
<p>Zurück zum Wesentlichen: unsere Komponente bekommt hier also über den <code>return</code>-Wert der <code>render()</code>-Methode mitgeteilt, dass sie ein Element vom typ <code>div</code> mit der id <code>hello-world</code> und dem Child-Element (in dem Fall ein Textknoten) mit dem Inhalt <code>Hallo Welt</code> darstellen soll.</p>
<blockquote>
  <p><code>ReactDOM.render(Element, Container)</code></p>
</blockquote>
<p>Zu guter Letzt kommt mit <code>ReactDOM</code> die zweite Library ins Spiel. <strong>ReactDOM</strong> ist zuständig für das Zusammenspiel von React mit dem DOM (_Document Object Model_), also oberflächlich ausgedrückt: dem <strong>Web-Browser</strong>. Wie auch schon React selbst besitzt ReactDOM nur sehr wenige Top-Level API-Methoden. Wir konzentrieren uns vorerst mal auf die <code>render()</code>-Methode, die sozusagen das Herzstück von ReactDOM im Browser ist.</p>
<p>Trotz der Namensgleichheit hat diese <strong>erst einmal nicht direkt</strong> etwas mit der Methode innerhalb von React-Komponenten zu tun sondern dient lediglich dazu ein React-Element in eine angegebene <strong>„Root-Node“</strong> zu rendern, also stumpf ausgedrückt: anzuzeigen. In unserem Fall wird hier unsere <code>HelloWorld</code>-Komponente in das `</p>
<div id="app">` gerendert. Die Root-Node wird dabei **nicht ersetzt**, sondern die Komponente wird **innerhalb des Containers** eingesetzt.

**ReactDOM** sorgt also dafür, **dass** wir die angegebene Komponente überhaupt erst einmal im Browser sehen können. **Was** wir dort genau sehen haben wir zuvor in der `render()`-Methode der Komponente über das angegebene React-Element als `return`-Wert beschrieben. Beim Aufruf von `ReactDOM.render()` wird dabei das als ersten Parameter angegebene **React-Element** in den als zweiten Parameter angegebenen **Container** gerendert.

<div class="hint hint--info">
<p>Beim ersten Aufruf der <code>ReactDOM.render()</code> Funktion wird sämtlicher möglicherweise vorhandene Inhalt des Ziel-Containers durch den von React ermittelten, darzustellenden Inhalt ersetzt. Bei jedem weiteren Aufruf verwendet React einen internen Vergleichs-Algorithmus für bestmögliche Effizienz, um nicht die komplette Anwendung vollständig neu zu rendern! </p>
<p>In der Praxis ist das allerdings weniger von Relevanz, da die <code>ReactDOM.render()</code> Funktion bei der Erstellung von Single Page Apps üblicherweise nur einmalig ausgeführt wird, für gewöhnlich beim Laden einer Seite. React verändert dabei auch niemals den Ziel-Container selbst, sondern lediglich dessen Inhalt. Besitzt das Container-Element also eigene Attribute wie  Klassen, IDs oder data-Attribute bleiben diese auch nach dem Aufruf von <code>ReactDOM.render()</code> erhalten.</p>
</div>

Damit ist das generelle Funktionsprinzip von React erst einmal erklärt, unsere erste Komponente ist implementiert und im Browser zu sehen!


</div>